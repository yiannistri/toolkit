{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"GitOps Toolkit \u00b6 The GitOps Toolkit is a set of composable APIs and specialized tools that can be used to build a Continuous Delivery platform on top of Kubernetes. These tools are build with Kubernetes controller-runtime libraries, and they can be dynamically configured with Kubernetes custom resources either by cluster admins or by other automated tools. The GitOps Toolkit components interact with each other via Kubernetes events and are responsible for the reconciliation of their designated API objects. Work in Progress We envision a future where Flux v2 and Helm Operator v2 will be assembled from the GitOps Toolkit components. The Flux CD team is looking for feedback and help as the toolkit is in an active experimentation phase. If you wish to take part in this quest please reach out to us on Slack or GitHub. Target features: Source management Kustomize and Helm support Event-based and on-a-schedule reconciliation Role-based reconciliation (multi-tenancy) Health assessment (clusters and workloads) Dependency management (infra and workloads) Alerting to external systems (webhook senders) External events handling (webhook receivers) Source write-back (automated patching) Policy driven validation (OPA, admission controllers) Seamless integration with Git providers (GitHub, GitLab, Bitbucket) Interoperability with workflow providers (GitHub Actions, Tekton, Argo) Interoperability with CAPI providers Components: Toolkit CLI Source Controller GitRepository CRD HelmRepository CRD HelmChart CRD Bucket CRD Kustomize Controller Kustomization CRD Helm Controller HelmRelease CRD Notification Controller Provider CRD Alert CRD Receiver CRD To get started with the toolkit please follow this guide . Community \u00b6 The GitOps Toolkit is always looking for new contributors and there are a multitude of ways to get involved. Depending on what you want to do, some of the following bits might be your first steps: Join our upcoming dev meetings ( meeting access and agenda Talk to us in the #flux channel on CNCF Slack Join the planning discussions And if you are completely new to the GitOps Toolkit, take a look at our Get Started guide and give us feedback Check out how to contribute to the project We are looking forward to seeing you with us!","title":"Introduction"},{"location":"#gitops-toolkit","text":"The GitOps Toolkit is a set of composable APIs and specialized tools that can be used to build a Continuous Delivery platform on top of Kubernetes. These tools are build with Kubernetes controller-runtime libraries, and they can be dynamically configured with Kubernetes custom resources either by cluster admins or by other automated tools. The GitOps Toolkit components interact with each other via Kubernetes events and are responsible for the reconciliation of their designated API objects. Work in Progress We envision a future where Flux v2 and Helm Operator v2 will be assembled from the GitOps Toolkit components. The Flux CD team is looking for feedback and help as the toolkit is in an active experimentation phase. If you wish to take part in this quest please reach out to us on Slack or GitHub. Target features: Source management Kustomize and Helm support Event-based and on-a-schedule reconciliation Role-based reconciliation (multi-tenancy) Health assessment (clusters and workloads) Dependency management (infra and workloads) Alerting to external systems (webhook senders) External events handling (webhook receivers) Source write-back (automated patching) Policy driven validation (OPA, admission controllers) Seamless integration with Git providers (GitHub, GitLab, Bitbucket) Interoperability with workflow providers (GitHub Actions, Tekton, Argo) Interoperability with CAPI providers Components: Toolkit CLI Source Controller GitRepository CRD HelmRepository CRD HelmChart CRD Bucket CRD Kustomize Controller Kustomization CRD Helm Controller HelmRelease CRD Notification Controller Provider CRD Alert CRD Receiver CRD To get started with the toolkit please follow this guide .","title":"GitOps Toolkit"},{"location":"#community","text":"The GitOps Toolkit is always looking for new contributors and there are a multitude of ways to get involved. Depending on what you want to do, some of the following bits might be your first steps: Join our upcoming dev meetings ( meeting access and agenda Talk to us in the #flux channel on CNCF Slack Join the planning discussions And if you are completely new to the GitOps Toolkit, take a look at our Get Started guide and give us feedback Check out how to contribute to the project We are looking forward to seeing you with us!","title":"Community"},{"location":"cmd/gotk/","text":"gotk \u00b6 Command line utility for assembling Kubernetes CD pipelines Synopsis \u00b6 Command line utility for assembling Kubernetes CD pipelines the GitOps way. Examples \u00b6 # Check prerequisites gotk check --pre # Install the latest version of the toolkit gotk install --version=master # Create a source from a public Git repository gotk create source git webapp-latest \\ --url=https://github.com/stefanprodan/podinfo \\ --branch=master \\ --interval=3m # List GitRepository sources and their status gotk get sources git # Trigger a GitRepository source reconciliation gotk reconcile source git gotk-system # Export GitRepository sources in YAML format gotk export source git --all > sources.yaml # Create a Kustomization for deploying a series of microservices gotk create kustomization webapp-dev \\ --source=webapp-latest \\ --path=\"./deploy/webapp/\" \\ --prune=true \\ --interval=5m \\ --validation=client \\ --health-check=\"Deployment/backend.webapp\" \\ --health-check=\"Deployment/frontend.webapp\" \\ --health-check-timeout=2m # Trigger a git sync of the Kustomization's source and apply changes gotk reconcile kustomization webapp-dev --with-source # Suspend a Kustomization reconciliation gotk suspend kustomization webapp-dev # Export Kustomizations in YAML format gotk export kustomization --all > kustomizations.yaml # Resume a Kustomization reconciliation gotk resume kustomization webapp-dev # Delete a Kustomization gotk delete kustomization webapp-dev # Delete a GitRepository source gotk delete source git webapp-latest # Uninstall the toolkit and delete CRDs gotk uninstall --crds Options \u00b6 -h, --help help for gotk --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk bootstrap - Bootstrap toolkit components gotk check - Check requirements and installation gotk completion - Generates completion scripts for various shells gotk create - Create or update sources and resources gotk delete - Delete sources and resources gotk export - Export resources in YAML format gotk get - Get sources and resources gotk install - Install the toolkit components gotk reconcile - Reconcile sources and resources gotk resume - Resume suspended resources gotk suspend - Suspend resources gotk uninstall - Uninstall the toolkit components","title":"Overview"},{"location":"cmd/gotk/#gotk","text":"Command line utility for assembling Kubernetes CD pipelines","title":"gotk"},{"location":"cmd/gotk/#synopsis","text":"Command line utility for assembling Kubernetes CD pipelines the GitOps way.","title":"Synopsis"},{"location":"cmd/gotk/#examples","text":"# Check prerequisites gotk check --pre # Install the latest version of the toolkit gotk install --version=master # Create a source from a public Git repository gotk create source git webapp-latest \\ --url=https://github.com/stefanprodan/podinfo \\ --branch=master \\ --interval=3m # List GitRepository sources and their status gotk get sources git # Trigger a GitRepository source reconciliation gotk reconcile source git gotk-system # Export GitRepository sources in YAML format gotk export source git --all > sources.yaml # Create a Kustomization for deploying a series of microservices gotk create kustomization webapp-dev \\ --source=webapp-latest \\ --path=\"./deploy/webapp/\" \\ --prune=true \\ --interval=5m \\ --validation=client \\ --health-check=\"Deployment/backend.webapp\" \\ --health-check=\"Deployment/frontend.webapp\" \\ --health-check-timeout=2m # Trigger a git sync of the Kustomization's source and apply changes gotk reconcile kustomization webapp-dev --with-source # Suspend a Kustomization reconciliation gotk suspend kustomization webapp-dev # Export Kustomizations in YAML format gotk export kustomization --all > kustomizations.yaml # Resume a Kustomization reconciliation gotk resume kustomization webapp-dev # Delete a Kustomization gotk delete kustomization webapp-dev # Delete a GitRepository source gotk delete source git webapp-latest # Uninstall the toolkit and delete CRDs gotk uninstall --crds","title":"Examples"},{"location":"cmd/gotk/#options","text":"-h, --help help for gotk --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options"},{"location":"cmd/gotk/#see-also","text":"gotk bootstrap - Bootstrap toolkit components gotk check - Check requirements and installation gotk completion - Generates completion scripts for various shells gotk create - Create or update sources and resources gotk delete - Delete sources and resources gotk export - Export resources in YAML format gotk get - Get sources and resources gotk install - Install the toolkit components gotk reconcile - Reconcile sources and resources gotk resume - Resume suspended resources gotk suspend - Suspend resources gotk uninstall - Uninstall the toolkit components","title":"SEE ALSO"},{"location":"cmd/gotk_bootstrap/","text":"gotk bootstrap \u00b6 Bootstrap toolkit components Synopsis \u00b6 The bootstrap sub-commands bootstrap the toolkit components on the targeted Git provider. Options \u00b6 --arch string arch can be amd64 or arm64 (default \"amd64\") --branch string default branch (for GitHub this must match the default branch setting for the organization) (default \"main\") --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) -h, --help help for bootstrap --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --log-level string set the controllers log level (default \"info\") --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true) Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk - Command line utility for assembling Kubernetes CD pipelines gotk bootstrap github - Bootstrap toolkit components in a GitHub repository gotk bootstrap gitlab - Bootstrap toolkit components in a GitLab repository","title":"Bootstrap"},{"location":"cmd/gotk_bootstrap/#gotk-bootstrap","text":"Bootstrap toolkit components","title":"gotk bootstrap"},{"location":"cmd/gotk_bootstrap/#synopsis","text":"The bootstrap sub-commands bootstrap the toolkit components on the targeted Git provider.","title":"Synopsis"},{"location":"cmd/gotk_bootstrap/#options","text":"--arch string arch can be amd64 or arm64 (default \"amd64\") --branch string default branch (for GitHub this must match the default branch setting for the organization) (default \"main\") --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) -h, --help help for bootstrap --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --log-level string set the controllers log level (default \"info\") --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true)","title":"Options"},{"location":"cmd/gotk_bootstrap/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_bootstrap/#see-also","text":"gotk - Command line utility for assembling Kubernetes CD pipelines gotk bootstrap github - Bootstrap toolkit components in a GitHub repository gotk bootstrap gitlab - Bootstrap toolkit components in a GitLab repository","title":"SEE ALSO"},{"location":"cmd/gotk_bootstrap_github/","text":"gotk bootstrap github \u00b6 Bootstrap toolkit components in a GitHub repository Synopsis \u00b6 The bootstrap github command creates the GitHub repository if it doesn't exists and commits the toolkit components manifests to the master branch. Then it configures the target cluster to synchronize with the repository. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. gotk bootstrap github [flags] Examples \u00b6 # Create a GitHub personal access token and export it as an env var export GITHUB_TOKEN=<my-token> # Run bootstrap for a private repo owned by a GitHub organization gotk bootstrap github --owner=<organization> --repository=<repo name> # Run bootstrap for a private repo and assign organization teams to it gotk bootstrap github --owner=<organization> --repository=<repo name> --team=<team1 slug> --team=<team2 slug> # Run bootstrap for a repository path gotk bootstrap github --owner=<organization> --repository=<repo name> --path=dev-cluster # Run bootstrap for a public repository on a personal account gotk bootstrap github --owner=<user> --repository=<repo name> --private=false --personal=true # Run bootstrap for a private repo hosted on GitHub Enterprise gotk bootstrap github --owner=<organization> --repository=<repo name> --hostname=<domain> # Run bootstrap for a an existing repository with a branch named main gotk bootstrap github --owner=<organization> --repository=<repo name> --branch=main Options \u00b6 -h, --help help for github --hostname string GitHub hostname (default \"github.com\") --interval duration sync interval (default 1m0s) --owner string GitHub user or organization name --path string repository path, when specified the cluster sync will be scoped to this path --personal is personal repository --private is private repository (default true) --repository string GitHub repository name --team stringArray GitHub team to be given maintainer access Options inherited from parent commands \u00b6 --arch string arch can be amd64 or arm64 (default \"amd64\") --branch string default branch (for GitHub this must match the default branch setting for the organization) (default \"main\") --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --log-level string set the controllers log level (default \"info\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true) SEE ALSO \u00b6 gotk bootstrap - Bootstrap toolkit components","title":"Bootstrap github"},{"location":"cmd/gotk_bootstrap_github/#gotk-bootstrap-github","text":"Bootstrap toolkit components in a GitHub repository","title":"gotk bootstrap github"},{"location":"cmd/gotk_bootstrap_github/#synopsis","text":"The bootstrap github command creates the GitHub repository if it doesn't exists and commits the toolkit components manifests to the master branch. Then it configures the target cluster to synchronize with the repository. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. gotk bootstrap github [flags]","title":"Synopsis"},{"location":"cmd/gotk_bootstrap_github/#examples","text":"# Create a GitHub personal access token and export it as an env var export GITHUB_TOKEN=<my-token> # Run bootstrap for a private repo owned by a GitHub organization gotk bootstrap github --owner=<organization> --repository=<repo name> # Run bootstrap for a private repo and assign organization teams to it gotk bootstrap github --owner=<organization> --repository=<repo name> --team=<team1 slug> --team=<team2 slug> # Run bootstrap for a repository path gotk bootstrap github --owner=<organization> --repository=<repo name> --path=dev-cluster # Run bootstrap for a public repository on a personal account gotk bootstrap github --owner=<user> --repository=<repo name> --private=false --personal=true # Run bootstrap for a private repo hosted on GitHub Enterprise gotk bootstrap github --owner=<organization> --repository=<repo name> --hostname=<domain> # Run bootstrap for a an existing repository with a branch named main gotk bootstrap github --owner=<organization> --repository=<repo name> --branch=main","title":"Examples"},{"location":"cmd/gotk_bootstrap_github/#options","text":"-h, --help help for github --hostname string GitHub hostname (default \"github.com\") --interval duration sync interval (default 1m0s) --owner string GitHub user or organization name --path string repository path, when specified the cluster sync will be scoped to this path --personal is personal repository --private is private repository (default true) --repository string GitHub repository name --team stringArray GitHub team to be given maintainer access","title":"Options"},{"location":"cmd/gotk_bootstrap_github/#options-inherited-from-parent-commands","text":"--arch string arch can be amd64 or arm64 (default \"amd64\") --branch string default branch (for GitHub this must match the default branch setting for the organization) (default \"main\") --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --log-level string set the controllers log level (default \"info\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true)","title":"Options inherited from parent commands"},{"location":"cmd/gotk_bootstrap_github/#see-also","text":"gotk bootstrap - Bootstrap toolkit components","title":"SEE ALSO"},{"location":"cmd/gotk_bootstrap_gitlab/","text":"gotk bootstrap gitlab \u00b6 Bootstrap toolkit components in a GitLab repository Synopsis \u00b6 The bootstrap gitlab command creates the GitLab repository if it doesn't exists and commits the toolkit components manifests to the master branch. Then it configures the target cluster to synchronize with the repository. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. gotk bootstrap gitlab [flags] Examples \u00b6 # Create a GitLab API token and export it as an env var export GITLAB_TOKEN=<my-token> # Run bootstrap for a private repo owned by a GitLab group gotk bootstrap gitlab --owner=<group> --repository=<repo name> # Run bootstrap for a repository path gotk bootstrap gitlab --owner=<group> --repository=<repo name> --path=dev-cluster # Run bootstrap for a public repository on a personal account gotk bootstrap gitlab --owner=<user> --repository=<repo name> --private=false --personal=true # Run bootstrap for a private repo hosted on a GitLab server gotk bootstrap gitlab --owner=<group> --repository=<repo name> --hostname=<domain> # Run bootstrap for a an existing repository with a branch named main gotk bootstrap gitlab --owner=<organization> --repository=<repo name> --branch=main Options \u00b6 -h, --help help for gitlab --hostname string GitLab hostname (default \"gitlab.com\") --interval duration sync interval (default 1m0s) --owner string GitLab user or group name --path string repository path, when specified the cluster sync will be scoped to this path --personal is personal repository --private is private repository (default true) --repository string GitLab repository name --ssh-hostname string GitLab SSH hostname, defaults to hostname if not specified Options inherited from parent commands \u00b6 --arch string arch can be amd64 or arm64 (default \"amd64\") --branch string default branch (for GitHub this must match the default branch setting for the organization) (default \"main\") --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --log-level string set the controllers log level (default \"info\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true) SEE ALSO \u00b6 gotk bootstrap - Bootstrap toolkit components","title":"Bootstrap gitlab"},{"location":"cmd/gotk_bootstrap_gitlab/#gotk-bootstrap-gitlab","text":"Bootstrap toolkit components in a GitLab repository","title":"gotk bootstrap gitlab"},{"location":"cmd/gotk_bootstrap_gitlab/#synopsis","text":"The bootstrap gitlab command creates the GitLab repository if it doesn't exists and commits the toolkit components manifests to the master branch. Then it configures the target cluster to synchronize with the repository. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. gotk bootstrap gitlab [flags]","title":"Synopsis"},{"location":"cmd/gotk_bootstrap_gitlab/#examples","text":"# Create a GitLab API token and export it as an env var export GITLAB_TOKEN=<my-token> # Run bootstrap for a private repo owned by a GitLab group gotk bootstrap gitlab --owner=<group> --repository=<repo name> # Run bootstrap for a repository path gotk bootstrap gitlab --owner=<group> --repository=<repo name> --path=dev-cluster # Run bootstrap for a public repository on a personal account gotk bootstrap gitlab --owner=<user> --repository=<repo name> --private=false --personal=true # Run bootstrap for a private repo hosted on a GitLab server gotk bootstrap gitlab --owner=<group> --repository=<repo name> --hostname=<domain> # Run bootstrap for a an existing repository with a branch named main gotk bootstrap gitlab --owner=<organization> --repository=<repo name> --branch=main","title":"Examples"},{"location":"cmd/gotk_bootstrap_gitlab/#options","text":"-h, --help help for gitlab --hostname string GitLab hostname (default \"gitlab.com\") --interval duration sync interval (default 1m0s) --owner string GitLab user or group name --path string repository path, when specified the cluster sync will be scoped to this path --personal is personal repository --private is private repository (default true) --repository string GitLab repository name --ssh-hostname string GitLab SSH hostname, defaults to hostname if not specified","title":"Options"},{"location":"cmd/gotk_bootstrap_gitlab/#options-inherited-from-parent-commands","text":"--arch string arch can be amd64 or arm64 (default \"amd64\") --branch string default branch (for GitHub this must match the default branch setting for the organization) (default \"main\") --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --log-level string set the controllers log level (default \"info\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true)","title":"Options inherited from parent commands"},{"location":"cmd/gotk_bootstrap_gitlab/#see-also","text":"gotk bootstrap - Bootstrap toolkit components","title":"SEE ALSO"},{"location":"cmd/gotk_check/","text":"gotk check \u00b6 Check requirements and installation Synopsis \u00b6 The check command will perform a series of checks to validate that the local environment is configured correctly and if the installed components are healthy. gotk check [flags] Examples \u00b6 # Run pre-installation checks gotk check --pre # Run installation checks gotk check Options \u00b6 --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) -h, --help help for check --pre only run pre-installation checks Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk - Command line utility for assembling Kubernetes CD pipelines","title":"Check"},{"location":"cmd/gotk_check/#gotk-check","text":"Check requirements and installation","title":"gotk check"},{"location":"cmd/gotk_check/#synopsis","text":"The check command will perform a series of checks to validate that the local environment is configured correctly and if the installed components are healthy. gotk check [flags]","title":"Synopsis"},{"location":"cmd/gotk_check/#examples","text":"# Run pre-installation checks gotk check --pre # Run installation checks gotk check","title":"Examples"},{"location":"cmd/gotk_check/#options","text":"--components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) -h, --help help for check --pre only run pre-installation checks","title":"Options"},{"location":"cmd/gotk_check/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_check/#see-also","text":"gotk - Command line utility for assembling Kubernetes CD pipelines","title":"SEE ALSO"},{"location":"cmd/gotk_completion/","text":"gotk completion \u00b6 Generates completion scripts for various shells Synopsis \u00b6 The completion sub-command generates completion scripts for various shells Options \u00b6 -h, --help help for completion Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk - Command line utility for assembling Kubernetes CD pipelines gotk completion bash - Generates bash completion scripts gotk completion fish - Generates fish completion scripts gotk completion powershell - Generates powershell completion scripts gotk completion zsh - Generates zsh completion scripts","title":"Gotk completion"},{"location":"cmd/gotk_completion/#gotk-completion","text":"Generates completion scripts for various shells","title":"gotk completion"},{"location":"cmd/gotk_completion/#synopsis","text":"The completion sub-command generates completion scripts for various shells","title":"Synopsis"},{"location":"cmd/gotk_completion/#options","text":"-h, --help help for completion","title":"Options"},{"location":"cmd/gotk_completion/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_completion/#see-also","text":"gotk - Command line utility for assembling Kubernetes CD pipelines gotk completion bash - Generates bash completion scripts gotk completion fish - Generates fish completion scripts gotk completion powershell - Generates powershell completion scripts gotk completion zsh - Generates zsh completion scripts","title":"SEE ALSO"},{"location":"cmd/gotk_completion_bash/","text":"gotk completion bash \u00b6 Generates bash completion scripts Synopsis \u00b6 Generates bash completion scripts gotk completion bash [flags] Examples \u00b6 To load completion run . <(gotk completion bash) To configure your bash shell to load completions for each session add to your bashrc # ~/.bashrc or ~/.profile command -v gotk >/dev/null && . <(gotk completion bash) Options \u00b6 -h, --help help for bash Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk completion - Generates completion scripts for various shells","title":"Gotk completion bash"},{"location":"cmd/gotk_completion_bash/#gotk-completion-bash","text":"Generates bash completion scripts","title":"gotk completion bash"},{"location":"cmd/gotk_completion_bash/#synopsis","text":"Generates bash completion scripts gotk completion bash [flags]","title":"Synopsis"},{"location":"cmd/gotk_completion_bash/#examples","text":"To load completion run . <(gotk completion bash) To configure your bash shell to load completions for each session add to your bashrc # ~/.bashrc or ~/.profile command -v gotk >/dev/null && . <(gotk completion bash)","title":"Examples"},{"location":"cmd/gotk_completion_bash/#options","text":"-h, --help help for bash","title":"Options"},{"location":"cmd/gotk_completion_bash/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_completion_bash/#see-also","text":"gotk completion - Generates completion scripts for various shells","title":"SEE ALSO"},{"location":"cmd/gotk_completion_fish/","text":"gotk completion fish \u00b6 Generates fish completion scripts Synopsis \u00b6 Generates fish completion scripts gotk completion fish [flags] Examples \u00b6 To load completion run . <(gotk completion fish) To configure your fish shell to load completions for each session write this script to your completions dir: gotk completion fish > ~/.config/fish/completions/gotk See http://fishshell.com/docs/current/index.html#completion-own for more details Options \u00b6 -h, --help help for fish Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk completion - Generates completion scripts for various shells","title":"Gotk completion fish"},{"location":"cmd/gotk_completion_fish/#gotk-completion-fish","text":"Generates fish completion scripts","title":"gotk completion fish"},{"location":"cmd/gotk_completion_fish/#synopsis","text":"Generates fish completion scripts gotk completion fish [flags]","title":"Synopsis"},{"location":"cmd/gotk_completion_fish/#examples","text":"To load completion run . <(gotk completion fish) To configure your fish shell to load completions for each session write this script to your completions dir: gotk completion fish > ~/.config/fish/completions/gotk See http://fishshell.com/docs/current/index.html#completion-own for more details","title":"Examples"},{"location":"cmd/gotk_completion_fish/#options","text":"-h, --help help for fish","title":"Options"},{"location":"cmd/gotk_completion_fish/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_completion_fish/#see-also","text":"gotk completion - Generates completion scripts for various shells","title":"SEE ALSO"},{"location":"cmd/gotk_completion_powershell/","text":"gotk completion powershell \u00b6 Generates powershell completion scripts Synopsis \u00b6 Generates powershell completion scripts gotk completion powershell [flags] Examples \u00b6 To load completion run . <(gotk completion powershell) To configure your powershell shell to load completions for each session add to your powershell profile Windows: cd \"$env:USERPROFILE\\Documents\\WindowsPowerShell\\Modules\" gotk completion >> gotk-completion.ps1 Linux: cd \"${XDG_CONFIG_HOME:-\"$HOME/.config/\"}/powershell/modules\" gotk completion >> gotk-completions.ps1 Options \u00b6 -h, --help help for powershell Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk completion - Generates completion scripts for various shells","title":"Gotk completion powershell"},{"location":"cmd/gotk_completion_powershell/#gotk-completion-powershell","text":"Generates powershell completion scripts","title":"gotk completion powershell"},{"location":"cmd/gotk_completion_powershell/#synopsis","text":"Generates powershell completion scripts gotk completion powershell [flags]","title":"Synopsis"},{"location":"cmd/gotk_completion_powershell/#examples","text":"To load completion run . <(gotk completion powershell) To configure your powershell shell to load completions for each session add to your powershell profile Windows: cd \"$env:USERPROFILE\\Documents\\WindowsPowerShell\\Modules\" gotk completion >> gotk-completion.ps1 Linux: cd \"${XDG_CONFIG_HOME:-\"$HOME/.config/\"}/powershell/modules\" gotk completion >> gotk-completions.ps1","title":"Examples"},{"location":"cmd/gotk_completion_powershell/#options","text":"-h, --help help for powershell","title":"Options"},{"location":"cmd/gotk_completion_powershell/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_completion_powershell/#see-also","text":"gotk completion - Generates completion scripts for various shells","title":"SEE ALSO"},{"location":"cmd/gotk_completion_zsh/","text":"gotk completion zsh \u00b6 Generates zsh completion scripts Synopsis \u00b6 Generates zsh completion scripts gotk completion zsh [flags] Examples \u00b6 To load completion run . <(gotk completion zsh) && compdef _gotk gotk To configure your zsh shell to load completions for each session add to your zshrc # ~/.zshrc or ~/.profile command -v gotk >/dev/null && . <(gotk completion zsh) && compdef _gotk gotk or write a cached file in one of the completion directories in your ${fpath}: echo \"${fpath// /\\n}\" | grep -i completion gotk completions zsh > _gotk mv _gotk ~/.oh-my-zsh/completions # oh-my-zsh mv _gotk ~/.zprezto/modules/completion/external/src/ # zprezto Options \u00b6 -h, --help help for zsh Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk completion - Generates completion scripts for various shells","title":"Gotk completion zsh"},{"location":"cmd/gotk_completion_zsh/#gotk-completion-zsh","text":"Generates zsh completion scripts","title":"gotk completion zsh"},{"location":"cmd/gotk_completion_zsh/#synopsis","text":"Generates zsh completion scripts gotk completion zsh [flags]","title":"Synopsis"},{"location":"cmd/gotk_completion_zsh/#examples","text":"To load completion run . <(gotk completion zsh) && compdef _gotk gotk To configure your zsh shell to load completions for each session add to your zshrc # ~/.zshrc or ~/.profile command -v gotk >/dev/null && . <(gotk completion zsh) && compdef _gotk gotk or write a cached file in one of the completion directories in your ${fpath}: echo \"${fpath// /\\n}\" | grep -i completion gotk completions zsh > _gotk mv _gotk ~/.oh-my-zsh/completions # oh-my-zsh mv _gotk ~/.zprezto/modules/completion/external/src/ # zprezto","title":"Examples"},{"location":"cmd/gotk_completion_zsh/#options","text":"-h, --help help for zsh","title":"Options"},{"location":"cmd/gotk_completion_zsh/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_completion_zsh/#see-also","text":"gotk completion - Generates completion scripts for various shells","title":"SEE ALSO"},{"location":"cmd/gotk_create/","text":"gotk create \u00b6 Create or update sources and resources Synopsis \u00b6 The create sub-commands generate sources and resources. Options \u00b6 --export export in YAML format to stdout -h, --help help for create --interval duration source sync interval (default 1m0s) --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk - Command line utility for assembling Kubernetes CD pipelines gotk create helmrelease - Create or update a HelmRelease resource gotk create kustomization - Create or update a Kustomization resource gotk create source - Create or update sources","title":"Create"},{"location":"cmd/gotk_create/#gotk-create","text":"Create or update sources and resources","title":"gotk create"},{"location":"cmd/gotk_create/#synopsis","text":"The create sub-commands generate sources and resources.","title":"Synopsis"},{"location":"cmd/gotk_create/#options","text":"--export export in YAML format to stdout -h, --help help for create --interval duration source sync interval (default 1m0s) --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2)","title":"Options"},{"location":"cmd/gotk_create/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_create/#see-also","text":"gotk - Command line utility for assembling Kubernetes CD pipelines gotk create helmrelease - Create or update a HelmRelease resource gotk create kustomization - Create or update a Kustomization resource gotk create source - Create or update sources","title":"SEE ALSO"},{"location":"cmd/gotk_create_helmrelease/","text":"gotk create helmrelease \u00b6 Create or update a HelmRelease resource Synopsis \u00b6 The helmrelease create command generates a HelmRelease resource for a given HelmRepository source. gotk create helmrelease [name] [flags] Examples \u00b6 # Create a HelmRelease with a chart from a HelmRepository source gotk create hr podinfo \\ --interval=10m \\ --source=HelmRepository/podinfo \\ --chart=podinfo \\ --chart-version=\">4.0.0\" # Create a HelmRelease with a chart from a GitRepository source gotk create hr podinfo \\ --interval=10m \\ --source=GitRepository/podinfo \\ --chart=./charts/podinfo # Create a HelmRelease with a chart from a Bucket source gotk create hr podinfo \\ --interval=10m \\ --source=Bucket/podinfo \\ --chart=./charts/podinfo # Create a HelmRelease with values from a local YAML file gotk create hr podinfo \\ --source=HelmRepository/podinfo \\ --chart=podinfo \\ --values=./my-values.yaml # Create a HelmRelease with a custom release name gotk create hr podinfo \\ --release-name=podinfo-dev --source=HelmRepository/podinfo \\ --chart=podinfo \\ # Create a HelmRelease targeting another namespace than the resource gotk create hr podinfo \\ --target-namespace=default \\ --source=HelmRepository/podinfo \\ --chart=podinfo # Create a HelmRelease definition on disk without applying it on the cluster gotk create hr podinfo \\ --source=HelmRepository/podinfo \\ --chart=podinfo \\ --values=./values.yaml \\ --export > podinfo-release.yaml Options \u00b6 --chart string Helm chart name or path --chart-version string Helm chart version, accepts a semver range (ignored for charts from GitRepository sources) --depends-on stringArray HelmReleases that must be ready before this release can be installed, supported formats '<name>' and '<namespace>/<name>' -h, --help help for helmrelease --release-name string name used for the Helm release, defaults to a composition of '[<target-namespace>-]<hr-name>' --source string source that contains the chart (<kind>/<name>) --target-namespace string namespace to install this release, defaults to the HelmRelease namespace --values string local path to the values.yaml file Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk create - Create or update sources and resources","title":"Create helmrelease"},{"location":"cmd/gotk_create_helmrelease/#gotk-create-helmrelease","text":"Create or update a HelmRelease resource","title":"gotk create helmrelease"},{"location":"cmd/gotk_create_helmrelease/#synopsis","text":"The helmrelease create command generates a HelmRelease resource for a given HelmRepository source. gotk create helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_create_helmrelease/#examples","text":"# Create a HelmRelease with a chart from a HelmRepository source gotk create hr podinfo \\ --interval=10m \\ --source=HelmRepository/podinfo \\ --chart=podinfo \\ --chart-version=\">4.0.0\" # Create a HelmRelease with a chart from a GitRepository source gotk create hr podinfo \\ --interval=10m \\ --source=GitRepository/podinfo \\ --chart=./charts/podinfo # Create a HelmRelease with a chart from a Bucket source gotk create hr podinfo \\ --interval=10m \\ --source=Bucket/podinfo \\ --chart=./charts/podinfo # Create a HelmRelease with values from a local YAML file gotk create hr podinfo \\ --source=HelmRepository/podinfo \\ --chart=podinfo \\ --values=./my-values.yaml # Create a HelmRelease with a custom release name gotk create hr podinfo \\ --release-name=podinfo-dev --source=HelmRepository/podinfo \\ --chart=podinfo \\ # Create a HelmRelease targeting another namespace than the resource gotk create hr podinfo \\ --target-namespace=default \\ --source=HelmRepository/podinfo \\ --chart=podinfo # Create a HelmRelease definition on disk without applying it on the cluster gotk create hr podinfo \\ --source=HelmRepository/podinfo \\ --chart=podinfo \\ --values=./values.yaml \\ --export > podinfo-release.yaml","title":"Examples"},{"location":"cmd/gotk_create_helmrelease/#options","text":"--chart string Helm chart name or path --chart-version string Helm chart version, accepts a semver range (ignored for charts from GitRepository sources) --depends-on stringArray HelmReleases that must be ready before this release can be installed, supported formats '<name>' and '<namespace>/<name>' -h, --help help for helmrelease --release-name string name used for the Helm release, defaults to a composition of '[<target-namespace>-]<hr-name>' --source string source that contains the chart (<kind>/<name>) --target-namespace string namespace to install this release, defaults to the HelmRelease namespace --values string local path to the values.yaml file","title":"Options"},{"location":"cmd/gotk_create_helmrelease/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_create_helmrelease/#see-also","text":"gotk create - Create or update sources and resources","title":"SEE ALSO"},{"location":"cmd/gotk_create_kustomization/","text":"gotk create kustomization \u00b6 Create or update a Kustomization resource Synopsis \u00b6 The kustomization source create command generates a Kustomize resource for a given source. gotk create kustomization [name] [flags] Examples \u00b6 # Create a Kustomization resource from a source at a given path gotk create kustomization contour \\ --source=contour \\ --path=\"./examples/contour/\" \\ --prune=true \\ --interval=10m \\ --validation=client \\ --health-check=\"Deployment/contour.projectcontour\" \\ --health-check=\"DaemonSet/envoy.projectcontour\" \\ --health-check-timeout=3m # Create a Kustomization resource that depends on the previous one gotk create kustomization webapp \\ --depends-on=contour \\ --source=webapp \\ --path=\"./deploy/overlays/dev\" \\ --prune=true \\ --interval=5m \\ --validation=client # Create a Kustomization resource that references a Bucket gotk create kustomization secrets \\ --source=Bucket/secrets \\ --prune=true \\ --interval=5m Options \u00b6 --decryption-provider string enables secrets decryption, provider can be 'sops' --decryption-secret string set the Kubernetes secret name that contains the OpenPGP private keys used for sops decryption --depends-on stringArray Kustomization that must be ready before this Kustomization can be applied, supported formats '<name>' and '<namespace>/<name>' --health-check stringArray workload to be included in the health assessment, in the format '<kind>/<name>.<namespace>' --health-check-timeout duration timeout of health checking operations (default 2m0s) -h, --help help for kustomization --path string path to the directory containing the Kustomization file (default \"./\") --prune enable garbage collection --sa-name string service account name --sa-namespace string service account namespace --source string source that contains the Kubernetes manifests in the format '[<kind>/]<name>', where kind can be GitRepository or Bucket, if kind is not specified it defaults to GitRepository --validation string validate the manifests before applying them on the cluster, can be 'client' or 'server' Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk create - Create or update sources and resources","title":"Create kustomization"},{"location":"cmd/gotk_create_kustomization/#gotk-create-kustomization","text":"Create or update a Kustomization resource","title":"gotk create kustomization"},{"location":"cmd/gotk_create_kustomization/#synopsis","text":"The kustomization source create command generates a Kustomize resource for a given source. gotk create kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_create_kustomization/#examples","text":"# Create a Kustomization resource from a source at a given path gotk create kustomization contour \\ --source=contour \\ --path=\"./examples/contour/\" \\ --prune=true \\ --interval=10m \\ --validation=client \\ --health-check=\"Deployment/contour.projectcontour\" \\ --health-check=\"DaemonSet/envoy.projectcontour\" \\ --health-check-timeout=3m # Create a Kustomization resource that depends on the previous one gotk create kustomization webapp \\ --depends-on=contour \\ --source=webapp \\ --path=\"./deploy/overlays/dev\" \\ --prune=true \\ --interval=5m \\ --validation=client # Create a Kustomization resource that references a Bucket gotk create kustomization secrets \\ --source=Bucket/secrets \\ --prune=true \\ --interval=5m","title":"Examples"},{"location":"cmd/gotk_create_kustomization/#options","text":"--decryption-provider string enables secrets decryption, provider can be 'sops' --decryption-secret string set the Kubernetes secret name that contains the OpenPGP private keys used for sops decryption --depends-on stringArray Kustomization that must be ready before this Kustomization can be applied, supported formats '<name>' and '<namespace>/<name>' --health-check stringArray workload to be included in the health assessment, in the format '<kind>/<name>.<namespace>' --health-check-timeout duration timeout of health checking operations (default 2m0s) -h, --help help for kustomization --path string path to the directory containing the Kustomization file (default \"./\") --prune enable garbage collection --sa-name string service account name --sa-namespace string service account namespace --source string source that contains the Kubernetes manifests in the format '[<kind>/]<name>', where kind can be GitRepository or Bucket, if kind is not specified it defaults to GitRepository --validation string validate the manifests before applying them on the cluster, can be 'client' or 'server'","title":"Options"},{"location":"cmd/gotk_create_kustomization/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_create_kustomization/#see-also","text":"gotk create - Create or update sources and resources","title":"SEE ALSO"},{"location":"cmd/gotk_create_source/","text":"gotk create source \u00b6 Create or update sources Synopsis \u00b6 The create source sub-commands generate sources. Options \u00b6 -h, --help help for source Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk create - Create or update sources and resources gotk create source bucket - Create or update a Bucket source gotk create source git - Create or update a GitRepository source gotk create source helm - Create or update a HelmRepository source","title":"Create source"},{"location":"cmd/gotk_create_source/#gotk-create-source","text":"Create or update sources","title":"gotk create source"},{"location":"cmd/gotk_create_source/#synopsis","text":"The create source sub-commands generate sources.","title":"Synopsis"},{"location":"cmd/gotk_create_source/#options","text":"-h, --help help for source","title":"Options"},{"location":"cmd/gotk_create_source/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_create_source/#see-also","text":"gotk create - Create or update sources and resources gotk create source bucket - Create or update a Bucket source gotk create source git - Create or update a GitRepository source gotk create source helm - Create or update a HelmRepository source","title":"SEE ALSO"},{"location":"cmd/gotk_create_source_bucket/","text":"gotk create source bucket \u00b6 Create or update a Bucket source Synopsis \u00b6 The create source bucket command generates a Bucket resource and waits for it to be downloaded. For Buckets with static authentication, the credentials are stored in a Kubernetes secret. gotk create source bucket [name] [flags] Examples \u00b6 # Create a source from a Buckets using static authentication gotk create source bucket podinfo \\ --bucket-name=podinfo \\ --endpoint=minio.minio.svc.cluster.local:9000 \\ --insecure=true \\ --access-key=myaccesskey \\ --secret-key=mysecretkey \\ --interval=10m # Create a source from an Amazon S3 Bucket using IAM authentication gotk create source bucket podinfo \\ --bucket-name=podinfo \\ --provider=aws \\ --endpoint=s3.amazonaws.com \\ --region=us-east-1 \\ --interval=10m Options \u00b6 --access-key string the bucket access key --bucket-name string the bucket name --endpoint string the bucket endpoint address -h, --help help for bucket --insecure for when connecting to a non-TLS S3 HTTP endpoint --provider string the S3 compatible storage provider name, can be 'generic' or 'aws' (default \"generic\") --region string the bucket region --secret-key string the bucket secret key Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk create source - Create or update sources","title":"Create source bucket"},{"location":"cmd/gotk_create_source_bucket/#gotk-create-source-bucket","text":"Create or update a Bucket source","title":"gotk create source bucket"},{"location":"cmd/gotk_create_source_bucket/#synopsis","text":"The create source bucket command generates a Bucket resource and waits for it to be downloaded. For Buckets with static authentication, the credentials are stored in a Kubernetes secret. gotk create source bucket [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_create_source_bucket/#examples","text":"# Create a source from a Buckets using static authentication gotk create source bucket podinfo \\ --bucket-name=podinfo \\ --endpoint=minio.minio.svc.cluster.local:9000 \\ --insecure=true \\ --access-key=myaccesskey \\ --secret-key=mysecretkey \\ --interval=10m # Create a source from an Amazon S3 Bucket using IAM authentication gotk create source bucket podinfo \\ --bucket-name=podinfo \\ --provider=aws \\ --endpoint=s3.amazonaws.com \\ --region=us-east-1 \\ --interval=10m","title":"Examples"},{"location":"cmd/gotk_create_source_bucket/#options","text":"--access-key string the bucket access key --bucket-name string the bucket name --endpoint string the bucket endpoint address -h, --help help for bucket --insecure for when connecting to a non-TLS S3 HTTP endpoint --provider string the S3 compatible storage provider name, can be 'generic' or 'aws' (default \"generic\") --region string the bucket region --secret-key string the bucket secret key","title":"Options"},{"location":"cmd/gotk_create_source_bucket/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_create_source_bucket/#see-also","text":"gotk create source - Create or update sources","title":"SEE ALSO"},{"location":"cmd/gotk_create_source_git/","text":"gotk create source git \u00b6 Create or update a GitRepository source Synopsis \u00b6 The create source git command generates a GitRepository resource and waits for it to sync. For Git over SSH, host and SSH keys are automatically generated and stored in a Kubernetes secret. For private Git repositories, the basic authentication credentials are stored in a Kubernetes secret. gotk create source git [name] [flags] Examples \u00b6 # Create a source from a public Git repository master branch gotk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --branch=master # Create a source from a Git repository pinned to specific git tag gotk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --tag=\"3.2.3\" # Create a source from a public Git repository tag that matches a semver range gotk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --tag-semver=\">=3.2.0 <3.3.0\" # Create a source from a Git repository using SSH authentication gotk create source git podinfo \\ --url=ssh://git@github.com/stefanprodan/podinfo \\ --branch=master # Create a source from a Git repository using SSH authentication and an # ECDSA P-521 curve public key gotk create source git podinfo \\ --url=ssh://git@github.com/stefanprodan/podinfo \\ --branch=master \\ --ssh-key-algorithm=ecdsa \\ --ssh-ecdsa-curve=p521 # Create a source from a Git repository using basic authentication gotk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --username=username \\ --password=password Options \u00b6 --branch string git branch (default \"master\") -h, --help help for git -p, --password string basic authentication password --ssh-ecdsa-curve ecdsaCurve SSH ECDSA public key curve (p256, p384, p521) (default p384) --ssh-key-algorithm publicKeyAlgorithm SSH public key algorithm (rsa, ecdsa, ed25519) (default rsa) --ssh-rsa-bits rsaKeyBits SSH RSA public key bit size (multiplies of 8) (default 2048) --tag string git tag --tag-semver string git tag semver range --url string git address, e.g. ssh://git@host/org/repository -u, --username string basic authentication username Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk create source - Create or update sources","title":"Create source git"},{"location":"cmd/gotk_create_source_git/#gotk-create-source-git","text":"Create or update a GitRepository source","title":"gotk create source git"},{"location":"cmd/gotk_create_source_git/#synopsis","text":"The create source git command generates a GitRepository resource and waits for it to sync. For Git over SSH, host and SSH keys are automatically generated and stored in a Kubernetes secret. For private Git repositories, the basic authentication credentials are stored in a Kubernetes secret. gotk create source git [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_create_source_git/#examples","text":"# Create a source from a public Git repository master branch gotk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --branch=master # Create a source from a Git repository pinned to specific git tag gotk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --tag=\"3.2.3\" # Create a source from a public Git repository tag that matches a semver range gotk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --tag-semver=\">=3.2.0 <3.3.0\" # Create a source from a Git repository using SSH authentication gotk create source git podinfo \\ --url=ssh://git@github.com/stefanprodan/podinfo \\ --branch=master # Create a source from a Git repository using SSH authentication and an # ECDSA P-521 curve public key gotk create source git podinfo \\ --url=ssh://git@github.com/stefanprodan/podinfo \\ --branch=master \\ --ssh-key-algorithm=ecdsa \\ --ssh-ecdsa-curve=p521 # Create a source from a Git repository using basic authentication gotk create source git podinfo \\ --url=https://github.com/stefanprodan/podinfo \\ --username=username \\ --password=password","title":"Examples"},{"location":"cmd/gotk_create_source_git/#options","text":"--branch string git branch (default \"master\") -h, --help help for git -p, --password string basic authentication password --ssh-ecdsa-curve ecdsaCurve SSH ECDSA public key curve (p256, p384, p521) (default p384) --ssh-key-algorithm publicKeyAlgorithm SSH public key algorithm (rsa, ecdsa, ed25519) (default rsa) --ssh-rsa-bits rsaKeyBits SSH RSA public key bit size (multiplies of 8) (default 2048) --tag string git tag --tag-semver string git tag semver range --url string git address, e.g. ssh://git@host/org/repository -u, --username string basic authentication username","title":"Options"},{"location":"cmd/gotk_create_source_git/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_create_source_git/#see-also","text":"gotk create source - Create or update sources","title":"SEE ALSO"},{"location":"cmd/gotk_create_source_helm/","text":"gotk create source helm \u00b6 Create or update a HelmRepository source Synopsis \u00b6 The create source helm command generates a HelmRepository resource and waits for it to fetch the index. For private Helm repositories, the basic authentication credentials are stored in a Kubernetes secret. gotk create source helm [name] [flags] Examples \u00b6 # Create a source from a public Helm repository gotk create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --interval=10m # Create a source from a Helm repository using basic authentication gotk create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --username=username \\ --password=password # Create a source from a Helm repository using TLS authentication gotk create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --cert-file=./cert.crt \\ --key-file=./key.crt \\ --ca-file=./ca.crt Options \u00b6 --ca-file string TLS authentication CA file path --cert-file string TLS authentication cert file path -h, --help help for helm --key-file string TLS authentication key file path -p, --password string basic authentication password --url string Helm repository address -u, --username string basic authentication username Options inherited from parent commands \u00b6 --export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk create source - Create or update sources","title":"Create source helm"},{"location":"cmd/gotk_create_source_helm/#gotk-create-source-helm","text":"Create or update a HelmRepository source","title":"gotk create source helm"},{"location":"cmd/gotk_create_source_helm/#synopsis","text":"The create source helm command generates a HelmRepository resource and waits for it to fetch the index. For private Helm repositories, the basic authentication credentials are stored in a Kubernetes secret. gotk create source helm [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_create_source_helm/#examples","text":"# Create a source from a public Helm repository gotk create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --interval=10m # Create a source from a Helm repository using basic authentication gotk create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --username=username \\ --password=password # Create a source from a Helm repository using TLS authentication gotk create source helm podinfo \\ --url=https://stefanprodan.github.io/podinfo \\ --cert-file=./cert.crt \\ --key-file=./key.crt \\ --ca-file=./ca.crt","title":"Examples"},{"location":"cmd/gotk_create_source_helm/#options","text":"--ca-file string TLS authentication CA file path --cert-file string TLS authentication cert file path -h, --help help for helm --key-file string TLS authentication key file path -p, --password string basic authentication password --url string Helm repository address -u, --username string basic authentication username","title":"Options"},{"location":"cmd/gotk_create_source_helm/#options-inherited-from-parent-commands","text":"--export export in YAML format to stdout --interval duration source sync interval (default 1m0s) --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") --label strings set labels on the resource (can specify multiple labels with commas: label1=value1,label2=value2) -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_create_source_helm/#see-also","text":"gotk create source - Create or update sources","title":"SEE ALSO"},{"location":"cmd/gotk_delete/","text":"gotk delete \u00b6 Delete sources and resources Synopsis \u00b6 The delete sub-commands delete sources and resources. Options \u00b6 -h, --help help for delete -s, --silent delete resource without asking for confirmation Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk - Command line utility for assembling Kubernetes CD pipelines gotk delete helmrelease - Delete a HelmRelease resource gotk delete kustomization - Delete a Kustomization resource gotk delete source - Delete sources","title":"Delete"},{"location":"cmd/gotk_delete/#gotk-delete","text":"Delete sources and resources","title":"gotk delete"},{"location":"cmd/gotk_delete/#synopsis","text":"The delete sub-commands delete sources and resources.","title":"Synopsis"},{"location":"cmd/gotk_delete/#options","text":"-h, --help help for delete -s, --silent delete resource without asking for confirmation","title":"Options"},{"location":"cmd/gotk_delete/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_delete/#see-also","text":"gotk - Command line utility for assembling Kubernetes CD pipelines gotk delete helmrelease - Delete a HelmRelease resource gotk delete kustomization - Delete a Kustomization resource gotk delete source - Delete sources","title":"SEE ALSO"},{"location":"cmd/gotk_delete_helmrelease/","text":"gotk delete helmrelease \u00b6 Delete a HelmRelease resource Synopsis \u00b6 The delete helmrelease command removes the given HelmRelease from the cluster. gotk delete helmrelease [name] [flags] Examples \u00b6 # Delete a Helm release and the Kubernetes resources created by it gotk delete hr podinfo Options \u00b6 -h, --help help for helmrelease Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk delete - Delete sources and resources","title":"Delete helmrelease"},{"location":"cmd/gotk_delete_helmrelease/#gotk-delete-helmrelease","text":"Delete a HelmRelease resource","title":"gotk delete helmrelease"},{"location":"cmd/gotk_delete_helmrelease/#synopsis","text":"The delete helmrelease command removes the given HelmRelease from the cluster. gotk delete helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_delete_helmrelease/#examples","text":"# Delete a Helm release and the Kubernetes resources created by it gotk delete hr podinfo","title":"Examples"},{"location":"cmd/gotk_delete_helmrelease/#options","text":"-h, --help help for helmrelease","title":"Options"},{"location":"cmd/gotk_delete_helmrelease/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_delete_helmrelease/#see-also","text":"gotk delete - Delete sources and resources","title":"SEE ALSO"},{"location":"cmd/gotk_delete_kustomization/","text":"gotk delete kustomization \u00b6 Delete a Kustomization resource Synopsis \u00b6 The delete kustomization command deletes the given Kustomization from the cluster. gotk delete kustomization [name] [flags] Examples \u00b6 # Delete a kustomization and the Kubernetes resources created by it gotk delete kustomization podinfo Options \u00b6 -h, --help help for kustomization Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk delete - Delete sources and resources","title":"Delete kustomization"},{"location":"cmd/gotk_delete_kustomization/#gotk-delete-kustomization","text":"Delete a Kustomization resource","title":"gotk delete kustomization"},{"location":"cmd/gotk_delete_kustomization/#synopsis","text":"The delete kustomization command deletes the given Kustomization from the cluster. gotk delete kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_delete_kustomization/#examples","text":"# Delete a kustomization and the Kubernetes resources created by it gotk delete kustomization podinfo","title":"Examples"},{"location":"cmd/gotk_delete_kustomization/#options","text":"-h, --help help for kustomization","title":"Options"},{"location":"cmd/gotk_delete_kustomization/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_delete_kustomization/#see-also","text":"gotk delete - Delete sources and resources","title":"SEE ALSO"},{"location":"cmd/gotk_delete_source/","text":"gotk delete source \u00b6 Delete sources Synopsis \u00b6 The delete source sub-commands delete sources. Options \u00b6 -h, --help help for source Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk delete - Delete sources and resources gotk delete source bucket - Delete a Bucket source gotk delete source git - Delete a GitRepository source gotk delete source helm - Delete a HelmRepository source","title":"Delete source"},{"location":"cmd/gotk_delete_source/#gotk-delete-source","text":"Delete sources","title":"gotk delete source"},{"location":"cmd/gotk_delete_source/#synopsis","text":"The delete source sub-commands delete sources.","title":"Synopsis"},{"location":"cmd/gotk_delete_source/#options","text":"-h, --help help for source","title":"Options"},{"location":"cmd/gotk_delete_source/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_delete_source/#see-also","text":"gotk delete - Delete sources and resources gotk delete source bucket - Delete a Bucket source gotk delete source git - Delete a GitRepository source gotk delete source helm - Delete a HelmRepository source","title":"SEE ALSO"},{"location":"cmd/gotk_delete_source_bucket/","text":"gotk delete source bucket \u00b6 Delete a Bucket source Synopsis \u00b6 The delete source bucket command deletes the given Bucket from the cluster. gotk delete source bucket [name] [flags] Examples \u00b6 # Delete a Bucket source gotk delete source bucket podinfo Options \u00b6 -h, --help help for bucket Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk delete source - Delete sources","title":"Delete source bucket"},{"location":"cmd/gotk_delete_source_bucket/#gotk-delete-source-bucket","text":"Delete a Bucket source","title":"gotk delete source bucket"},{"location":"cmd/gotk_delete_source_bucket/#synopsis","text":"The delete source bucket command deletes the given Bucket from the cluster. gotk delete source bucket [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_delete_source_bucket/#examples","text":"# Delete a Bucket source gotk delete source bucket podinfo","title":"Examples"},{"location":"cmd/gotk_delete_source_bucket/#options","text":"-h, --help help for bucket","title":"Options"},{"location":"cmd/gotk_delete_source_bucket/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_delete_source_bucket/#see-also","text":"gotk delete source - Delete sources","title":"SEE ALSO"},{"location":"cmd/gotk_delete_source_git/","text":"gotk delete source git \u00b6 Delete a GitRepository source Synopsis \u00b6 The delete source git command deletes the given GitRepository from the cluster. gotk delete source git [name] [flags] Examples \u00b6 # Delete a Git repository gotk delete source git podinfo Options \u00b6 -h, --help help for git Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk delete source - Delete sources","title":"Delete source git"},{"location":"cmd/gotk_delete_source_git/#gotk-delete-source-git","text":"Delete a GitRepository source","title":"gotk delete source git"},{"location":"cmd/gotk_delete_source_git/#synopsis","text":"The delete source git command deletes the given GitRepository from the cluster. gotk delete source git [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_delete_source_git/#examples","text":"# Delete a Git repository gotk delete source git podinfo","title":"Examples"},{"location":"cmd/gotk_delete_source_git/#options","text":"-h, --help help for git","title":"Options"},{"location":"cmd/gotk_delete_source_git/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_delete_source_git/#see-also","text":"gotk delete source - Delete sources","title":"SEE ALSO"},{"location":"cmd/gotk_delete_source_helm/","text":"gotk delete source helm \u00b6 Delete a HelmRepository source Synopsis \u00b6 The delete source helm command deletes the given HelmRepository from the cluster. gotk delete source helm [name] [flags] Examples \u00b6 # Delete a Helm repository gotk delete source helm podinfo Options \u00b6 -h, --help help for helm Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk delete source - Delete sources","title":"Delete source helm"},{"location":"cmd/gotk_delete_source_helm/#gotk-delete-source-helm","text":"Delete a HelmRepository source","title":"gotk delete source helm"},{"location":"cmd/gotk_delete_source_helm/#synopsis","text":"The delete source helm command deletes the given HelmRepository from the cluster. gotk delete source helm [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_delete_source_helm/#examples","text":"# Delete a Helm repository gotk delete source helm podinfo","title":"Examples"},{"location":"cmd/gotk_delete_source_helm/#options","text":"-h, --help help for helm","title":"Options"},{"location":"cmd/gotk_delete_source_helm/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") -s, --silent delete resource without asking for confirmation --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_delete_source_helm/#see-also","text":"gotk delete source - Delete sources","title":"SEE ALSO"},{"location":"cmd/gotk_export/","text":"gotk export \u00b6 Export resources in YAML format Synopsis \u00b6 The export sub-commands export resources in YAML format. Options \u00b6 --all select all resources -h, --help help for export Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk - Command line utility for assembling Kubernetes CD pipelines gotk export helmrelease - Export HelmRelease resources in YAML format gotk export kustomization - Export Kustomization resources in YAML format gotk export source - Export sources","title":"Export"},{"location":"cmd/gotk_export/#gotk-export","text":"Export resources in YAML format","title":"gotk export"},{"location":"cmd/gotk_export/#synopsis","text":"The export sub-commands export resources in YAML format.","title":"Synopsis"},{"location":"cmd/gotk_export/#options","text":"--all select all resources -h, --help help for export","title":"Options"},{"location":"cmd/gotk_export/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_export/#see-also","text":"gotk - Command line utility for assembling Kubernetes CD pipelines gotk export helmrelease - Export HelmRelease resources in YAML format gotk export kustomization - Export Kustomization resources in YAML format gotk export source - Export sources","title":"SEE ALSO"},{"location":"cmd/gotk_export_helmrelease/","text":"gotk export helmrelease \u00b6 Export HelmRelease resources in YAML format Synopsis \u00b6 The export helmrelease command exports one or all HelmRelease resources in YAML format. gotk export helmrelease [name] [flags] Examples \u00b6 # Export all HelmRelease resources gotk export helmrelease --all > kustomizations.yaml # Export a HelmRelease gotk export hr my-app > app-release.yaml Options \u00b6 -h, --help help for helmrelease Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk export - Export resources in YAML format","title":"Export helmrelease"},{"location":"cmd/gotk_export_helmrelease/#gotk-export-helmrelease","text":"Export HelmRelease resources in YAML format","title":"gotk export helmrelease"},{"location":"cmd/gotk_export_helmrelease/#synopsis","text":"The export helmrelease command exports one or all HelmRelease resources in YAML format. gotk export helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_export_helmrelease/#examples","text":"# Export all HelmRelease resources gotk export helmrelease --all > kustomizations.yaml # Export a HelmRelease gotk export hr my-app > app-release.yaml","title":"Examples"},{"location":"cmd/gotk_export_helmrelease/#options","text":"-h, --help help for helmrelease","title":"Options"},{"location":"cmd/gotk_export_helmrelease/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_export_helmrelease/#see-also","text":"gotk export - Export resources in YAML format","title":"SEE ALSO"},{"location":"cmd/gotk_export_kustomization/","text":"gotk export kustomization \u00b6 Export Kustomization resources in YAML format Synopsis \u00b6 The export kustomization command exports one or all Kustomization resources in YAML format. gotk export kustomization [name] [flags] Examples \u00b6 # Export all Kustomization resources gotk export kustomization --all > kustomizations.yaml # Export a Kustomization gotk export kustomization my-app > kustomization.yaml Options \u00b6 -h, --help help for kustomization Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk export - Export resources in YAML format","title":"Export kustomization"},{"location":"cmd/gotk_export_kustomization/#gotk-export-kustomization","text":"Export Kustomization resources in YAML format","title":"gotk export kustomization"},{"location":"cmd/gotk_export_kustomization/#synopsis","text":"The export kustomization command exports one or all Kustomization resources in YAML format. gotk export kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_export_kustomization/#examples","text":"# Export all Kustomization resources gotk export kustomization --all > kustomizations.yaml # Export a Kustomization gotk export kustomization my-app > kustomization.yaml","title":"Examples"},{"location":"cmd/gotk_export_kustomization/#options","text":"-h, --help help for kustomization","title":"Options"},{"location":"cmd/gotk_export_kustomization/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_export_kustomization/#see-also","text":"gotk export - Export resources in YAML format","title":"SEE ALSO"},{"location":"cmd/gotk_export_source/","text":"gotk export source \u00b6 Export sources Synopsis \u00b6 The export source sub-commands export sources in YAML format. Options \u00b6 -h, --help help for source --with-credentials include credential secrets Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk export - Export resources in YAML format gotk export source bucket - Export Bucket sources in YAML format gotk export source git - Export GitRepository sources in YAML format gotk export source helm - Export HelmRepository sources in YAML format","title":"Export source"},{"location":"cmd/gotk_export_source/#gotk-export-source","text":"Export sources","title":"gotk export source"},{"location":"cmd/gotk_export_source/#synopsis","text":"The export source sub-commands export sources in YAML format.","title":"Synopsis"},{"location":"cmd/gotk_export_source/#options","text":"-h, --help help for source --with-credentials include credential secrets","title":"Options"},{"location":"cmd/gotk_export_source/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_export_source/#see-also","text":"gotk export - Export resources in YAML format gotk export source bucket - Export Bucket sources in YAML format gotk export source git - Export GitRepository sources in YAML format gotk export source helm - Export HelmRepository sources in YAML format","title":"SEE ALSO"},{"location":"cmd/gotk_export_source_bucket/","text":"gotk export source bucket \u00b6 Export Bucket sources in YAML format Synopsis \u00b6 The export source git command exports on or all Bucket sources in YAML format. gotk export source bucket [name] [flags] Examples \u00b6 # Export all Bucket sources gotk export source bucket --all > sources.yaml # Export a Bucket source including the static credentials gotk export source bucket my-bucket --with-credentials > source.yaml Options \u00b6 -h, --help help for bucket Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets SEE ALSO \u00b6 gotk export source - Export sources","title":"Export source bucket"},{"location":"cmd/gotk_export_source_bucket/#gotk-export-source-bucket","text":"Export Bucket sources in YAML format","title":"gotk export source bucket"},{"location":"cmd/gotk_export_source_bucket/#synopsis","text":"The export source git command exports on or all Bucket sources in YAML format. gotk export source bucket [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_export_source_bucket/#examples","text":"# Export all Bucket sources gotk export source bucket --all > sources.yaml # Export a Bucket source including the static credentials gotk export source bucket my-bucket --with-credentials > source.yaml","title":"Examples"},{"location":"cmd/gotk_export_source_bucket/#options","text":"-h, --help help for bucket","title":"Options"},{"location":"cmd/gotk_export_source_bucket/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets","title":"Options inherited from parent commands"},{"location":"cmd/gotk_export_source_bucket/#see-also","text":"gotk export source - Export sources","title":"SEE ALSO"},{"location":"cmd/gotk_export_source_git/","text":"gotk export source git \u00b6 Export GitRepository sources in YAML format Synopsis \u00b6 The export source git command exports on or all GitRepository sources in YAML format. gotk export source git [name] [flags] Examples \u00b6 # Export all GitRepository sources gotk export source git --all > sources.yaml # Export a GitRepository source including the SSH key pair or basic auth credentials gotk export source git my-private-repo --with-credentials > source.yaml Options \u00b6 -h, --help help for git Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets SEE ALSO \u00b6 gotk export source - Export sources","title":"Export source git"},{"location":"cmd/gotk_export_source_git/#gotk-export-source-git","text":"Export GitRepository sources in YAML format","title":"gotk export source git"},{"location":"cmd/gotk_export_source_git/#synopsis","text":"The export source git command exports on or all GitRepository sources in YAML format. gotk export source git [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_export_source_git/#examples","text":"# Export all GitRepository sources gotk export source git --all > sources.yaml # Export a GitRepository source including the SSH key pair or basic auth credentials gotk export source git my-private-repo --with-credentials > source.yaml","title":"Examples"},{"location":"cmd/gotk_export_source_git/#options","text":"-h, --help help for git","title":"Options"},{"location":"cmd/gotk_export_source_git/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets","title":"Options inherited from parent commands"},{"location":"cmd/gotk_export_source_git/#see-also","text":"gotk export source - Export sources","title":"SEE ALSO"},{"location":"cmd/gotk_export_source_helm/","text":"gotk export source helm \u00b6 Export HelmRepository sources in YAML format Synopsis \u00b6 The export source git command exports on or all HelmRepository sources in YAML format. gotk export source helm [name] [flags] Examples \u00b6 # Export all HelmRepository sources gotk export source helm --all > sources.yaml # Export a HelmRepository source including the basic auth credentials gotk export source helm my-private-repo --with-credentials > source.yaml Options \u00b6 -h, --help help for helm Options inherited from parent commands \u00b6 --all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets SEE ALSO \u00b6 gotk export source - Export sources","title":"Export source helm"},{"location":"cmd/gotk_export_source_helm/#gotk-export-source-helm","text":"Export HelmRepository sources in YAML format","title":"gotk export source helm"},{"location":"cmd/gotk_export_source_helm/#synopsis","text":"The export source git command exports on or all HelmRepository sources in YAML format. gotk export source helm [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_export_source_helm/#examples","text":"# Export all HelmRepository sources gotk export source helm --all > sources.yaml # Export a HelmRepository source including the basic auth credentials gotk export source helm my-private-repo --with-credentials > source.yaml","title":"Examples"},{"location":"cmd/gotk_export_source_helm/#options","text":"-h, --help help for helm","title":"Options"},{"location":"cmd/gotk_export_source_helm/#options-inherited-from-parent-commands","text":"--all select all resources --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects --with-credentials include credential secrets","title":"Options inherited from parent commands"},{"location":"cmd/gotk_export_source_helm/#see-also","text":"gotk export source - Export sources","title":"SEE ALSO"},{"location":"cmd/gotk_get/","text":"gotk get \u00b6 Get sources and resources Synopsis \u00b6 The get sub-commands print the statuses of sources and resources. Options \u00b6 -h, --help help for get Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk - Command line utility for assembling Kubernetes CD pipelines gotk get helmreleases - Get HelmRelease statuses gotk get kustomizations - Get Kustomization statuses gotk get sources - Get source statuses","title":"Get"},{"location":"cmd/gotk_get/#gotk-get","text":"Get sources and resources","title":"gotk get"},{"location":"cmd/gotk_get/#synopsis","text":"The get sub-commands print the statuses of sources and resources.","title":"Synopsis"},{"location":"cmd/gotk_get/#options","text":"-h, --help help for get","title":"Options"},{"location":"cmd/gotk_get/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_get/#see-also","text":"gotk - Command line utility for assembling Kubernetes CD pipelines gotk get helmreleases - Get HelmRelease statuses gotk get kustomizations - Get Kustomization statuses gotk get sources - Get source statuses","title":"SEE ALSO"},{"location":"cmd/gotk_get_helmreleases/","text":"gotk get helmreleases \u00b6 Get HelmRelease statuses Synopsis \u00b6 The get helmreleases command prints the statuses of the resources. gotk get helmreleases [flags] Examples \u00b6 # List all Helm releases and their status gotk get helmreleases Options \u00b6 -h, --help help for helmreleases Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk get - Get sources and resources","title":"Get helmreleases"},{"location":"cmd/gotk_get_helmreleases/#gotk-get-helmreleases","text":"Get HelmRelease statuses","title":"gotk get helmreleases"},{"location":"cmd/gotk_get_helmreleases/#synopsis","text":"The get helmreleases command prints the statuses of the resources. gotk get helmreleases [flags]","title":"Synopsis"},{"location":"cmd/gotk_get_helmreleases/#examples","text":"# List all Helm releases and their status gotk get helmreleases","title":"Examples"},{"location":"cmd/gotk_get_helmreleases/#options","text":"-h, --help help for helmreleases","title":"Options"},{"location":"cmd/gotk_get_helmreleases/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_get_helmreleases/#see-also","text":"gotk get - Get sources and resources","title":"SEE ALSO"},{"location":"cmd/gotk_get_kustomizations/","text":"gotk get kustomizations \u00b6 Get Kustomization statuses Synopsis \u00b6 The get kustomizations command prints the statuses of the resources. gotk get kustomizations [flags] Examples \u00b6 # List all kustomizations and their status gotk get kustomizations Options \u00b6 -h, --help help for kustomizations Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk get - Get sources and resources","title":"Get kustomizations"},{"location":"cmd/gotk_get_kustomizations/#gotk-get-kustomizations","text":"Get Kustomization statuses","title":"gotk get kustomizations"},{"location":"cmd/gotk_get_kustomizations/#synopsis","text":"The get kustomizations command prints the statuses of the resources. gotk get kustomizations [flags]","title":"Synopsis"},{"location":"cmd/gotk_get_kustomizations/#examples","text":"# List all kustomizations and their status gotk get kustomizations","title":"Examples"},{"location":"cmd/gotk_get_kustomizations/#options","text":"-h, --help help for kustomizations","title":"Options"},{"location":"cmd/gotk_get_kustomizations/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_get_kustomizations/#see-also","text":"gotk get - Get sources and resources","title":"SEE ALSO"},{"location":"cmd/gotk_get_sources/","text":"gotk get sources \u00b6 Get source statuses Synopsis \u00b6 The get source sub-commands print the statuses of the sources. Options \u00b6 -h, --help help for sources Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk get - Get sources and resources gotk get sources bucket - Get Bucket source statuses gotk get sources git - Get GitRepository source statuses gotk get sources helm - Get HelmRepository source statuses","title":"Get sources"},{"location":"cmd/gotk_get_sources/#gotk-get-sources","text":"Get source statuses","title":"gotk get sources"},{"location":"cmd/gotk_get_sources/#synopsis","text":"The get source sub-commands print the statuses of the sources.","title":"Synopsis"},{"location":"cmd/gotk_get_sources/#options","text":"-h, --help help for sources","title":"Options"},{"location":"cmd/gotk_get_sources/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_get_sources/#see-also","text":"gotk get - Get sources and resources gotk get sources bucket - Get Bucket source statuses gotk get sources git - Get GitRepository source statuses gotk get sources helm - Get HelmRepository source statuses","title":"SEE ALSO"},{"location":"cmd/gotk_get_sources_bucket/","text":"gotk get sources bucket \u00b6 Get Bucket source statuses Synopsis \u00b6 The get sources bucket command prints the status of the Bucket sources. gotk get sources bucket [flags] Examples \u00b6 # List all Buckets and their status gotk get sources bucket Options \u00b6 -h, --help help for bucket Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk get sources - Get source statuses","title":"Get sources bucket"},{"location":"cmd/gotk_get_sources_bucket/#gotk-get-sources-bucket","text":"Get Bucket source statuses","title":"gotk get sources bucket"},{"location":"cmd/gotk_get_sources_bucket/#synopsis","text":"The get sources bucket command prints the status of the Bucket sources. gotk get sources bucket [flags]","title":"Synopsis"},{"location":"cmd/gotk_get_sources_bucket/#examples","text":"# List all Buckets and their status gotk get sources bucket","title":"Examples"},{"location":"cmd/gotk_get_sources_bucket/#options","text":"-h, --help help for bucket","title":"Options"},{"location":"cmd/gotk_get_sources_bucket/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_get_sources_bucket/#see-also","text":"gotk get sources - Get source statuses","title":"SEE ALSO"},{"location":"cmd/gotk_get_sources_git/","text":"gotk get sources git \u00b6 Get GitRepository source statuses Synopsis \u00b6 The get sources git command prints the status of the GitRepository sources. gotk get sources git [flags] Examples \u00b6 # List all Git repositories and their status gotk get sources git Options \u00b6 -h, --help help for git Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk get sources - Get source statuses","title":"Get sources git"},{"location":"cmd/gotk_get_sources_git/#gotk-get-sources-git","text":"Get GitRepository source statuses","title":"gotk get sources git"},{"location":"cmd/gotk_get_sources_git/#synopsis","text":"The get sources git command prints the status of the GitRepository sources. gotk get sources git [flags]","title":"Synopsis"},{"location":"cmd/gotk_get_sources_git/#examples","text":"# List all Git repositories and their status gotk get sources git","title":"Examples"},{"location":"cmd/gotk_get_sources_git/#options","text":"-h, --help help for git","title":"Options"},{"location":"cmd/gotk_get_sources_git/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_get_sources_git/#see-also","text":"gotk get sources - Get source statuses","title":"SEE ALSO"},{"location":"cmd/gotk_get_sources_helm/","text":"gotk get sources helm \u00b6 Get HelmRepository source statuses Synopsis \u00b6 The get sources helm command prints the status of the HelmRepository sources. gotk get sources helm [flags] Examples \u00b6 # List all Helm repositories and their status gotk get sources helm Options \u00b6 -h, --help help for helm Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk get sources - Get source statuses","title":"Get sources helm"},{"location":"cmd/gotk_get_sources_helm/#gotk-get-sources-helm","text":"Get HelmRepository source statuses","title":"gotk get sources helm"},{"location":"cmd/gotk_get_sources_helm/#synopsis","text":"The get sources helm command prints the status of the HelmRepository sources. gotk get sources helm [flags]","title":"Synopsis"},{"location":"cmd/gotk_get_sources_helm/#examples","text":"# List all Helm repositories and their status gotk get sources helm","title":"Examples"},{"location":"cmd/gotk_get_sources_helm/#options","text":"-h, --help help for helm","title":"Options"},{"location":"cmd/gotk_get_sources_helm/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_get_sources_helm/#see-also","text":"gotk get sources - Get source statuses","title":"SEE ALSO"},{"location":"cmd/gotk_install/","text":"gotk install \u00b6 Install the toolkit components Synopsis \u00b6 The install command deploys the toolkit components in the specified namespace. If a previous version is installed, then an in-place upgrade will be performed. gotk install [flags] Examples \u00b6 # Install the latest version in the gotk-system namespace gotk install --version=latest --namespace=gotk-system # Dry-run install for a specific version and a series of components gotk install --dry-run --version=v0.0.7 --components=\"source-controller,kustomize-controller\" # Dry-run install with manifests preview gotk install --dry-run --verbose # Write install manifests to file gotk install --export > gotk-system.yaml Options \u00b6 --arch string arch can be amd64 or arm64 (default \"amd64\") --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --dry-run only print the object that would be applied --export write the install manifests to stdout and exit -h, --help help for install --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --log-level string set the controllers log level (default \"info\") --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true) Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk - Command line utility for assembling Kubernetes CD pipelines","title":"Install"},{"location":"cmd/gotk_install/#gotk-install","text":"Install the toolkit components","title":"gotk install"},{"location":"cmd/gotk_install/#synopsis","text":"The install command deploys the toolkit components in the specified namespace. If a previous version is installed, then an in-place upgrade will be performed. gotk install [flags]","title":"Synopsis"},{"location":"cmd/gotk_install/#examples","text":"# Install the latest version in the gotk-system namespace gotk install --version=latest --namespace=gotk-system # Dry-run install for a specific version and a series of components gotk install --dry-run --version=v0.0.7 --components=\"source-controller,kustomize-controller\" # Dry-run install with manifests preview gotk install --dry-run --verbose # Write install manifests to file gotk install --export > gotk-system.yaml","title":"Examples"},{"location":"cmd/gotk_install/#options","text":"--arch string arch can be amd64 or arm64 (default \"amd64\") --components strings list of components, accepts comma-separated values (default [source-controller,kustomize-controller,helm-controller,notification-controller]) --dry-run only print the object that would be applied --export write the install manifests to stdout and exit -h, --help help for install --image-pull-secret string Kubernetes secret name used for pulling the toolkit images from a private registry --log-level string set the controllers log level (default \"info\") --network-policy deny ingress access to the toolkit controllers from other namespaces using network policies (default true) --registry string container registry where the toolkit images are published (default \"ghcr.io/fluxcd\") -v, --version string toolkit version (default \"latest\") --watch-all-namespaces watch for custom resources in all namespaces, if set to false it will only watch the namespace where the toolkit is installed (default true)","title":"Options"},{"location":"cmd/gotk_install/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_install/#see-also","text":"gotk - Command line utility for assembling Kubernetes CD pipelines","title":"SEE ALSO"},{"location":"cmd/gotk_reconcile/","text":"gotk reconcile \u00b6 Reconcile sources and resources Synopsis \u00b6 The reconcile sub-commands trigger a reconciliation of sources and resources. Options \u00b6 -h, --help help for reconcile Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk - Command line utility for assembling Kubernetes CD pipelines gotk reconcile helmrelease - Reconcile a HelmRelease resource gotk reconcile kustomization - Reconcile a Kustomization resource gotk reconcile source - Reconcile sources","title":"Reconcile"},{"location":"cmd/gotk_reconcile/#gotk-reconcile","text":"Reconcile sources and resources","title":"gotk reconcile"},{"location":"cmd/gotk_reconcile/#synopsis","text":"The reconcile sub-commands trigger a reconciliation of sources and resources.","title":"Synopsis"},{"location":"cmd/gotk_reconcile/#options","text":"-h, --help help for reconcile","title":"Options"},{"location":"cmd/gotk_reconcile/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_reconcile/#see-also","text":"gotk - Command line utility for assembling Kubernetes CD pipelines gotk reconcile helmrelease - Reconcile a HelmRelease resource gotk reconcile kustomization - Reconcile a Kustomization resource gotk reconcile source - Reconcile sources","title":"SEE ALSO"},{"location":"cmd/gotk_reconcile_helmrelease/","text":"gotk reconcile helmrelease \u00b6 Reconcile a HelmRelease resource Synopsis \u00b6 The reconcile kustomization command triggers a reconciliation of a HelmRelease resource and waits for it to finish. gotk reconcile helmrelease [name] [flags] Examples \u00b6 # Trigger a HelmRelease apply outside of the reconciliation interval gotk reconcile hr podinfo # Trigger a reconciliation of the HelmRelease's source and apply changes gotk reconcile hr podinfo --with-source Options \u00b6 -h, --help help for helmrelease --with-source reconcile HelmRelease source Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk reconcile - Reconcile sources and resources","title":"Reconcile helmrelease"},{"location":"cmd/gotk_reconcile_helmrelease/#gotk-reconcile-helmrelease","text":"Reconcile a HelmRelease resource","title":"gotk reconcile helmrelease"},{"location":"cmd/gotk_reconcile_helmrelease/#synopsis","text":"The reconcile kustomization command triggers a reconciliation of a HelmRelease resource and waits for it to finish. gotk reconcile helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_reconcile_helmrelease/#examples","text":"# Trigger a HelmRelease apply outside of the reconciliation interval gotk reconcile hr podinfo # Trigger a reconciliation of the HelmRelease's source and apply changes gotk reconcile hr podinfo --with-source","title":"Examples"},{"location":"cmd/gotk_reconcile_helmrelease/#options","text":"-h, --help help for helmrelease --with-source reconcile HelmRelease source","title":"Options"},{"location":"cmd/gotk_reconcile_helmrelease/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_reconcile_helmrelease/#see-also","text":"gotk reconcile - Reconcile sources and resources","title":"SEE ALSO"},{"location":"cmd/gotk_reconcile_kustomization/","text":"gotk reconcile kustomization \u00b6 Reconcile a Kustomization resource Synopsis \u00b6 The reconcile kustomization command triggers a reconciliation of a Kustomization resource and waits for it to finish. gotk reconcile kustomization [name] [flags] Examples \u00b6 # Trigger a Kustomization apply outside of the reconciliation interval gotk reconcile kustomization podinfo # Trigger a sync of the Kustomization's source and apply changes gotk reconcile kustomization podinfo --with-source Options \u00b6 -h, --help help for kustomization --with-source reconcile kustomization source Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk reconcile - Reconcile sources and resources","title":"Reconcile kustomization"},{"location":"cmd/gotk_reconcile_kustomization/#gotk-reconcile-kustomization","text":"Reconcile a Kustomization resource","title":"gotk reconcile kustomization"},{"location":"cmd/gotk_reconcile_kustomization/#synopsis","text":"The reconcile kustomization command triggers a reconciliation of a Kustomization resource and waits for it to finish. gotk reconcile kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_reconcile_kustomization/#examples","text":"# Trigger a Kustomization apply outside of the reconciliation interval gotk reconcile kustomization podinfo # Trigger a sync of the Kustomization's source and apply changes gotk reconcile kustomization podinfo --with-source","title":"Examples"},{"location":"cmd/gotk_reconcile_kustomization/#options","text":"-h, --help help for kustomization --with-source reconcile kustomization source","title":"Options"},{"location":"cmd/gotk_reconcile_kustomization/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_reconcile_kustomization/#see-also","text":"gotk reconcile - Reconcile sources and resources","title":"SEE ALSO"},{"location":"cmd/gotk_reconcile_source/","text":"gotk reconcile source \u00b6 Reconcile sources Synopsis \u00b6 The reconcile source sub-commands trigger a reconciliation of sources. Options \u00b6 -h, --help help for source Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk reconcile - Reconcile sources and resources gotk reconcile source bucket - Reconcile a Bucket source gotk reconcile source git - Reconcile a GitRepository source gotk reconcile source helm - Reconcile a HelmRepository source","title":"Reconcile source"},{"location":"cmd/gotk_reconcile_source/#gotk-reconcile-source","text":"Reconcile sources","title":"gotk reconcile source"},{"location":"cmd/gotk_reconcile_source/#synopsis","text":"The reconcile source sub-commands trigger a reconciliation of sources.","title":"Synopsis"},{"location":"cmd/gotk_reconcile_source/#options","text":"-h, --help help for source","title":"Options"},{"location":"cmd/gotk_reconcile_source/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_reconcile_source/#see-also","text":"gotk reconcile - Reconcile sources and resources gotk reconcile source bucket - Reconcile a Bucket source gotk reconcile source git - Reconcile a GitRepository source gotk reconcile source helm - Reconcile a HelmRepository source","title":"SEE ALSO"},{"location":"cmd/gotk_reconcile_source_bucket/","text":"gotk reconcile source bucket \u00b6 Reconcile a Bucket source Synopsis \u00b6 The reconcile source command triggers a reconciliation of a Bucket resource and waits for it to finish. gotk reconcile source bucket [name] [flags] Examples \u00b6 # Trigger a reconciliation for an existing source gotk reconcile source bucket podinfo Options \u00b6 -h, --help help for bucket Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk reconcile source - Reconcile sources","title":"Reconcile source bucket"},{"location":"cmd/gotk_reconcile_source_bucket/#gotk-reconcile-source-bucket","text":"Reconcile a Bucket source","title":"gotk reconcile source bucket"},{"location":"cmd/gotk_reconcile_source_bucket/#synopsis","text":"The reconcile source command triggers a reconciliation of a Bucket resource and waits for it to finish. gotk reconcile source bucket [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_reconcile_source_bucket/#examples","text":"# Trigger a reconciliation for an existing source gotk reconcile source bucket podinfo","title":"Examples"},{"location":"cmd/gotk_reconcile_source_bucket/#options","text":"-h, --help help for bucket","title":"Options"},{"location":"cmd/gotk_reconcile_source_bucket/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_reconcile_source_bucket/#see-also","text":"gotk reconcile source - Reconcile sources","title":"SEE ALSO"},{"location":"cmd/gotk_reconcile_source_git/","text":"gotk reconcile source git \u00b6 Reconcile a GitRepository source Synopsis \u00b6 The reconcile source command triggers a reconciliation of a GitRepository resource and waits for it to finish. gotk reconcile source git [name] [flags] Examples \u00b6 # Trigger a git pull for an existing source gotk reconcile source git podinfo Options \u00b6 -h, --help help for git Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk reconcile source - Reconcile sources","title":"Reconcile source git"},{"location":"cmd/gotk_reconcile_source_git/#gotk-reconcile-source-git","text":"Reconcile a GitRepository source","title":"gotk reconcile source git"},{"location":"cmd/gotk_reconcile_source_git/#synopsis","text":"The reconcile source command triggers a reconciliation of a GitRepository resource and waits for it to finish. gotk reconcile source git [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_reconcile_source_git/#examples","text":"# Trigger a git pull for an existing source gotk reconcile source git podinfo","title":"Examples"},{"location":"cmd/gotk_reconcile_source_git/#options","text":"-h, --help help for git","title":"Options"},{"location":"cmd/gotk_reconcile_source_git/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_reconcile_source_git/#see-also","text":"gotk reconcile source - Reconcile sources","title":"SEE ALSO"},{"location":"cmd/gotk_reconcile_source_helm/","text":"gotk reconcile source helm \u00b6 Reconcile a HelmRepository source Synopsis \u00b6 The reconcile source command triggers a reconciliation of a HelmRepository resource and waits for it to finish. gotk reconcile source helm [name] [flags] Examples \u00b6 # Trigger a reconciliation for an existing source gotk reconcile source helm podinfo Options \u00b6 -h, --help help for helm Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk reconcile source - Reconcile sources","title":"Reconcile source helm"},{"location":"cmd/gotk_reconcile_source_helm/#gotk-reconcile-source-helm","text":"Reconcile a HelmRepository source","title":"gotk reconcile source helm"},{"location":"cmd/gotk_reconcile_source_helm/#synopsis","text":"The reconcile source command triggers a reconciliation of a HelmRepository resource and waits for it to finish. gotk reconcile source helm [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_reconcile_source_helm/#examples","text":"# Trigger a reconciliation for an existing source gotk reconcile source helm podinfo","title":"Examples"},{"location":"cmd/gotk_reconcile_source_helm/#options","text":"-h, --help help for helm","title":"Options"},{"location":"cmd/gotk_reconcile_source_helm/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_reconcile_source_helm/#see-also","text":"gotk reconcile source - Reconcile sources","title":"SEE ALSO"},{"location":"cmd/gotk_resume/","text":"gotk resume \u00b6 Resume suspended resources Synopsis \u00b6 The resume sub-commands resume a suspended resource. Options \u00b6 -h, --help help for resume Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk - Command line utility for assembling Kubernetes CD pipelines gotk resume helmrelease - Resume a suspended HelmRelease gotk resume kustomization - Resume a suspended Kustomization","title":"Resume"},{"location":"cmd/gotk_resume/#gotk-resume","text":"Resume suspended resources","title":"gotk resume"},{"location":"cmd/gotk_resume/#synopsis","text":"The resume sub-commands resume a suspended resource.","title":"Synopsis"},{"location":"cmd/gotk_resume/#options","text":"-h, --help help for resume","title":"Options"},{"location":"cmd/gotk_resume/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_resume/#see-also","text":"gotk - Command line utility for assembling Kubernetes CD pipelines gotk resume helmrelease - Resume a suspended HelmRelease gotk resume kustomization - Resume a suspended Kustomization","title":"SEE ALSO"},{"location":"cmd/gotk_resume_helmrelease/","text":"gotk resume helmrelease \u00b6 Resume a suspended HelmRelease Synopsis \u00b6 The resume command marks a previously suspended HelmRelease resource for reconciliation and waits for it to finish the apply. gotk resume helmrelease [name] [flags] Examples \u00b6 # Resume reconciliation for an existing Helm release gotk resume hr podinfo Options \u00b6 -h, --help help for helmrelease Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk resume - Resume suspended resources","title":"Resume helmrelease"},{"location":"cmd/gotk_resume_helmrelease/#gotk-resume-helmrelease","text":"Resume a suspended HelmRelease","title":"gotk resume helmrelease"},{"location":"cmd/gotk_resume_helmrelease/#synopsis","text":"The resume command marks a previously suspended HelmRelease resource for reconciliation and waits for it to finish the apply. gotk resume helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_resume_helmrelease/#examples","text":"# Resume reconciliation for an existing Helm release gotk resume hr podinfo","title":"Examples"},{"location":"cmd/gotk_resume_helmrelease/#options","text":"-h, --help help for helmrelease","title":"Options"},{"location":"cmd/gotk_resume_helmrelease/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_resume_helmrelease/#see-also","text":"gotk resume - Resume suspended resources","title":"SEE ALSO"},{"location":"cmd/gotk_resume_kustomization/","text":"gotk resume kustomization \u00b6 Resume a suspended Kustomization Synopsis \u00b6 The resume command marks a previously suspended Kustomization resource for reconciliation and waits for it to finish the apply. gotk resume kustomization [name] [flags] Examples \u00b6 # Resume reconciliation for an existing Kustomization gotk resume ks podinfo Options \u00b6 -h, --help help for kustomization Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk resume - Resume suspended resources","title":"Resume kustomization"},{"location":"cmd/gotk_resume_kustomization/#gotk-resume-kustomization","text":"Resume a suspended Kustomization","title":"gotk resume kustomization"},{"location":"cmd/gotk_resume_kustomization/#synopsis","text":"The resume command marks a previously suspended Kustomization resource for reconciliation and waits for it to finish the apply. gotk resume kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_resume_kustomization/#examples","text":"# Resume reconciliation for an existing Kustomization gotk resume ks podinfo","title":"Examples"},{"location":"cmd/gotk_resume_kustomization/#options","text":"-h, --help help for kustomization","title":"Options"},{"location":"cmd/gotk_resume_kustomization/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_resume_kustomization/#see-also","text":"gotk resume - Resume suspended resources","title":"SEE ALSO"},{"location":"cmd/gotk_suspend/","text":"gotk suspend \u00b6 Suspend resources Synopsis \u00b6 The suspend sub-commands suspend the reconciliation of a resource. Options \u00b6 -h, --help help for suspend Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk - Command line utility for assembling Kubernetes CD pipelines gotk suspend helmrelease - Suspend reconciliation of HelmRelease gotk suspend kustomization - Suspend reconciliation of Kustomization","title":"Suspend"},{"location":"cmd/gotk_suspend/#gotk-suspend","text":"Suspend resources","title":"gotk suspend"},{"location":"cmd/gotk_suspend/#synopsis","text":"The suspend sub-commands suspend the reconciliation of a resource.","title":"Synopsis"},{"location":"cmd/gotk_suspend/#options","text":"-h, --help help for suspend","title":"Options"},{"location":"cmd/gotk_suspend/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_suspend/#see-also","text":"gotk - Command line utility for assembling Kubernetes CD pipelines gotk suspend helmrelease - Suspend reconciliation of HelmRelease gotk suspend kustomization - Suspend reconciliation of Kustomization","title":"SEE ALSO"},{"location":"cmd/gotk_suspend_helmrelease/","text":"gotk suspend helmrelease \u00b6 Suspend reconciliation of HelmRelease Synopsis \u00b6 The suspend command disables the reconciliation of a HelmRelease resource. gotk suspend helmrelease [name] [flags] Examples \u00b6 # Suspend reconciliation for an existing Helm release gotk suspend hr podinfo Options \u00b6 -h, --help help for helmrelease Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk suspend - Suspend resources","title":"Suspend helmrelease"},{"location":"cmd/gotk_suspend_helmrelease/#gotk-suspend-helmrelease","text":"Suspend reconciliation of HelmRelease","title":"gotk suspend helmrelease"},{"location":"cmd/gotk_suspend_helmrelease/#synopsis","text":"The suspend command disables the reconciliation of a HelmRelease resource. gotk suspend helmrelease [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_suspend_helmrelease/#examples","text":"# Suspend reconciliation for an existing Helm release gotk suspend hr podinfo","title":"Examples"},{"location":"cmd/gotk_suspend_helmrelease/#options","text":"-h, --help help for helmrelease","title":"Options"},{"location":"cmd/gotk_suspend_helmrelease/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_suspend_helmrelease/#see-also","text":"gotk suspend - Suspend resources","title":"SEE ALSO"},{"location":"cmd/gotk_suspend_kustomization/","text":"gotk suspend kustomization \u00b6 Suspend reconciliation of Kustomization Synopsis \u00b6 The suspend command disables the reconciliation of a Kustomization resource. gotk suspend kustomization [name] [flags] Examples \u00b6 # Suspend reconciliation for an existing Kustomization gotk suspend ks podinfo Options \u00b6 -h, --help help for kustomization Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk suspend - Suspend resources","title":"Suspend kustomization"},{"location":"cmd/gotk_suspend_kustomization/#gotk-suspend-kustomization","text":"Suspend reconciliation of Kustomization","title":"gotk suspend kustomization"},{"location":"cmd/gotk_suspend_kustomization/#synopsis","text":"The suspend command disables the reconciliation of a Kustomization resource. gotk suspend kustomization [name] [flags]","title":"Synopsis"},{"location":"cmd/gotk_suspend_kustomization/#examples","text":"# Suspend reconciliation for an existing Kustomization gotk suspend ks podinfo","title":"Examples"},{"location":"cmd/gotk_suspend_kustomization/#options","text":"-h, --help help for kustomization","title":"Options"},{"location":"cmd/gotk_suspend_kustomization/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_suspend_kustomization/#see-also","text":"gotk suspend - Suspend resources","title":"SEE ALSO"},{"location":"cmd/gotk_uninstall/","text":"gotk uninstall \u00b6 Uninstall the toolkit components Synopsis \u00b6 The uninstall command removes the namespace, cluster roles, cluster role bindings and CRDs from the cluster. gotk uninstall [flags] Examples \u00b6 # Dry-run uninstall of all components gotk uninstall --dry-run --namespace=gotk-system # Uninstall all components and delete custom resource definitions gotk uninstall --resources --crds --namespace=gotk-system Options \u00b6 --crds removes all CRDs previously installed --dry-run only print the object that would be deleted -h, --help help for uninstall --resources removes custom resources such as Kustomizations, GitRepositories and HelmRepositories (default true) -s, --silent delete components without asking for confirmation Options inherited from parent commands \u00b6 --kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects SEE ALSO \u00b6 gotk - Command line utility for assembling Kubernetes CD pipelines","title":"Uninstall"},{"location":"cmd/gotk_uninstall/#gotk-uninstall","text":"Uninstall the toolkit components","title":"gotk uninstall"},{"location":"cmd/gotk_uninstall/#synopsis","text":"The uninstall command removes the namespace, cluster roles, cluster role bindings and CRDs from the cluster. gotk uninstall [flags]","title":"Synopsis"},{"location":"cmd/gotk_uninstall/#examples","text":"# Dry-run uninstall of all components gotk uninstall --dry-run --namespace=gotk-system # Uninstall all components and delete custom resource definitions gotk uninstall --resources --crds --namespace=gotk-system","title":"Examples"},{"location":"cmd/gotk_uninstall/#options","text":"--crds removes all CRDs previously installed --dry-run only print the object that would be deleted -h, --help help for uninstall --resources removes custom resources such as Kustomizations, GitRepositories and HelmRepositories (default true) -s, --silent delete components without asking for confirmation","title":"Options"},{"location":"cmd/gotk_uninstall/#options-inherited-from-parent-commands","text":"--kubeconfig string path to the kubeconfig file (default \"~/.kube/config\") -n, --namespace string the namespace scope for this operation (default \"gotk-system\") --timeout duration timeout for this operation (default 5m0s) --verbose print generated objects","title":"Options inherited from parent commands"},{"location":"cmd/gotk_uninstall/#see-also","text":"gotk - Command line utility for assembling Kubernetes CD pipelines","title":"SEE ALSO"},{"location":"components/helm/api/","text":"HelmRelease API reference Packages: helm.toolkit.fluxcd.io/v2beta1 helm.toolkit.fluxcd.io/v2beta1 Package v2beta1 contains API Schema definitions for the helm v2beta1 API group Resource Types: HelmRelease HelmRelease HelmRelease is the Schema for the helmreleases API Field Description apiVersion string helm.toolkit.fluxcd.io/v2beta1 kind string HelmRelease metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec HelmReleaseSpec chart HelmChartTemplate Chart defines the template of the v1beta1.HelmChart that should be created for this HelmRelease. interval Kubernetes meta/v1.Duration Interval at which to reconcile the Helm release. suspend bool (Optional) Suspend tells the controller to suspend reconciliation for this HelmRelease, it does not apply to already started reconciliations. Defaults to false. releaseName string (Optional) ReleaseName used for the Helm release. Defaults to a composition of \u2018[TargetNamespace-]Name\u2019. targetNamespace string (Optional) TargetNamespace to target when performing operations for the HelmRelease. Defaults to the namespace of the HelmRelease. dependsOn []Runtime dependency.CrossNamespaceDependencyReference (Optional) DependsOn may contain a dependency.CrossNamespaceDependencyReference slice with references to HelmRelease resources that must be ready before this HelmRelease can be reconciled. timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm action. Defaults to \u20185m0s\u2019. maxHistory int (Optional) MaxHistory is the number of revisions saved by Helm for this HelmRelease. Use \u20180\u2019 for an unlimited number of revisions; defaults to \u201810\u2019. install Install (Optional) Install holds the configuration for Helm install actions for this HelmRelease. upgrade Upgrade (Optional) Upgrade holds the configuration for Helm upgrade actions for this HelmRelease. test Test (Optional) Test holds the configuration for Helm test actions for this HelmRelease. rollback Rollback (Optional) Rollback holds the configuration for Helm rollback actions for this HelmRelease. uninstall Uninstall (Optional) Uninstall holds the configuration for Helm uninstall actions for this HelmRelease. valuesFrom []ValuesReference ValuesFrom holds references to resources containing Helm values for this HelmRelease, and information about how they should be merged. values Kubernetes pkg/apis/apiextensions/v1.JSON (Optional) Values holds the values for this Helm release. status HelmReleaseStatus CrossNamespaceObjectReference ( Appears on: HelmChartTemplateSpec ) CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level. Field Description apiVersion string (Optional) APIVersion of the referent. kind string Kind of the referent. name string Name of the referent. namespace string (Optional) Namespace of the referent. DeploymentAction DeploymentAction defines a consistent interface for Install and Upgrade. HelmChartTemplate ( Appears on: HelmReleaseSpec ) HelmChartTemplate defines the template from which the controller will generate a v1beta1.HelmChart object in the same namespace as the referenced v1beta1.Source. Field Description spec HelmChartTemplateSpec Spec holds the template for the v1beta1.HelmChartSpec for this HelmRelease. chart string The name or path the Helm chart is available at in the SourceRef. version string (Optional) Version semver expression, ignored for charts from v1beta1.GitRepository and v1beta1.Bucket sources. Defaults to latest when omitted. sourceRef CrossNamespaceObjectReference The name and namespace of the v1beta1.Source the chart is available at. interval Kubernetes meta/v1.Duration (Optional) Interval at which to check the v1beta1.Source for updates. Defaults to \u2018HelmReleaseSpec.Interval\u2019. valuesFile string (Optional) Alternative values file to use as the default chart values, expected to be a relative path in the SourceRef. Ignored when omitted. HelmChartTemplateSpec ( Appears on: HelmChartTemplate ) HelmChartTemplateSpec defines the template from which the controller will generate a v1beta1.HelmChartSpec object. Field Description chart string The name or path the Helm chart is available at in the SourceRef. version string (Optional) Version semver expression, ignored for charts from v1beta1.GitRepository and v1beta1.Bucket sources. Defaults to latest when omitted. sourceRef CrossNamespaceObjectReference The name and namespace of the v1beta1.Source the chart is available at. interval Kubernetes meta/v1.Duration (Optional) Interval at which to check the v1beta1.Source for updates. Defaults to \u2018HelmReleaseSpec.Interval\u2019. valuesFile string (Optional) Alternative values file to use as the default chart values, expected to be a relative path in the SourceRef. Ignored when omitted. HelmReleaseSpec ( Appears on: HelmRelease ) HelmReleaseSpec defines the desired state of a Helm release. Field Description chart HelmChartTemplate Chart defines the template of the v1beta1.HelmChart that should be created for this HelmRelease. interval Kubernetes meta/v1.Duration Interval at which to reconcile the Helm release. suspend bool (Optional) Suspend tells the controller to suspend reconciliation for this HelmRelease, it does not apply to already started reconciliations. Defaults to false. releaseName string (Optional) ReleaseName used for the Helm release. Defaults to a composition of \u2018[TargetNamespace-]Name\u2019. targetNamespace string (Optional) TargetNamespace to target when performing operations for the HelmRelease. Defaults to the namespace of the HelmRelease. dependsOn []Runtime dependency.CrossNamespaceDependencyReference (Optional) DependsOn may contain a dependency.CrossNamespaceDependencyReference slice with references to HelmRelease resources that must be ready before this HelmRelease can be reconciled. timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm action. Defaults to \u20185m0s\u2019. maxHistory int (Optional) MaxHistory is the number of revisions saved by Helm for this HelmRelease. Use \u20180\u2019 for an unlimited number of revisions; defaults to \u201810\u2019. install Install (Optional) Install holds the configuration for Helm install actions for this HelmRelease. upgrade Upgrade (Optional) Upgrade holds the configuration for Helm upgrade actions for this HelmRelease. test Test (Optional) Test holds the configuration for Helm test actions for this HelmRelease. rollback Rollback (Optional) Rollback holds the configuration for Helm rollback actions for this HelmRelease. uninstall Uninstall (Optional) Uninstall holds the configuration for Helm uninstall actions for this HelmRelease. valuesFrom []ValuesReference ValuesFrom holds references to resources containing Helm values for this HelmRelease, and information about how they should be merged. values Kubernetes pkg/apis/apiextensions/v1.JSON (Optional) Values holds the values for this Helm release. HelmReleaseStatus ( Appears on: HelmRelease ) HelmReleaseStatus defines the observed state of a HelmRelease. Field Description observedGeneration int64 (Optional) ObservedGeneration is the last observed generation. lastHandledReconcileAt string (Optional) LastHandledReconcileAt is the last manual reconciliation request (by annotating the HelmRelease) handled by the reconciler. conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) Conditions holds the conditions for the HelmRelease. lastAppliedRevision string (Optional) LastAppliedRevision is the revision of the last successfully applied source. lastAttemptedRevision string (Optional) LastAttemptedRevision is the revision of the last reconciliation attempt. lastAttemptedValuesChecksum string (Optional) LastAttemptedValuesChecksum is the SHA1 checksum of the values of the last reconciliation attempt. lastReleaseRevision int (Optional) LastReleaseRevision is the revision of the last successful Helm release. helmChart string (Optional) HelmChart is the namespaced name of the HelmChart resource created by the controller for the HelmRelease. failures int64 (Optional) Failures is the reconciliation failure count against the latest desired state. It is reset after a successful reconciliation. installFailures int64 (Optional) InstallFailures is the install failure count against the latest desired state. It is reset after a successful reconciliation. upgradeFailures int64 (Optional) UpgradeFailures is the upgrade failure count against the latest desired state. It is reset after a successful reconciliation. Install ( Appears on: HelmReleaseSpec ) Install holds the configuration for Helm install actions performed for this HelmRelease. Field Description timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm install action. Defaults to \u2018HelmReleaseSpec.Timeout\u2019. remediation InstallRemediation (Optional) Remediation holds the remediation configuration for when the Helm install action for the HelmRelease fails. The default is to not perform any action. disableWait bool (Optional) DisableWait disables the waiting for resources to be ready after a Helm install has been performed. disableHooks bool (Optional) DisableHooks prevents hooks from running during the Helm install action. disableOpenAPIValidation bool (Optional) DisableOpenAPIValidation prevents the Helm install action from validating rendered templates against the Kubernetes OpenAPI Schema. replace bool (Optional) Replace tells the Helm install action to re-use the \u2018ReleaseName\u2019, but only if that name is a deleted release which remains in the history. skipCRDs bool (Optional) SkipCRDs tells the Helm install action to not install any CRDs. By default, CRDs are installed if not already present. InstallRemediation ( Appears on: Install ) InstallRemediation holds the configuration for Helm install remediation. Field Description retries int (Optional) Retries is the number of retries that should be attempted on failures before bailing. Remediation, using an uninstall, is performed between each attempt. Defaults to \u20180\u2019, a negative integer equals to unlimited retries. ignoreTestFailures bool (Optional) IgnoreTestFailures tells the controller to skip remediation when the Helm tests are run after an install action but fail. Defaults to \u2018Test.IgnoreFailures\u2019. remediateLastFailure bool (Optional) RemediateLastFailure tells the controller to remediate the last failure, when no retries remain. Defaults to \u2018false\u2019. Remediation Remediation defines a consistent interface for InstallRemediation and UpgradeRemediation. RemediationStrategy ( string alias) ( Appears on: UpgradeRemediation ) RemediationStrategy returns the strategy to use to remediate a failed install or upgrade. Rollback ( Appears on: HelmReleaseSpec ) Rollback holds the configuration for Helm rollback actions for this HelmRelease. Field Description timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm rollback action. Defaults to \u2018HelmReleaseSpec.Timeout\u2019. disableWait bool (Optional) DisableWait disables the waiting for resources to be ready after a Helm rollback has been performed. disableHooks bool (Optional) DisableHooks prevents hooks from running during the Helm rollback action. recreate bool (Optional) Recreate performs pod restarts for the resource if applicable. force bool (Optional) Force forces resource updates through a replacement strategy. cleanupOnFail bool (Optional) CleanupOnFail allows deletion of new resources created during the Helm rollback action when it fails. Test ( Appears on: HelmReleaseSpec ) Test holds the configuration for Helm test actions for this HelmRelease. Field Description enable bool (Optional) Enable enables Helm test actions for this HelmRelease after an Helm install or upgrade action has been performed. timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation during the performance of a Helm test action. Defaults to \u2018HelmReleaseSpec.Timeout\u2019. ignoreFailures bool (Optional) IgnoreFailures tells the controller to skip remediation when the Helm tests are run but fail. Can be overwritten for tests run after install or upgrade actions in \u2018Install.IgnoreTestFailures\u2019 and \u2018Upgrade.IgnoreTestFailures\u2019. Uninstall ( Appears on: HelmReleaseSpec ) Uninstall holds the configuration for Helm uninstall actions for this HelmRelease. Field Description timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm uninstall action. Defaults to \u2018HelmReleaseSpec.Timeout\u2019. disableHooks bool (Optional) DisableHooks prevents hooks from running during the Helm rollback action. keepHistory bool (Optional) KeepHistory tells Helm to remove all associated resources and mark the release as deleted, but retain the release history. Upgrade ( Appears on: HelmReleaseSpec ) Upgrade holds the configuration for Helm upgrade actions for this HelmRelease. Field Description timeout Kubernetes meta/v1.Duration (Optional) Timeout is the time to wait for any individual Kubernetes operation (like Jobs for hooks) during the performance of a Helm upgrade action. Defaults to \u2018HelmReleaseSpec.Timeout\u2019. remediation UpgradeRemediation (Optional) Remediation holds the remediation configuration for when the Helm upgrade action for the HelmRelease fails. The default is to not perform any action. disableWait bool (Optional) DisableWait disables the waiting for resources to be ready after a Helm upgrade has been performed. disableHooks bool (Optional) DisableHooks prevents hooks from running during the Helm upgrade action. disableOpenAPIValidation bool (Optional) DisableOpenAPIValidation prevents the Helm upgrade action from validating rendered templates against the Kubernetes OpenAPI Schema. force bool (Optional) Force forces resource updates through a replacement strategy. preserveValues bool (Optional) PreserveValues will make Helm reuse the last release\u2019s values and merge in overrides from \u2018Values\u2019. Setting this flag makes the HelmRelease non-declarative. cleanupOnFail bool (Optional) CleanupOnFail allows deletion of new resources created during the Helm upgrade action when it fails. UpgradeRemediation ( Appears on: Upgrade ) UpgradeRemediation holds the configuration for Helm upgrade remediation. Field Description retries int (Optional) Retries is the number of retries that should be attempted on failures before bailing. Remediation, using \u2018Strategy\u2019, is performed between each attempt. Defaults to \u20180\u2019, a negative integer equals to unlimited retries. ignoreTestFailures bool (Optional) IgnoreTestFailures tells the controller to skip remediation when the Helm tests are run after an upgrade action but fail. Defaults to \u2018Test.IgnoreFailures\u2019. remediateLastFailure bool (Optional) RemediateLastFailure tells the controller to remediate the last failure, when no retries remain. Defaults to \u2018false\u2019 unless \u2018Retries\u2019 is greater than 0. strategy RemediationStrategy (Optional) Strategy to use for failure remediation. Defaults to \u2018rollback\u2019. ValuesReference ( Appears on: HelmReleaseSpec ) ValuesReference contains a reference to a resource containing Helm values, and optionally the key they can be found at. Field Description kind string Kind of the values referent, valid values are (\u2018Secret\u2019, \u2018ConfigMap\u2019). name string Name of the values referent. Should reside in the same namespace as the referring resource. valuesKey string (Optional) ValuesKey is the data key where the values.yaml or a specific value can be found at. Defaults to \u2018values.yaml\u2019. targetPath string (Optional) TargetPath is the YAML dot notation path the value should be merged at. When set, the ValuesKey is expected to be a single flat value. Defaults to \u2018None\u2019, which results in the values getting merged at the root. optional bool (Optional) Optional marks this ValuesReference as optional. When set, a not found error for the values reference is ignored, but any ValuesKey, TargetPath or transient error will still result in a reconciliation failure. This page was automatically generated with gen-crd-api-reference-docs","title":"Helm API Reference"},{"location":"components/helm/controller/","text":"Helm Controller \u00b6 The Helm Controller is a Kubernetes operator, allowing one to declaratively manage Helm chart releases with Kubernetes manifests. The desired state of a Helm release is described through a Kubernetes Custom Resource named HelmRelease . Based on the creation, mutation or removal of a HelmRelease resource in the cluster, Helm actions are performed by the controller. Features: Watches for HelmRelease objects and generates HelmChart objects Supports HelmChart artifacts produced from HelmRepository and GitRepository sources Fetches artifacts produced by source-controller from HelmChart objects Watches HelmChart objects for revision changes (including semver ranges for charts from HelmRepository sources) Performs automated Helm actions, including Helm tests, rollbacks and uninstalls Offers extensive configuration options for automated remediation (rollback, uninstall, retry) on failed Helm install, upgrade or test actions Runs Helm install/upgrade in a specific order, taking into account the depends-on relationship defined in a set of HelmRelease objects Prunes Helm releases removed from cluster (garbage collection) Reports Helm releases statuses (alerting provided by notification-controller ) Links: Source code fluxcd/helm-controller Specification docs","title":"Overview"},{"location":"components/helm/controller/#helm-controller","text":"The Helm Controller is a Kubernetes operator, allowing one to declaratively manage Helm chart releases with Kubernetes manifests. The desired state of a Helm release is described through a Kubernetes Custom Resource named HelmRelease . Based on the creation, mutation or removal of a HelmRelease resource in the cluster, Helm actions are performed by the controller. Features: Watches for HelmRelease objects and generates HelmChart objects Supports HelmChart artifacts produced from HelmRepository and GitRepository sources Fetches artifacts produced by source-controller from HelmChart objects Watches HelmChart objects for revision changes (including semver ranges for charts from HelmRepository sources) Performs automated Helm actions, including Helm tests, rollbacks and uninstalls Offers extensive configuration options for automated remediation (rollback, uninstall, retry) on failed Helm install, upgrade or test actions Runs Helm install/upgrade in a specific order, taking into account the depends-on relationship defined in a set of HelmRelease objects Prunes Helm releases removed from cluster (garbage collection) Reports Helm releases statuses (alerting provided by notification-controller ) Links: Source code fluxcd/helm-controller Specification docs","title":"Helm Controller"},{"location":"components/helm/helmreleases/","text":"Helm Releases \u00b6 The HelmRelease API defines a resource for automated controller driven Helm releases. Specification \u00b6 A helmrelease object defines a resource for controller driven reconciliation of Helm releases via Helm actions such as install, upgrade, test, uninstall, and rollback. This includes release placement (namespace/name), release content (chart/values overrides), action trigger configuration, individual action configuration, and statusing. // HelmReleaseSpec defines the desired state of a Helm Release. type HelmReleaseSpec struct { // Chart defines the template of the v1beta1.HelmChart that should be created // for this HelmRelease. // +required Chart HelmChartTemplate `json:\"chart\"` // Interval at which to reconcile the Helm release. // +required Interval metav1 . Duration `json:\"interval\"` // Suspend tells the controller to suspend reconciliation for this HelmRelease, // it does not apply to already started reconciliations. Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` // ReleaseName used for the Helm release. Defaults to a composition of // '[TargetNamespace-]Name'. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=53 // +kubebuilder:validation:Optional // +optional ReleaseName string `json:\"releaseName,omitempty\"` // TargetNamespace to target when performing operations for the HelmRelease. // Defaults to the namespace of the HelmRelease. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=63 // +kubebuilder:validation:Optional // +optional TargetNamespace string `json:\"targetNamespace,omitempty\"` // DependsOn may contain a dependency.CrossNamespaceDependencyReference slice with // references to HelmRelease resources that must be ready before this HelmRelease // can be reconciled. // +optional DependsOn [] dependency . CrossNamespaceDependencyReference `json:\"dependsOn,omitempty\"` // Timeout is the time to wait for any individual Kubernetes operation (like Jobs // for hooks) during the performance of a Helm action. Defaults to '5m0s'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // MaxHistory is the number of revisions saved by Helm for this HelmRelease. // Use '0' for an unlimited number of revisions; defaults to '10'. // +optional MaxHistory * int `json:\"maxHistory,omitempty\"` // Install holds the configuration for Helm install actions for this HelmRelease. // +optional Install * Install `json:\"install,omitempty\"` // Upgrade holds the configuration for Helm upgrade actions for this HelmRelease. // +optional Upgrade * Upgrade `json:\"upgrade,omitempty\"` // Test holds the configuration for Helm test actions for this HelmRelease. // +optional Test * Test `json:\"test,omitempty\"` // Rollback holds the configuration for Helm rollback actions for this HelmRelease. // +optional Rollback * Rollback `json:\"rollback,omitempty\"` // Uninstall holds the configuration for Helm uninstall actions for this HelmRelease. // +optional Uninstall * Uninstall `json:\"uninstall,omitempty\"` // ValuesFrom holds references to resources containing Helm values for this HelmRelease, // and information about how they should be merged. ValuesFrom [] ValuesReference `json:\"valuesFrom,omitempty\"` // Values holds the values for this Helm release. // +optional Values * apiextensionsv1 . JSON `json:\"values,omitempty\"` } // HelmChartTemplate defines the template from which the controller will // generate a v1beta1.HelmChart object in the same namespace as the referenced // v1beta1.Source. type HelmChartTemplate struct { // Spec holds the template for the v1beta1.HelmChartSpec for this HelmRelease. // +required Spec HelmChartTemplateSpec `json:\"spec\"` } // HelmChartTemplateSpec defines the template from which the controller will // generate a v1beta1.HelmChartSpec object. type HelmChartTemplateSpec struct { // The name or path the Helm chart is available at in the SourceRef. // +required Chart string `json:\"chart\"` // Version semver expression, ignored for charts from v1beta1.GitRepository and // v1beta1.Bucket sources. Defaults to latest when omitted. // +optional Version string `json:\"version,omitempty\"` // The name and namespace of the v1beta1.Source the chart is available at. // +required SourceRef CrossNamespaceObjectReference `json:\"sourceRef\"` // Interval at which to check the v1beta1.Source for updates. Defaults to // 'HelmReleaseSpec.Interval'. // +optional Interval * metav1 . Duration `json:\"interval,omitempty\"` // Alternative values file to use as the default chart values, expected to be a // relative path in the SourceRef. Ignored when omitted. // +optional ValuesFile string `json:\"valuesFile,omitempty\"` } // Install holds the configuration for Helm install actions performed for this // HelmRelease. type Install struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm install action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Remediation holds the remediation configuration for when the Helm install // action for the HelmRelease fails. The default is to not perform any action. // +optional Remediation * InstallRemediation `json:\"remediation,omitempty\"` // DisableWait disables the waiting for resources to be ready after a Helm // install has been performed. // +optional DisableWait bool `json:\"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm install action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // DisableOpenAPIValidation prevents the Helm install action from validating // rendered templates against the Kubernetes OpenAPI Schema. // +optional DisableOpenAPIValidation bool `json:\"disableOpenAPIValidation,omitempty\"` // Replace tells the Helm install action to re-use the 'ReleaseName', but only // if that name is a deleted release which remains in the history. // +optional Replace bool `json:\"replace,omitempty\"` // SkipCRDs tells the Helm install action to not install any CRDs. By default, // CRDs are installed if not already present. // +optional SkipCRDs bool `json:\"skipCRDs,omitempty\"` } // InstallRemediation holds the configuration for Helm install remediation. type InstallRemediation struct { // Retries is the number of retries that should be attempted on failures before // bailing. Remediation, using an uninstall, is performed between each attempt. // Defaults to '0', a negative integer equals to unlimited retries. // +optional Retries int `json:\"retries,omitempty\"` // IgnoreTestFailures tells the controller to skip remediation when the Helm // tests are run after an install action but fail. Defaults to // 'Test.IgnoreFailures'. // +optional IgnoreTestFailures * bool `json:\"ignoreTestFailures,omitempty\"` // RemediateLastFailure tells the controller to remediate the last failure, when // no retries remain. Defaults to 'false'. // +optional RemediateLastFailure * bool `json:\"remediateLastFailure,omitempty\"` } // Upgrade holds the configuration for Helm upgrade actions for this // HelmRelease. type Upgrade struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm upgrade action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Remediation holds the remediation configuration for when the Helm upgrade // action for the HelmRelease fails. The default is to not perform any action. // +optional Remediation * UpgradeRemediation `json:\"remediation,omitempty\"` // DisableWait disables the waiting for resources to be ready after a Helm // upgrade has been performed. // +optional DisableWait bool `json:\"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm upgrade action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // DisableOpenAPIValidation prevents the Helm upgrade action from validating // rendered templates against the Kubernetes OpenAPI Schema. // +optional DisableOpenAPIValidation bool `json:\"disableOpenAPIValidation,omitempty\"` // Force forces resource updates through a replacement strategy. // +optional Force bool `json:\"force,omitempty\"` // PreserveValues will make Helm reuse the last release's values and merge in // overrides from 'Values'. Setting this flag makes the HelmRelease // non-declarative. // +optional PreserveValues bool `json:\"preserveValues,omitempty\"` // CleanupOnFail allows deletion of new resources created during the Helm // upgrade action when it fails. // +optional CleanupOnFail bool `json:\"cleanupOnFail,omitempty\"` } // UpgradeRemediation holds the configuration for Helm upgrade remediation. type UpgradeRemediation struct { // Retries is the number of retries that should be attempted on failures before // bailing. Remediation, using 'Strategy', is performed between each attempt. // Defaults to '0', a negative integer equals to unlimited retries. // +optional Retries int `json:\"retries,omitempty\"` // IgnoreTestFailures tells the controller to skip remediation when the Helm // tests are run after an upgrade action but fail. // Defaults to 'Test.IgnoreFailures'. // +optional IgnoreTestFailures * bool `json:\"ignoreTestFailures,omitempty\"` // RemediateLastFailure tells the controller to remediate the last failure, when // no retries remain. Defaults to 'false' unless 'Retries' is greater than 0. // +optional RemediateLastFailure * bool `json:\"remediateLastFailure,omitempty\"` // Strategy to use for failure remediation. Defaults to 'rollback'. // +kubebuilder:validation:Enum=rollback;uninstall // +optional Strategy * RemediationStrategy `json:\"strategy,omitempty\"` } // Test holds the configuration for Helm test actions for this HelmRelease. type Test struct { // Enable enables Helm test actions for this HelmRelease after an Helm install // or upgrade action has been performed. // +optional Enable bool `json:\"enable,omitempty\"` // Timeout is the time to wait for any individual Kubernetes operation during // the performance of a Helm test action. Defaults to 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // IgnoreFailures tells the controller to skip remediation when the Helm tests // are run but fail. Can be overwritten for tests run after install or upgrade // actions in 'Install.IgnoreTestFailures' and 'Upgrade.IgnoreTestFailures'. // +optional IgnoreFailures bool `json:\"ignoreFailures,omitempty\"` } // Rollback holds the configuration for Helm rollback actions for this // HelmRelease. type Rollback struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm rollback action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // DisableWait disables the waiting for resources to be ready after a Helm // rollback has been performed. // +optional DisableWait bool `json:\"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm rollback action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // Recreate performs pod restarts for the resource if applicable. // +optional Recreate bool `json:\"recreate,omitempty\"` // Force forces resource updates through a replacement strategy. // +optional Force bool `json:\"force,omitempty\"` // CleanupOnFail allows deletion of new resources created during the Helm // rollback action when it fails. // +optional CleanupOnFail bool `json:\"cleanupOnFail,omitempty\"` } // Uninstall holds the configuration for Helm uninstall actions for this // HelmRelease. type Uninstall struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm uninstall action. Defaults // to 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // DisableHooks prevents hooks from running during the Helm rollback action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // KeepHistory tells Helm to remove all associated resources and mark the // release as deleted, but retain the release history. // +optional KeepHistory bool `json:\"keepHistory,omitempty\"` } Reference types \u00b6 // CrossNamespaceObjectReference contains enough information to let you locate the // typed referenced object at cluster level. type CrossNamespaceObjectReference struct { // APIVersion of the referent. // +optional APIVersion string `json:\"apiVersion,omitempty\"` // Kind of the referent. // +kubebuilder:validation:Enum=HelmRepository // +required Kind string `json:\"kind,omitempty\"` // Name of the referent. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=253 // +required Name string `json:\"name\"` // Namespace of the referent. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=63 // +kubebuilder:validation:Optional // +optional Namespace string `json:\"namespace,omitempty\"` } // ValuesReference contains a reference to a resource containing Helm values, // and optionally the key they can be found at. type ValuesReference struct { // Kind of the values referent, valid values are ('Secret', 'ConfigMap'). // +kubebuilder:validation:Enum=Secret;ConfigMap // +required Kind string `json:\"kind\"` // Name of the values referent. Should reside in the same namespace as the // referring resource. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=253 // +required Name string `json:\"name\"` // ValuesKey is the data key where the values.yaml or a specific value can be // found at. Defaults to 'values.yaml'. // +optional ValuesKey string `json:\"valuesKey,omitempty\"` // TargetPath is the YAML dot notation path the value should be merged at. When // set, the ValuesKey is expected to be a single flat value. Defaults to 'None', // which results in the values getting merged at the root. // +optional TargetPath string `json:\"targetPath,omitempty\"` // Optional marks this ValuesReference as optional. When set, a not found error // for the values reference is ignored, but any ValuesKey, TargetPath or // transient error will still result in a reconciliation failure. // +optional Optional bool `json:\"optional,omitempty\"` } Status specification \u00b6 // HelmReleaseStatus defines the observed state of a HelmRelease. type HelmReleaseStatus struct { // ObservedGeneration is the last observed generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // LastHandledReconcileAt is the last manual reconciliation request (by // annotating the HelmRelease) handled by the reconciler. // +optional LastHandledReconcileAt string `json:\"lastHandledReconcileAt,omitempty\"` // Conditions holds the conditions for the HelmRelease. // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // LastAppliedRevision is the revision of the last successfully applied source. // +optional LastAppliedRevision string `json:\"lastAppliedRevision,omitempty\"` // LastAttemptedRevision is the revision of the last reconciliation attempt. // +optional LastAttemptedRevision string `json:\"lastAttemptedRevision,omitempty\"` // LastAttemptedValuesChecksum is the SHA1 checksum of the values of the last // reconciliation attempt. // +optional LastAttemptedValuesChecksum string `json:\"lastAttemptedValuesChecksum,omitempty\"` // LastReleaseRevision is the revision of the last successful Helm release. // +optional LastReleaseRevision int `json:\"lastReleaseRevision,omitempty\"` // HelmChart is the namespaced name of the HelmChart resource created by // the controller for the HelmRelease. // +optional HelmChart string `json:\"helmChart,omitempty\"` // Failures is the reconciliation failure count against the latest observed // state. It is reset after a successful reconciliation. // +optional Failures int64 `json:\"failures,omitempty\"` // InstallFailures is the install failure count against the latest observed // state. It is reset after a successful reconciliation. // +optional InstallFailures int64 `json:\"installFailures,omitempty\"` // UpgradeFailures is the upgrade failure count against the latest observed // state. It is reset after a successful reconciliation. // +optional UpgradeFailures int64 `json:\"upgradeFailures,omitempty\"` } Condition types \u00b6 const ( // ReleasedCondition represents the status of the last release attempt // (install/upgrade/test) against the latest desired state. ReleasedCondition string = \"Released\" // TestSuccessCondition represents the status of the last test attempt against // the latest desired state. TestSuccessCondition string = \"TestSuccess\" // RemediatedCondition represents the status of the last remediation attempt // (uninstall/rollback) due to a failure of the last release attempt against the // latest desired state. RemediatedCondition string = \"Remediated\" ) Condition reasons \u00b6 const ( // InstallSucceededReason represents the fact that the Helm install for the // HelmRelease succeeded. InstallSucceededReason string = \"InstallSucceeded\" // InstallFailedReason represents the fact that the Helm install for the // HelmRelease failed. InstallFailedReason string = \"InstallFailed\" // UpgradeSucceededReason represents the fact that the Helm upgrade for the // HelmRelease succeeded. UpgradeSucceededReason string = \"UpgradeSucceeded\" // UpgradeFailedReason represents the fact that the Helm upgrade for the // HelmRelease failed. UpgradeFailedReason string = \"UpgradeFailed\" // TestSucceededReason represents the fact that the Helm tests for the // HelmRelease succeeded. TestSucceededReason string = \"TestSucceeded\" // TestFailedReason represents the fact that the Helm tests for the HelmRelease // failed. TestFailedReason string = \"TestFailed\" // RollbackSucceededReason represents the fact that the Helm rollback for the // HelmRelease succeeded. RollbackSucceededReason string = \"RollbackSucceeded\" // RollbackFailedReason represents the fact that the Helm test for the // HelmRelease failed. RollbackFailedReason string = \"RollbackFailed\" // UninstallSucceededReason represents the fact that the Helm uninstall for the // HelmRelease succeeded. UninstallSucceededReason string = \"UninstallSucceeded\" // UninstallFailedReason represents the fact that the Helm uninstall for the // HelmRelease failed. UninstallFailedReason string = \"UninstallFailed\" // ArtifactFailedReason represents the fact that the artifact download for the // HelmRelease failed. ArtifactFailedReason string = \"ArtifactFailed\" // InitFailedReason represents the fact that the initialization of the Helm // configuration failed. InitFailedReason string = \"InitFailed\" // GetLastReleaseFailedReason represents the fact that observing the last // release failed. GetLastReleaseFailedReason string = \"GetLastReleaseFailed\" ) Helm release placement \u00b6 The namespace/name in which to deploy the Helm release defaults to the namespace/name of the HelmRelease . These can be overridden respectively via spec.targetNamespace and spec.releaseName . If spec.targetNamespace is set, spec.releaseName defaults to <spec.targetNamespace>-<metadata.name> . Note: that configuring the spec.targetNamespace only defines the namespace the release is made in, the metadata for the release (also known as the \"Helm storage\") will always be stored in the metadata.namespace of the HelmRelease . Helm chart template \u00b6 The spec.chart.spec values are used by the helm-controller as a template to create a new HelmChart resource with the given spec. The spec.chart.spec.sourceRef is a reference to an object managed by source-controller . When the source revision changes, it generates a Kubernetes event that triggers a new release. Supported source types: HelmRepository GitRepository Bucket The HelmChart is created in the same namespace as the sourceRef , with a name matching the HelmRelease <metadata.namespace>-<metadata.name> . The chart.spec.chart can either contain: The name of the chart as made available by the HelmRepository (without any aliases), for example: podinfo The relative path the chart can be found at in the GitRepository , for example: ./charts/podinfo The chart.spec.version can be a fixed semver, or any semver range (i.e. >=4.0.0 <5.0.0 ). It is ignored for HelmRelease resources that reference a GitRepository or Bucket source. Values overrides \u00b6 The simplest way to define values overrides is inline via spec.values . It is also possible to define a list of ConfigMap and Secret resources from which to take values via spec.valuesFrom . The values are merged in the order given, with the later values overwriting earlier, and then spec.values overwriting those: spec : values : replicaCount : 2 valuesFrom : - kind : ConfigMap name : prod-env-values valuesKey : values-prod.yaml - kind : Secret name : prod-tls-values valuesKey : crt targetPath : tls.crt optional : true The definition of the listed keys for items in spec.valuesFrom is as follows: kind : Kind of the values referent ( ConfigMap or Secret ). name : Name of the values referent, in the same namespace as the HelmRelease . valuesKey (Optional) : The data key where the values.yaml or a specific value can be found. Defaults to values.yaml when omitted. targetPath (Optional) : The YAML dot notation path at which the value should be merged. When set, the valuesKey is expected to be a single flat value. Defaults to None when omitted, which results in the values getting merged at the root. optional (Optional) : Whether this values reference is optional. When true , a not found error for the values reference is ignored, but any valuesKey, targetPath or transient error will still result in a reconciliation failure. Defaults to false when omitted. Note: that the targetPath supports the same formatting as you would supply as an argument to the helm binary using --set [path]=[value] . In addition to this, the referred value can contain the same value formats (e.g. {a,b,c} for a list). You can read more about the available formats and limitations in the Helm documentation . Reconciliation \u00b6 If no Helm release with the matching namespace/name is found it will be installed. It will be upgraded any time the desired state is updated, which consists of: spec (and thus metadata.generation ) Latest HelmChart revision available ConfigMap and Secret values overrides . Changes to these do not trigger an immediate reconciliation, but will be handled upon the next reconciliation. This is to avoid a large number of upgrades occurring when multiple resources are updated. If the latest Helm release revision was not made by the helm-controller, it may not match the desired state, so an upgrade is made in this case as well. The spec.interval tells the reconciler at which interval to reconcile the release. The interval time units are s , m and h e.g. interval: 5m , the minimum value should be 60 seconds. The reconciler can be told to reconcile the HelmRelease outside of the specified interval by annotating the object with a fluxcd.io/reconcileAt annotation. For example: kubectl annotate --overwrite helmrelease/podinfo fluxcd.io/reconcileAt = \" $( date +%s ) \" Reconciliation can be suspended by setting spec.susped to true . The timeout for any individual Kubernetes operation (like Jobs for hooks) during the performance of Helm actions can be configured via spec.timeout and can be overridden per action via spec.<action>.timeout . Disabling resource waiting \u00b6 For install, upgrade, and rollback actions resource waiting is enabled by default, but can be disabled by setting spec.<action>.disableWait . HelmRelease dependencies \u00b6 When applying a HelmRelease , you may need to make sure other releases are Ready before the release is reconciled. For example, because your chart relies on the presence of a Custom Resource Definition installed by another HelmRelease . The spec.dependsOn field allows you to specify each of these dependencies. Assuming two HelmRelease resources: backend - contains the backend of the application frontend - contains the frontend of the application and relies on the backend apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : backend spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m upgrade : remediation : remediateLastFailure : true test : enable : true values : service : grpcService : backend resources : requests : cpu : 100m memory : 64Mi --- apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : frontend spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m dependsOn : - backend upgrade : remediation : remediateLastFailure : true test : enable : true values : backend : http://backend-podinfo:9898/echo resources : requests : cpu : 100m memory : 64Mi Note that this does not account for upgrade ordering. Kubernetes only allows applying one resource ( HelmRelease in this case) at a time, so there is no way for the controller to know when a dependency HelmRelease may be updated. Also, circular dependencies between HelmRelease resources must be avoided, otherwise the interdependent HelmRelease resources will never be reconciled. Configuring Helm test actions \u00b6 To make the controller run the Helm tests available for your chart after a successful Helm install or upgrade, spec.test.enable should be set to true . By default, when tests are enabled, failures in tests are considered release failures, and thus are subject to the triggering Helm action's remediation configuration. However, test failures can be ignored by setting spec.test.ignoreFailures to true . In this case, no remediation will be taken, and the test failure will not affect the Released and Ready status conditions. This can be overridden per Helm action by setting spec.install.remediation.ignoreTestFailures or spec.upgrade.remediation.ignoreTestFailures . apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : podinfo spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m test : enable : true ignoreFailures : true values : resources : requests : cpu : 100m memory : 64Mi Configuring failure remediation \u00b6 From time to time a Helm install/upgrade and accompanying Helm test may fail. When this occurs, by default no action is taken, and the release is left in a failed state. However, several automatic failure remediation options can be set via spec.install.remediation and spec.upgrade.remediation . The retries can be set to configure the number of retries after an initial failure. A negative integer results in infinite retries. This implicitly opts-in to a remediation action between each attempt. The remediation action for install failures is an uninstall. The remediation action for upgrade failures is by default a rollback, however spec.upgrade.remediation.strategy can be set to uninstall , in which case after the uninstall, the spec.install configuration takes over. One can also opt-in to remediation of the last failure (when no retries remain) by setting spec.<action>.remediation.remediateLastFailure to true . For upgrades, this defaults to true if at least one retry is configured. apiVersion : helm.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : podinfo spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m install : remediation : retries : 3 upgrade : remediation : remediateLastFailure : false values : resources : requests : cpu : 100m memory : 64Mi Status \u00b6 When the controller completes a reconciliation, it reports the result in the status sub-resource. The following status.condtions types are advertised. Here, \"desired state\" is as detailed in reconciliation : Ready - status of the last reconciliation attempt Released - status of the last release attempt (install/upgrade/test) against the latest desired state TestSuccess - status of the last test attempt against the latest desired state Remediated - status of the last remediation attempt (uninstall/rollback) due to a failure of the last release attempt against the latest desired state For example, you can wait for a successful helm-controller reconciliation with: kubectl wait helmrelease/podinfo --for = condition = ready Each of these conditions also include descriptive reason / message fields as to why the status is as such. Examples \u00b6 Install success \u00b6 status : conditions : - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm install succeeded reason : InstallSucceeded status : \"True\" type : Released - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm test succeeded reason : TestSucceeded status : \"True\" type : TestSuccess - lastTransitionTime : \"2020-07-13T13:13:42Z\" message : release reconciliation succeeded reason : ReconciliationSucceeded status : \"True\" type : Ready lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 2 Upgrade failure \u00b6 status : conditions : - lastTransitionTime : \"2020-07-13T13:17:28Z\" message : 'error validating \"\": error validating data: ValidationError(Deployment.spec.replicas): invalid type for io.k8s.api.apps.v1.DeploymentSpec.replicas: got \"string\", expected \"integer\"' reason : UpgradeFailed status : \"False\" type : Released - lastTransitionTime : \"2020-07-13T13:17:28Z\" message : 'error validating \"\": error validating data: ValidationError(Deployment.spec.replicas): invalid type for io.k8s.api.apps.v1.DeploymentSpec.replicas: got \"string\", expected \"integer\"' reason : UpgradeFailed status : \"False\" type : Ready failures : 1 lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 3 Ignored test failure \u00b6 status : conditions : - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm install succeeded reason : InstallSucceeded status : \"True\" type : Released - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm test failed reason : TestFailed status : \"False\" type : TestSuccess - lastTransitionTime : \"2020-07-13T13:13:42Z\" message : release reconciliation succeeded reason : ReconciliationSucceeded status : \"True\" type : Ready lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 2","title":"HelmRelease CRD"},{"location":"components/helm/helmreleases/#helm-releases","text":"The HelmRelease API defines a resource for automated controller driven Helm releases.","title":"Helm Releases"},{"location":"components/helm/helmreleases/#specification","text":"A helmrelease object defines a resource for controller driven reconciliation of Helm releases via Helm actions such as install, upgrade, test, uninstall, and rollback. This includes release placement (namespace/name), release content (chart/values overrides), action trigger configuration, individual action configuration, and statusing. // HelmReleaseSpec defines the desired state of a Helm Release. type HelmReleaseSpec struct { // Chart defines the template of the v1beta1.HelmChart that should be created // for this HelmRelease. // +required Chart HelmChartTemplate `json:\"chart\"` // Interval at which to reconcile the Helm release. // +required Interval metav1 . Duration `json:\"interval\"` // Suspend tells the controller to suspend reconciliation for this HelmRelease, // it does not apply to already started reconciliations. Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` // ReleaseName used for the Helm release. Defaults to a composition of // '[TargetNamespace-]Name'. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=53 // +kubebuilder:validation:Optional // +optional ReleaseName string `json:\"releaseName,omitempty\"` // TargetNamespace to target when performing operations for the HelmRelease. // Defaults to the namespace of the HelmRelease. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=63 // +kubebuilder:validation:Optional // +optional TargetNamespace string `json:\"targetNamespace,omitempty\"` // DependsOn may contain a dependency.CrossNamespaceDependencyReference slice with // references to HelmRelease resources that must be ready before this HelmRelease // can be reconciled. // +optional DependsOn [] dependency . CrossNamespaceDependencyReference `json:\"dependsOn,omitempty\"` // Timeout is the time to wait for any individual Kubernetes operation (like Jobs // for hooks) during the performance of a Helm action. Defaults to '5m0s'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // MaxHistory is the number of revisions saved by Helm for this HelmRelease. // Use '0' for an unlimited number of revisions; defaults to '10'. // +optional MaxHistory * int `json:\"maxHistory,omitempty\"` // Install holds the configuration for Helm install actions for this HelmRelease. // +optional Install * Install `json:\"install,omitempty\"` // Upgrade holds the configuration for Helm upgrade actions for this HelmRelease. // +optional Upgrade * Upgrade `json:\"upgrade,omitempty\"` // Test holds the configuration for Helm test actions for this HelmRelease. // +optional Test * Test `json:\"test,omitempty\"` // Rollback holds the configuration for Helm rollback actions for this HelmRelease. // +optional Rollback * Rollback `json:\"rollback,omitempty\"` // Uninstall holds the configuration for Helm uninstall actions for this HelmRelease. // +optional Uninstall * Uninstall `json:\"uninstall,omitempty\"` // ValuesFrom holds references to resources containing Helm values for this HelmRelease, // and information about how they should be merged. ValuesFrom [] ValuesReference `json:\"valuesFrom,omitempty\"` // Values holds the values for this Helm release. // +optional Values * apiextensionsv1 . JSON `json:\"values,omitempty\"` } // HelmChartTemplate defines the template from which the controller will // generate a v1beta1.HelmChart object in the same namespace as the referenced // v1beta1.Source. type HelmChartTemplate struct { // Spec holds the template for the v1beta1.HelmChartSpec for this HelmRelease. // +required Spec HelmChartTemplateSpec `json:\"spec\"` } // HelmChartTemplateSpec defines the template from which the controller will // generate a v1beta1.HelmChartSpec object. type HelmChartTemplateSpec struct { // The name or path the Helm chart is available at in the SourceRef. // +required Chart string `json:\"chart\"` // Version semver expression, ignored for charts from v1beta1.GitRepository and // v1beta1.Bucket sources. Defaults to latest when omitted. // +optional Version string `json:\"version,omitempty\"` // The name and namespace of the v1beta1.Source the chart is available at. // +required SourceRef CrossNamespaceObjectReference `json:\"sourceRef\"` // Interval at which to check the v1beta1.Source for updates. Defaults to // 'HelmReleaseSpec.Interval'. // +optional Interval * metav1 . Duration `json:\"interval,omitempty\"` // Alternative values file to use as the default chart values, expected to be a // relative path in the SourceRef. Ignored when omitted. // +optional ValuesFile string `json:\"valuesFile,omitempty\"` } // Install holds the configuration for Helm install actions performed for this // HelmRelease. type Install struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm install action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Remediation holds the remediation configuration for when the Helm install // action for the HelmRelease fails. The default is to not perform any action. // +optional Remediation * InstallRemediation `json:\"remediation,omitempty\"` // DisableWait disables the waiting for resources to be ready after a Helm // install has been performed. // +optional DisableWait bool `json:\"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm install action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // DisableOpenAPIValidation prevents the Helm install action from validating // rendered templates against the Kubernetes OpenAPI Schema. // +optional DisableOpenAPIValidation bool `json:\"disableOpenAPIValidation,omitempty\"` // Replace tells the Helm install action to re-use the 'ReleaseName', but only // if that name is a deleted release which remains in the history. // +optional Replace bool `json:\"replace,omitempty\"` // SkipCRDs tells the Helm install action to not install any CRDs. By default, // CRDs are installed if not already present. // +optional SkipCRDs bool `json:\"skipCRDs,omitempty\"` } // InstallRemediation holds the configuration for Helm install remediation. type InstallRemediation struct { // Retries is the number of retries that should be attempted on failures before // bailing. Remediation, using an uninstall, is performed between each attempt. // Defaults to '0', a negative integer equals to unlimited retries. // +optional Retries int `json:\"retries,omitempty\"` // IgnoreTestFailures tells the controller to skip remediation when the Helm // tests are run after an install action but fail. Defaults to // 'Test.IgnoreFailures'. // +optional IgnoreTestFailures * bool `json:\"ignoreTestFailures,omitempty\"` // RemediateLastFailure tells the controller to remediate the last failure, when // no retries remain. Defaults to 'false'. // +optional RemediateLastFailure * bool `json:\"remediateLastFailure,omitempty\"` } // Upgrade holds the configuration for Helm upgrade actions for this // HelmRelease. type Upgrade struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm upgrade action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Remediation holds the remediation configuration for when the Helm upgrade // action for the HelmRelease fails. The default is to not perform any action. // +optional Remediation * UpgradeRemediation `json:\"remediation,omitempty\"` // DisableWait disables the waiting for resources to be ready after a Helm // upgrade has been performed. // +optional DisableWait bool `json:\"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm upgrade action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // DisableOpenAPIValidation prevents the Helm upgrade action from validating // rendered templates against the Kubernetes OpenAPI Schema. // +optional DisableOpenAPIValidation bool `json:\"disableOpenAPIValidation,omitempty\"` // Force forces resource updates through a replacement strategy. // +optional Force bool `json:\"force,omitempty\"` // PreserveValues will make Helm reuse the last release's values and merge in // overrides from 'Values'. Setting this flag makes the HelmRelease // non-declarative. // +optional PreserveValues bool `json:\"preserveValues,omitempty\"` // CleanupOnFail allows deletion of new resources created during the Helm // upgrade action when it fails. // +optional CleanupOnFail bool `json:\"cleanupOnFail,omitempty\"` } // UpgradeRemediation holds the configuration for Helm upgrade remediation. type UpgradeRemediation struct { // Retries is the number of retries that should be attempted on failures before // bailing. Remediation, using 'Strategy', is performed between each attempt. // Defaults to '0', a negative integer equals to unlimited retries. // +optional Retries int `json:\"retries,omitempty\"` // IgnoreTestFailures tells the controller to skip remediation when the Helm // tests are run after an upgrade action but fail. // Defaults to 'Test.IgnoreFailures'. // +optional IgnoreTestFailures * bool `json:\"ignoreTestFailures,omitempty\"` // RemediateLastFailure tells the controller to remediate the last failure, when // no retries remain. Defaults to 'false' unless 'Retries' is greater than 0. // +optional RemediateLastFailure * bool `json:\"remediateLastFailure,omitempty\"` // Strategy to use for failure remediation. Defaults to 'rollback'. // +kubebuilder:validation:Enum=rollback;uninstall // +optional Strategy * RemediationStrategy `json:\"strategy,omitempty\"` } // Test holds the configuration for Helm test actions for this HelmRelease. type Test struct { // Enable enables Helm test actions for this HelmRelease after an Helm install // or upgrade action has been performed. // +optional Enable bool `json:\"enable,omitempty\"` // Timeout is the time to wait for any individual Kubernetes operation during // the performance of a Helm test action. Defaults to 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // IgnoreFailures tells the controller to skip remediation when the Helm tests // are run but fail. Can be overwritten for tests run after install or upgrade // actions in 'Install.IgnoreTestFailures' and 'Upgrade.IgnoreTestFailures'. // +optional IgnoreFailures bool `json:\"ignoreFailures,omitempty\"` } // Rollback holds the configuration for Helm rollback actions for this // HelmRelease. type Rollback struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm rollback action. Defaults to // 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // DisableWait disables the waiting for resources to be ready after a Helm // rollback has been performed. // +optional DisableWait bool `json:\"disableWait,omitempty\"` // DisableHooks prevents hooks from running during the Helm rollback action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // Recreate performs pod restarts for the resource if applicable. // +optional Recreate bool `json:\"recreate,omitempty\"` // Force forces resource updates through a replacement strategy. // +optional Force bool `json:\"force,omitempty\"` // CleanupOnFail allows deletion of new resources created during the Helm // rollback action when it fails. // +optional CleanupOnFail bool `json:\"cleanupOnFail,omitempty\"` } // Uninstall holds the configuration for Helm uninstall actions for this // HelmRelease. type Uninstall struct { // Timeout is the time to wait for any individual Kubernetes operation (like // Jobs for hooks) during the performance of a Helm uninstall action. Defaults // to 'HelmReleaseSpec.Timeout'. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // DisableHooks prevents hooks from running during the Helm rollback action. // +optional DisableHooks bool `json:\"disableHooks,omitempty\"` // KeepHistory tells Helm to remove all associated resources and mark the // release as deleted, but retain the release history. // +optional KeepHistory bool `json:\"keepHistory,omitempty\"` }","title":"Specification"},{"location":"components/helm/helmreleases/#reference-types","text":"// CrossNamespaceObjectReference contains enough information to let you locate the // typed referenced object at cluster level. type CrossNamespaceObjectReference struct { // APIVersion of the referent. // +optional APIVersion string `json:\"apiVersion,omitempty\"` // Kind of the referent. // +kubebuilder:validation:Enum=HelmRepository // +required Kind string `json:\"kind,omitempty\"` // Name of the referent. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=253 // +required Name string `json:\"name\"` // Namespace of the referent. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=63 // +kubebuilder:validation:Optional // +optional Namespace string `json:\"namespace,omitempty\"` } // ValuesReference contains a reference to a resource containing Helm values, // and optionally the key they can be found at. type ValuesReference struct { // Kind of the values referent, valid values are ('Secret', 'ConfigMap'). // +kubebuilder:validation:Enum=Secret;ConfigMap // +required Kind string `json:\"kind\"` // Name of the values referent. Should reside in the same namespace as the // referring resource. // +kubebuilder:validation:MinLength=1 // +kubebuilder:validation:MaxLength=253 // +required Name string `json:\"name\"` // ValuesKey is the data key where the values.yaml or a specific value can be // found at. Defaults to 'values.yaml'. // +optional ValuesKey string `json:\"valuesKey,omitempty\"` // TargetPath is the YAML dot notation path the value should be merged at. When // set, the ValuesKey is expected to be a single flat value. Defaults to 'None', // which results in the values getting merged at the root. // +optional TargetPath string `json:\"targetPath,omitempty\"` // Optional marks this ValuesReference as optional. When set, a not found error // for the values reference is ignored, but any ValuesKey, TargetPath or // transient error will still result in a reconciliation failure. // +optional Optional bool `json:\"optional,omitempty\"` }","title":"Reference types"},{"location":"components/helm/helmreleases/#status-specification","text":"// HelmReleaseStatus defines the observed state of a HelmRelease. type HelmReleaseStatus struct { // ObservedGeneration is the last observed generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // LastHandledReconcileAt is the last manual reconciliation request (by // annotating the HelmRelease) handled by the reconciler. // +optional LastHandledReconcileAt string `json:\"lastHandledReconcileAt,omitempty\"` // Conditions holds the conditions for the HelmRelease. // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // LastAppliedRevision is the revision of the last successfully applied source. // +optional LastAppliedRevision string `json:\"lastAppliedRevision,omitempty\"` // LastAttemptedRevision is the revision of the last reconciliation attempt. // +optional LastAttemptedRevision string `json:\"lastAttemptedRevision,omitempty\"` // LastAttemptedValuesChecksum is the SHA1 checksum of the values of the last // reconciliation attempt. // +optional LastAttemptedValuesChecksum string `json:\"lastAttemptedValuesChecksum,omitempty\"` // LastReleaseRevision is the revision of the last successful Helm release. // +optional LastReleaseRevision int `json:\"lastReleaseRevision,omitempty\"` // HelmChart is the namespaced name of the HelmChart resource created by // the controller for the HelmRelease. // +optional HelmChart string `json:\"helmChart,omitempty\"` // Failures is the reconciliation failure count against the latest observed // state. It is reset after a successful reconciliation. // +optional Failures int64 `json:\"failures,omitempty\"` // InstallFailures is the install failure count against the latest observed // state. It is reset after a successful reconciliation. // +optional InstallFailures int64 `json:\"installFailures,omitempty\"` // UpgradeFailures is the upgrade failure count against the latest observed // state. It is reset after a successful reconciliation. // +optional UpgradeFailures int64 `json:\"upgradeFailures,omitempty\"` }","title":"Status specification"},{"location":"components/helm/helmreleases/#condition-types","text":"const ( // ReleasedCondition represents the status of the last release attempt // (install/upgrade/test) against the latest desired state. ReleasedCondition string = \"Released\" // TestSuccessCondition represents the status of the last test attempt against // the latest desired state. TestSuccessCondition string = \"TestSuccess\" // RemediatedCondition represents the status of the last remediation attempt // (uninstall/rollback) due to a failure of the last release attempt against the // latest desired state. RemediatedCondition string = \"Remediated\" )","title":"Condition types"},{"location":"components/helm/helmreleases/#condition-reasons","text":"const ( // InstallSucceededReason represents the fact that the Helm install for the // HelmRelease succeeded. InstallSucceededReason string = \"InstallSucceeded\" // InstallFailedReason represents the fact that the Helm install for the // HelmRelease failed. InstallFailedReason string = \"InstallFailed\" // UpgradeSucceededReason represents the fact that the Helm upgrade for the // HelmRelease succeeded. UpgradeSucceededReason string = \"UpgradeSucceeded\" // UpgradeFailedReason represents the fact that the Helm upgrade for the // HelmRelease failed. UpgradeFailedReason string = \"UpgradeFailed\" // TestSucceededReason represents the fact that the Helm tests for the // HelmRelease succeeded. TestSucceededReason string = \"TestSucceeded\" // TestFailedReason represents the fact that the Helm tests for the HelmRelease // failed. TestFailedReason string = \"TestFailed\" // RollbackSucceededReason represents the fact that the Helm rollback for the // HelmRelease succeeded. RollbackSucceededReason string = \"RollbackSucceeded\" // RollbackFailedReason represents the fact that the Helm test for the // HelmRelease failed. RollbackFailedReason string = \"RollbackFailed\" // UninstallSucceededReason represents the fact that the Helm uninstall for the // HelmRelease succeeded. UninstallSucceededReason string = \"UninstallSucceeded\" // UninstallFailedReason represents the fact that the Helm uninstall for the // HelmRelease failed. UninstallFailedReason string = \"UninstallFailed\" // ArtifactFailedReason represents the fact that the artifact download for the // HelmRelease failed. ArtifactFailedReason string = \"ArtifactFailed\" // InitFailedReason represents the fact that the initialization of the Helm // configuration failed. InitFailedReason string = \"InitFailed\" // GetLastReleaseFailedReason represents the fact that observing the last // release failed. GetLastReleaseFailedReason string = \"GetLastReleaseFailed\" )","title":"Condition reasons"},{"location":"components/helm/helmreleases/#helm-release-placement","text":"The namespace/name in which to deploy the Helm release defaults to the namespace/name of the HelmRelease . These can be overridden respectively via spec.targetNamespace and spec.releaseName . If spec.targetNamespace is set, spec.releaseName defaults to <spec.targetNamespace>-<metadata.name> . Note: that configuring the spec.targetNamespace only defines the namespace the release is made in, the metadata for the release (also known as the \"Helm storage\") will always be stored in the metadata.namespace of the HelmRelease .","title":"Helm release placement"},{"location":"components/helm/helmreleases/#helm-chart-template","text":"The spec.chart.spec values are used by the helm-controller as a template to create a new HelmChart resource with the given spec. The spec.chart.spec.sourceRef is a reference to an object managed by source-controller . When the source revision changes, it generates a Kubernetes event that triggers a new release. Supported source types: HelmRepository GitRepository Bucket The HelmChart is created in the same namespace as the sourceRef , with a name matching the HelmRelease <metadata.namespace>-<metadata.name> . The chart.spec.chart can either contain: The name of the chart as made available by the HelmRepository (without any aliases), for example: podinfo The relative path the chart can be found at in the GitRepository , for example: ./charts/podinfo The chart.spec.version can be a fixed semver, or any semver range (i.e. >=4.0.0 <5.0.0 ). It is ignored for HelmRelease resources that reference a GitRepository or Bucket source.","title":"Helm chart template"},{"location":"components/helm/helmreleases/#values-overrides","text":"The simplest way to define values overrides is inline via spec.values . It is also possible to define a list of ConfigMap and Secret resources from which to take values via spec.valuesFrom . The values are merged in the order given, with the later values overwriting earlier, and then spec.values overwriting those: spec : values : replicaCount : 2 valuesFrom : - kind : ConfigMap name : prod-env-values valuesKey : values-prod.yaml - kind : Secret name : prod-tls-values valuesKey : crt targetPath : tls.crt optional : true The definition of the listed keys for items in spec.valuesFrom is as follows: kind : Kind of the values referent ( ConfigMap or Secret ). name : Name of the values referent, in the same namespace as the HelmRelease . valuesKey (Optional) : The data key where the values.yaml or a specific value can be found. Defaults to values.yaml when omitted. targetPath (Optional) : The YAML dot notation path at which the value should be merged. When set, the valuesKey is expected to be a single flat value. Defaults to None when omitted, which results in the values getting merged at the root. optional (Optional) : Whether this values reference is optional. When true , a not found error for the values reference is ignored, but any valuesKey, targetPath or transient error will still result in a reconciliation failure. Defaults to false when omitted. Note: that the targetPath supports the same formatting as you would supply as an argument to the helm binary using --set [path]=[value] . In addition to this, the referred value can contain the same value formats (e.g. {a,b,c} for a list). You can read more about the available formats and limitations in the Helm documentation .","title":"Values overrides"},{"location":"components/helm/helmreleases/#reconciliation","text":"If no Helm release with the matching namespace/name is found it will be installed. It will be upgraded any time the desired state is updated, which consists of: spec (and thus metadata.generation ) Latest HelmChart revision available ConfigMap and Secret values overrides . Changes to these do not trigger an immediate reconciliation, but will be handled upon the next reconciliation. This is to avoid a large number of upgrades occurring when multiple resources are updated. If the latest Helm release revision was not made by the helm-controller, it may not match the desired state, so an upgrade is made in this case as well. The spec.interval tells the reconciler at which interval to reconcile the release. The interval time units are s , m and h e.g. interval: 5m , the minimum value should be 60 seconds. The reconciler can be told to reconcile the HelmRelease outside of the specified interval by annotating the object with a fluxcd.io/reconcileAt annotation. For example: kubectl annotate --overwrite helmrelease/podinfo fluxcd.io/reconcileAt = \" $( date +%s ) \" Reconciliation can be suspended by setting spec.susped to true . The timeout for any individual Kubernetes operation (like Jobs for hooks) during the performance of Helm actions can be configured via spec.timeout and can be overridden per action via spec.<action>.timeout .","title":"Reconciliation"},{"location":"components/helm/helmreleases/#disabling-resource-waiting","text":"For install, upgrade, and rollback actions resource waiting is enabled by default, but can be disabled by setting spec.<action>.disableWait .","title":"Disabling resource waiting"},{"location":"components/helm/helmreleases/#helmrelease-dependencies","text":"When applying a HelmRelease , you may need to make sure other releases are Ready before the release is reconciled. For example, because your chart relies on the presence of a Custom Resource Definition installed by another HelmRelease . The spec.dependsOn field allows you to specify each of these dependencies. Assuming two HelmRelease resources: backend - contains the backend of the application frontend - contains the frontend of the application and relies on the backend apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : backend spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m upgrade : remediation : remediateLastFailure : true test : enable : true values : service : grpcService : backend resources : requests : cpu : 100m memory : 64Mi --- apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : frontend spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m dependsOn : - backend upgrade : remediation : remediateLastFailure : true test : enable : true values : backend : http://backend-podinfo:9898/echo resources : requests : cpu : 100m memory : 64Mi Note that this does not account for upgrade ordering. Kubernetes only allows applying one resource ( HelmRelease in this case) at a time, so there is no way for the controller to know when a dependency HelmRelease may be updated. Also, circular dependencies between HelmRelease resources must be avoided, otherwise the interdependent HelmRelease resources will never be reconciled.","title":"HelmRelease dependencies"},{"location":"components/helm/helmreleases/#configuring-helm-test-actions","text":"To make the controller run the Helm tests available for your chart after a successful Helm install or upgrade, spec.test.enable should be set to true . By default, when tests are enabled, failures in tests are considered release failures, and thus are subject to the triggering Helm action's remediation configuration. However, test failures can be ignored by setting spec.test.ignoreFailures to true . In this case, no remediation will be taken, and the test failure will not affect the Released and Ready status conditions. This can be overridden per Helm action by setting spec.install.remediation.ignoreTestFailures or spec.upgrade.remediation.ignoreTestFailures . apiVersion : helm.toolkit.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : podinfo spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m test : enable : true ignoreFailures : true values : resources : requests : cpu : 100m memory : 64Mi","title":"Configuring Helm test actions"},{"location":"components/helm/helmreleases/#configuring-failure-remediation","text":"From time to time a Helm install/upgrade and accompanying Helm test may fail. When this occurs, by default no action is taken, and the release is left in a failed state. However, several automatic failure remediation options can be set via spec.install.remediation and spec.upgrade.remediation . The retries can be set to configure the number of retries after an initial failure. A negative integer results in infinite retries. This implicitly opts-in to a remediation action between each attempt. The remediation action for install failures is an uninstall. The remediation action for upgrade failures is by default a rollback, however spec.upgrade.remediation.strategy can be set to uninstall , in which case after the uninstall, the spec.install configuration takes over. One can also opt-in to remediation of the last failure (when no retries remain) by setting spec.<action>.remediation.remediateLastFailure to true . For upgrades, this defaults to true if at least one retry is configured. apiVersion : helm.fluxcd.io/v2beta1 kind : HelmRelease metadata : name : podinfo spec : interval : 5m chart : spec : chart : podinfo version : '>=4.0.0 <5.0.0' sourceRef : kind : HelmRepository name : podinfo interval : 1m install : remediation : retries : 3 upgrade : remediation : remediateLastFailure : false values : resources : requests : cpu : 100m memory : 64Mi","title":"Configuring failure remediation"},{"location":"components/helm/helmreleases/#status","text":"When the controller completes a reconciliation, it reports the result in the status sub-resource. The following status.condtions types are advertised. Here, \"desired state\" is as detailed in reconciliation : Ready - status of the last reconciliation attempt Released - status of the last release attempt (install/upgrade/test) against the latest desired state TestSuccess - status of the last test attempt against the latest desired state Remediated - status of the last remediation attempt (uninstall/rollback) due to a failure of the last release attempt against the latest desired state For example, you can wait for a successful helm-controller reconciliation with: kubectl wait helmrelease/podinfo --for = condition = ready Each of these conditions also include descriptive reason / message fields as to why the status is as such.","title":"Status"},{"location":"components/helm/helmreleases/#examples","text":"","title":"Examples"},{"location":"components/helm/helmreleases/#install-success","text":"status : conditions : - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm install succeeded reason : InstallSucceeded status : \"True\" type : Released - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm test succeeded reason : TestSucceeded status : \"True\" type : TestSuccess - lastTransitionTime : \"2020-07-13T13:13:42Z\" message : release reconciliation succeeded reason : ReconciliationSucceeded status : \"True\" type : Ready lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 2","title":"Install success"},{"location":"components/helm/helmreleases/#upgrade-failure","text":"status : conditions : - lastTransitionTime : \"2020-07-13T13:17:28Z\" message : 'error validating \"\": error validating data: ValidationError(Deployment.spec.replicas): invalid type for io.k8s.api.apps.v1.DeploymentSpec.replicas: got \"string\", expected \"integer\"' reason : UpgradeFailed status : \"False\" type : Released - lastTransitionTime : \"2020-07-13T13:17:28Z\" message : 'error validating \"\": error validating data: ValidationError(Deployment.spec.replicas): invalid type for io.k8s.api.apps.v1.DeploymentSpec.replicas: got \"string\", expected \"integer\"' reason : UpgradeFailed status : \"False\" type : Ready failures : 1 lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 3","title":"Upgrade failure"},{"location":"components/helm/helmreleases/#ignored-test-failure","text":"status : conditions : - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm install succeeded reason : InstallSucceeded status : \"True\" type : Released - lastTransitionTime : \"2020-07-13T13:13:40Z\" message : Helm test failed reason : TestFailed status : \"False\" type : TestSuccess - lastTransitionTime : \"2020-07-13T13:13:42Z\" message : release reconciliation succeeded reason : ReconciliationSucceeded status : \"True\" type : Ready lastAppliedRevision : 4.0.6 lastAttemptedRevision : 4.0.6 lastReleaseRevision : 1 observedGeneration : 2","title":"Ignored test failure"},{"location":"components/kustomize/api/","text":"Kustomize API reference Packages: kustomize.toolkit.fluxcd.io/v1beta1 kustomize.toolkit.fluxcd.io/v1beta1 Package v1beta1 contains API Schema definitions for the kustomize v1beta1 API group Resource Types: Kustomization Kustomization Kustomization is the Schema for the kustomizations API. Field Description apiVersion string kustomize.toolkit.fluxcd.io/v1beta1 kind string Kustomization metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec KustomizationSpec dependsOn []Runtime dependency.CrossNamespaceDependencyReference (Optional) DependsOn may contain a dependency.CrossNamespaceDependencyReference slice with references to Kustomization resources that must be ready before this Kustomization can be reconciled. decryption Decryption (Optional) Decrypt Kubernetes secrets before applying them on the cluster. interval Kubernetes meta/v1.Duration The interval at which to reconcile the kustomization. kubeConfig KubeConfig (Optional) The KubeConfig for reconciling the Kustomization on a remote cluster. path string Path to the directory containing the kustomization file. prune bool Prune enables garbage collection. healthChecks []CrossNamespaceObjectReference (Optional) A list of resources to be included in the health assessment. serviceAccount ServiceAccount (Optional) The Kubernetes service account used for applying the kustomization. sourceRef CrossNamespaceSourceReference Reference of the source where the kustomization file is. suspend bool (Optional) This flag tells the controller to suspend subsequent kustomize executions, it does not apply to already started executions. Defaults to false. targetNamespace string (Optional) TargetNamespace sets or overrides the namespace in the kustomization.yaml file. timeout Kubernetes meta/v1.Duration (Optional) Timeout for validation, apply and health checking operations. Defaults to \u2018Interval\u2019 duration. validation string (Optional) Validate the Kubernetes objects before applying them on the cluster. The validation strategy can be \u2018client\u2019 (local dry-run) or \u2018server\u2019 (APIServer dry-run). status KustomizationStatus CrossNamespaceObjectReference ( Appears on: KustomizationSpec ) CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level Field Description apiVersion string (Optional) API version of the referent, defaults to \u2018apps/v1\u2019 kind string Kind of the referent name string Name of the referent namespace string (Optional) Namespace of the referent CrossNamespaceSourceReference ( Appears on: KustomizationSpec ) CrossNamespaceSourceReference contains enough information to let you locate the typed referenced object at cluster level Field Description apiVersion string (Optional) API version of the referent kind string Kind of the referent name string Name of the referent namespace string (Optional) Namespace of the referent, defaults to the Kustomization namespace Decryption ( Appears on: KustomizationSpec ) Decryption defines how decryption is handled for Kubernetes manifests. Field Description provider string Provider is the name of the decryption engine. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The secret name containing the private OpenPGP keys used for decryption. KubeConfig ( Appears on: KustomizationSpec ) KubeConfig references a Kubernetes secret generated by CAPI. that contains a kubeconfig file. Field Description secretRef Kubernetes core/v1.LocalObjectReference The secret name containing a \u2018value\u2019 key with the kubeconfig file as the value. Ref: https://github.com/kubernetes-sigs/cluster-api/blob/release-0.3/util/secret/consts.go#L24 KustomizationSpec ( Appears on: Kustomization ) KustomizationSpec defines the desired state of a kustomization. Field Description dependsOn []Runtime dependency.CrossNamespaceDependencyReference (Optional) DependsOn may contain a dependency.CrossNamespaceDependencyReference slice with references to Kustomization resources that must be ready before this Kustomization can be reconciled. decryption Decryption (Optional) Decrypt Kubernetes secrets before applying them on the cluster. interval Kubernetes meta/v1.Duration The interval at which to reconcile the kustomization. kubeConfig KubeConfig (Optional) The KubeConfig for reconciling the Kustomization on a remote cluster. path string Path to the directory containing the kustomization file. prune bool Prune enables garbage collection. healthChecks []CrossNamespaceObjectReference (Optional) A list of resources to be included in the health assessment. serviceAccount ServiceAccount (Optional) The Kubernetes service account used for applying the kustomization. sourceRef CrossNamespaceSourceReference Reference of the source where the kustomization file is. suspend bool (Optional) This flag tells the controller to suspend subsequent kustomize executions, it does not apply to already started executions. Defaults to false. targetNamespace string (Optional) TargetNamespace sets or overrides the namespace in the kustomization.yaml file. timeout Kubernetes meta/v1.Duration (Optional) Timeout for validation, apply and health checking operations. Defaults to \u2018Interval\u2019 duration. validation string (Optional) Validate the Kubernetes objects before applying them on the cluster. The validation strategy can be \u2018client\u2019 (local dry-run) or \u2018server\u2019 (APIServer dry-run). KustomizationStatus ( Appears on: Kustomization ) KustomizationStatus defines the observed state of a kustomization. Field Description observedGeneration int64 (Optional) ObservedGeneration is the last reconciled generation. conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) lastAppliedRevision string (Optional) The last successfully applied revision. The revision format for Git sources is / . lastAttemptedRevision string (Optional) LastAttemptedRevision is the revision of the last reconciliation attempt. lastHandledReconcileAt string (Optional) LastHandledReconcileAt is the last manual reconciliation request (by annotating the Kustomization) handled by the reconciler. snapshot Snapshot (Optional) The last successfully applied revision metadata. ServiceAccount ( Appears on: KustomizationSpec ) ServiceAccount defines a reference to a Kubernetes service account. Field Description name string Name is the name of the service account being referenced. namespace string Namespace is the namespace of the service account being referenced. Snapshot ( Appears on: KustomizationStatus ) Snapshot holds the metadata of the Kubernetes objects generated for a source revision Field Description checksum string The manifests sha1 checksum. entries []SnapshotEntry A list of Kubernetes kinds grouped by namespace. SnapshotEntry ( Appears on: Snapshot ) Snapshot holds the metadata of namespaced Kubernetes objects Field Description namespace string (Optional) The namespace of this entry. kinds map[string]string The list of Kubernetes kinds. This page was automatically generated with gen-crd-api-reference-docs","title":"Kustomize API Reference"},{"location":"components/kustomize/controller/","text":"Kustomize Controller \u00b6 The kustomize-controller is a Kubernetes operator, specialized in running continuous delivery pipelines for infrastructure and workloads defined with Kubernetes manifests and assembled with Kustomize. Features: Reconciles the cluster state from multiple sources (provided by source-controller) Generates manifests with Kustomize (from plain Kubernetes yamls or Kustomize overlays) Validates manifests against Kubernetes API Impersonates service accounts (multi-tenancy RBAC) Health assessment of the deployed workloads Runs pipelines in a specific order (depends-on relationship) Prunes objects removed from source (garbage collection) Reports cluster state changes (alerting provided by notification-controller) Links: Source code fluxcd/kustomize-controller Specification docs","title":"Overview"},{"location":"components/kustomize/controller/#kustomize-controller","text":"The kustomize-controller is a Kubernetes operator, specialized in running continuous delivery pipelines for infrastructure and workloads defined with Kubernetes manifests and assembled with Kustomize. Features: Reconciles the cluster state from multiple sources (provided by source-controller) Generates manifests with Kustomize (from plain Kubernetes yamls or Kustomize overlays) Validates manifests against Kubernetes API Impersonates service accounts (multi-tenancy RBAC) Health assessment of the deployed workloads Runs pipelines in a specific order (depends-on relationship) Prunes objects removed from source (garbage collection) Reports cluster state changes (alerting provided by notification-controller) Links: Source code fluxcd/kustomize-controller Specification docs","title":"Kustomize Controller"},{"location":"components/kustomize/kustomization/","text":"Kustomization \u00b6 The Kustomization API defines a pipeline for fetching, decrypting, building, validating and applying Kubernetes manifests. Specification \u00b6 A Kustomization object defines the source of Kubernetes manifests by referencing an object managed by source-controller , the path to the kustomization file within that source, and the interval at which the kustomize build output is applied on the cluster. type KustomizationSpec struct { // DependsOn may contain a dependency.CrossNamespaceDependencyReference slice // with references to Kustomization resources that must be ready before this // Kustomization can be reconciled. // +optional DependsOn [] dependency . CrossNamespaceDependencyReference `json:\"dependsOn,omitempty\"` // Decrypt Kubernetes secrets before applying them on the cluster. // +optional Decryption * Decryption `json:\"decryption,omitempty\"` // The interval at which to apply the kustomization. // +required Interval metav1 . Duration `json:\"interval\"` // The KubeConfig for reconciling the Kustomization on a remote cluster. // +optional KubeConfig * KubeConfig `json:\"kubeConfig,omitempty\"` // Path to the directory containing the kustomization file. // +kubebuilder:validation:Pattern=\"^\\\\./\" // +required Path string `json:\"path\"` // Enables garbage collection. // +required Prune bool `json:\"prune\"` // A list of resources to be included in the health assessment. // +optional HealthChecks [] CrossNamespaceObjectReference `json:\"healthChecks,omitempty\"` // The Kubernetes service account used for applying the kustomization. // +optional ServiceAccount * ServiceAccount `json:\"serviceAccount,omitempty\"` // Reference of the source where the kustomization file is. // +required SourceRef CrossNamespaceSourceReference `json:\"sourceRef\"` // This flag tells the controller to suspend subsequent kustomize executions, // it does not apply to already started executions. Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` // TargetNamespace sets or overrides the namespace in the // kustomization.yaml file. // +optional TargetNamespace string `json:\"targetNamespace,omitempty\"` // Timeout for validation, apply and health checking operations. // Defaults to 'Interval' duration. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Validate the Kubernetes objects before applying them on the cluster. // The validation strategy can be 'client' (local dry-run) or 'server' (APIServer dry-run). // +kubebuilder:validation:Enum=client;server // +optional Validation string `json:\"validation,omitempty\"` } The decryption section defines how decryption is handled for Kubernetes manifests: type Decryption struct { // Provider is the name of the decryption engine. // +kubebuilder:validation:Enum=sops // +required Provider string `json:\"provider\"` // The secret name containing the private OpenPGP keys used for decryption. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } KubeConfig references a Kubernetes secret generated by CAPI: type KubeConfig struct { // The secret name containing a 'value' key with the kubeconfig file as the value. // Ref: https://github.com/kubernetes-sigs/cluster-api/blob/release-0.3/util/secret/consts.go#L24 // +required SecretRef corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } The status sub-resource records the result of the last reconciliation: type KustomizationStatus struct { // ObservedGeneration is the last reconciled generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // +optional Conditions [] Condition `json:\"conditions,omitempty\"` // The last successfully applied revision. // The revision format for Git sources is <branch|tag>/<commit-sha>. // +optional LastAppliedRevision string `json:\"lastAppliedRevision,omitempty\"` // LastAttemptedRevision is the revision of the last reconciliation attempt. // +optional LastAttemptedRevision string `json:\"lastAttemptedRevision,omitempty\"` // LastHandledReconcileAt is the last manual reconciliation request (by // annotating the Kustomization) handled by the reconciler. // +optional LastHandledReconcileAt string `json:\"lastHandledReconcileAt,omitempty\"` // The last successfully applied revision metadata. // +optional Snapshot * Snapshot `json:\"snapshot\"` } Status condition types: const ( // ReadyCondition is the name of the condition that // records the readiness status of a Kustomization. ReadyCondition string = \"Ready\" ) Status condition reasons: const ( // ReconciliationSucceededReason represents the fact that the // reconciliation of the Kustomization has succeeded. ReconciliationSucceededReason string = \"ReconciliationSucceeded\" // ReconciliationFailedReason represents the fact that the // reconciliation of the Kustomization has failed. ReconciliationFailedReason string = \"ReconciliationFailed\" // ProgressingReason represents the fact that the // reconciliation of the Kustomization is underway. ProgressingReason string = \"Progressing\" // SuspendedReason represents the fact that the // reconciliation of the Kustomization has been suspended. SuspendedReason string = \"Suspended\" // DependencyNotReady represents the fact that // one of the dependencies of the Kustomization is not ready. DependencyNotReadyReason string = \"DependencyNotReady\" // PruneFailedReason represents the fact that the // pruning of the Kustomization failed. PruneFailedReason string = \"PruneFailed\" // ArtifactFailedReason represents the fact that the // artifact download of the kustomization failed. ArtifactFailedReason string = \"ArtifactFailed\" // BuildFailedReason represents the fact that the // kustomize build of the Kustomization failed. BuildFailedReason string = \"BuildFailed\" // HealthCheckFailedReason represents the fact that // one of the health checks of the Kustomization failed. HealthCheckFailedReason string = \"HealthCheckFailed\" // ValidationFailedReason represents the fact that the // validation of the Kustomization manifests has failed. ValidationFailedReason string = \"ValidationFailed\" ) Source reference \u00b6 The kustomization spec.sourceRef is a reference to an object managed by source-controller . When the source revision changes, it generates a Kubernetes event that triggers a kustomize build and apply. Source supported types: GitRepository Bucket Note that the source should contain the kustomization.yaml and all the Kubernetes manifests and configuration files referenced in the kustomization.yaml. If your Git repository or S3 bucket contains only plain manifests, then a kustomization.yaml will be automatically generated. Generate kustomization.yaml \u00b6 If your repository contains plain Kubernetes manifests, the kustomization.yaml file is automatically generated for all the Kubernetes manifests in the spec.path and sub-directories. If the spec.prune is enable, the controller generates a label transformer to enable garbage collection . Reconciliation \u00b6 The kustomization spec.interval tells the controller at which interval to fetch the Kubernetes manifest for the source, build the kustomization and apply it on the cluster. The interval time units are s , m and h e.g. interval: 5m , the minimum value should be over 60 seconds. The kustomization execution can be suspended by setting spec.susped to true . The controller can be told to reconcile the kustomization outside of the specified interval by annotating the kustomization object with: const ( // ReconcileAtAnnotation is the annotation used for triggering a // reconciliation outside of the defined schedule. ReconcileAtAnnotation string = \"fluxcd.io/reconcileAt\" ) On-demand execution example: kubectl annotate --overwrite kustomization/podinfo fluxcd.io/reconcileAt = \" $( date +%s ) \" Garbage collection \u00b6 To enable garbage collection, set spec.prune to true . Garbage collection means that the Kubernetes objects that were previously applied on the cluster but are missing from the current source revision, are removed from cluster automatically. Garbage collection is also performed when a Kustomization object is deleted, triggering a removal of all Kubernetes objects previously applied on the cluster. Health assessment \u00b6 A kustomization can contain a series of health checks used to determine the rollout status of the deployed workloads and the ready status of custom resources. A health check entry can reference one of the following types: Kubernetes builtin kinds: Deployment, DaemonSet, StatefulSet, PersistentVolumeClaim, Pod, PodDisruptionBudget, Job, CronJob, Service, Secret, ConfigMap, CustomResourceDefinition Toolkit kinds: HelmRelease, HelmRepository, GitRepository, etc Custom resources that are compatible with kstatus Assuming the kustomization source contains a Kubernetes Deployment named backend , a health check can be defined as follows: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend spec : interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp healthChecks : - apiVersion : apps/v1 kind : Deployment name : backend namespace : dev timeout : 2m After applying the kustomize build output, the controller verifies if the rollout completed successfully. If the deployment was successful, the kustomization ready condition is marked as true , if the rollout failed, or if it takes more than the specified timeout to complete, then the kustomization ready condition is set to false . If the deployment becomes healthy on the next execution, then the kustomization is marked as ready. When a Kustomization contains HelmRelease objects, instead of checking the underling Deployments, you can define a health check that waits for the HelmReleases to be reconciled with: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : webapp spec : interval : 15m path : \"./releases/\" prune : true sourceRef : kind : GitRepository name : webapp healthChecks : - apiVersion : helm.toolkit.fluxcd.io/v1beta1 kind : HelmRelease name : frontend namespace : dev - apiVersion : helm.toolkit.fluxcd.io/v1beta1 kind : HelmRelease name : backend namespace : dev timeout : 5m If all the HelmRelease objects are successfully installed or upgraded, then the Kustomization will be marked as ready. Kustomization dependencies \u00b6 When applying a kustomization, you may need to make sure other resources exist before the workloads defined in your kustomization are deployed. For example, a namespace must exist before applying resources to it. With spec.dependsOn you can specify that the execution of a kustomization follows another. When you add dependsOn entries to a kustomization, that kustomization is applied only after all of its dependencies are ready. The readiness state of a kustomization is determined by its last apply status condition. Assuming two kustomizations: * common - contains a namespace and service accounts definitions * backend - contains the workloads to be deployed in that namespace You can instruct the controller to apply the common kustomization before backend : apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : common spec : interval : 5m path : \"./webapp/common/\" prune : true sourceRef : kind : GitRepository name : webapp --- apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend spec : dependsOn : - name : common interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp When combined with health assessment, a kustomization will run after all its dependencies health checks are passing. For example, a service mesh proxy injector should be running before deploying applications inside the mesh. apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : istio namespace : istio-system spec : interval : 5m path : \"./profiles/default/\" sourceRef : kind : GitRepository name : istio healthChecks : - kind : Deployment name : istiod namespace : istio-system timeout : 2m --- apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend spec : dependsOn : - name : common - name : istio namespace : istio-system interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp Note that circular dependencies between kustomizations must be avoided, otherwise the interdependent kustomizations will never be applied on the cluster. Role-based access control \u00b6 By default, a kustomization apply runs under the cluster admin account and can create, modify, delete cluster level objects (namespaces, CRDs, etc) and namespeced objects (deployments, ingresses, etc). For certain kustomizations a cluster admin may wish to control what types of Kubernetes objects can be reconciled and under which namespaces. To restrict a kustomization, one can assign a service account under which the reconciliation is performed. Assuming you want to restrict a group of kustomizations to a single namespace, you can create an account with a role binding that grants access only to that namespace: apiVersion : v1 kind : Namespace metadata : name : webapp --- apiVersion : v1 kind : ServiceAccount metadata : name : webapp-reconciler namespace : webapp --- apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : name : webapp-reconciler namespace : webapp rules : - apiGroups : [ '*' ] resources : [ '*' ] verbs : [ '*' ] --- apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : webapp-reconciler namespace : webapp roleRef : apiGroup : rbac.authorization.k8s.io kind : Role name : webapp-reconciler subjects : - kind : ServiceAccount name : webapp-reconciler namespace : webapp Note that the namespace, RBAC and service account manifests should be placed in a Git source and applied with a kustomization. The kustomizations that are running under that service account should depend-on the one that contains the account. Create a kustomization that prevents altering the cluster state outside of the webapp namespace: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend spec : dependsOn : - name : common serviceAccount : name : webapp-reconciler namespace : webapp interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp When the controller reconciles the frontend-webapp kustomization, it will impersonate the webapp-reconciler account. If the kustomization contains cluster level objects like CRDs or objects belonging to a different namespace, the reconciliation will fail since the account it runs under has no permissions to alter objects outside of the webapp namespace. Secrets decryption \u00b6 In order to store secrets safely in a public or private Git repository, you can use Mozilla SOPS and encrypt your Kubernetes Secrets data with OpenPGP keys. Generate a GPG key without passphrase using gnupg then use sops to encrypt a Kubernetes secret: sops --pgp = FBC7B9E2A4F9289AC0C1D4843D16CEE4A27381B4 \\ --encrypt --encrypted-regex '^(data|stringData)$' --in-place my-secret.yaml Commit and push the encrypted file to Git. Note that you should encrypt only the data section, encrypting the Kubernetes secret metadata, kind or apiVersion is not supported by kustomize-controller. Create a secret in the gitops-system namespace with the OpenPGP private key: gpg --export-secret-keys --armor FBC7B9E2A4F9289AC0C1D4843D16CEE4A27381B4 | kubectl -n gitops-system create secret generic sops-gpg \\ --from-file = sops.asc = /dev/stdin Configure decryption by referring the private key secret: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : my-secrets spec : interval : 5m path : \"./\" sourceRef : kind : GitRepository name : my-secrets decryption : provider : sops secretRef : name : sops-pgp Status \u00b6 When the controller completes a kustomization apply, reports the result in the status sub-resource. A successful reconciliation sets the ready condition to true and updates the revision field: status : conditions : - lastTransitionTime : \"2020-09-17T19:28:48Z\" message : \"Applied revision: master/a1afe267b54f38b46b487f6e938a6fd508278c07\" reason : ReconciliationSucceeded status : \"True\" type : Ready lastAppliedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 lastAttemptedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 You can wait for the kustomize controller to complete a reconciliation with: kubectl wait kustomization/backend --for = condition = ready The controller logs the Kubernetes objects: { \"level\" : \"info\" , \"ts\" : \"2020-09-17T07:27:11.921Z\" , \"logger\" : \"controllers.Kustomization\" , \"msg\" : \"Kustomization applied in 1.436096591s\" , \"kustomization\" : \"default/backend\" , \"output\" : { \"service/backend\" : \"created\" , \"deployment.apps/backend\" : \"created\" , \"horizontalpodautoscaler.autoscaling/backend\" : \"created\" } } A failed reconciliation sets the ready condition to false : status : conditions : - lastTransitionTime : \"2020-09-17T07:26:48Z\" message : \"The Service 'backend' is invalid: spec.type: Unsupported value: 'Ingress'\" reason : ValidationFailed status : \"False\" type : Ready lastAppliedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 lastAttemptedRevision : master/7c500d302e38e7e4a3f327343a8a5c21acaaeb87 Note that the last applied revision is updated only on a successful reconciliation. When a reconciliation fails, the controller logs the error and issues a Kubernetes event: { \"level\" : \"error\" , \"ts\" : \"2020-09-17T07:27:11.921Z\" , \"logger\" : \"controllers.Kustomization\" , \"kustomization\" : \"default/backend\" , \"error\" : \"The Service 'backend' is invalid: spec.type: Unsupported value: 'Ingress'\" }","title":"Kustomization CRD"},{"location":"components/kustomize/kustomization/#kustomization","text":"The Kustomization API defines a pipeline for fetching, decrypting, building, validating and applying Kubernetes manifests.","title":"Kustomization"},{"location":"components/kustomize/kustomization/#specification","text":"A Kustomization object defines the source of Kubernetes manifests by referencing an object managed by source-controller , the path to the kustomization file within that source, and the interval at which the kustomize build output is applied on the cluster. type KustomizationSpec struct { // DependsOn may contain a dependency.CrossNamespaceDependencyReference slice // with references to Kustomization resources that must be ready before this // Kustomization can be reconciled. // +optional DependsOn [] dependency . CrossNamespaceDependencyReference `json:\"dependsOn,omitempty\"` // Decrypt Kubernetes secrets before applying them on the cluster. // +optional Decryption * Decryption `json:\"decryption,omitempty\"` // The interval at which to apply the kustomization. // +required Interval metav1 . Duration `json:\"interval\"` // The KubeConfig for reconciling the Kustomization on a remote cluster. // +optional KubeConfig * KubeConfig `json:\"kubeConfig,omitempty\"` // Path to the directory containing the kustomization file. // +kubebuilder:validation:Pattern=\"^\\\\./\" // +required Path string `json:\"path\"` // Enables garbage collection. // +required Prune bool `json:\"prune\"` // A list of resources to be included in the health assessment. // +optional HealthChecks [] CrossNamespaceObjectReference `json:\"healthChecks,omitempty\"` // The Kubernetes service account used for applying the kustomization. // +optional ServiceAccount * ServiceAccount `json:\"serviceAccount,omitempty\"` // Reference of the source where the kustomization file is. // +required SourceRef CrossNamespaceSourceReference `json:\"sourceRef\"` // This flag tells the controller to suspend subsequent kustomize executions, // it does not apply to already started executions. Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` // TargetNamespace sets or overrides the namespace in the // kustomization.yaml file. // +optional TargetNamespace string `json:\"targetNamespace,omitempty\"` // Timeout for validation, apply and health checking operations. // Defaults to 'Interval' duration. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Validate the Kubernetes objects before applying them on the cluster. // The validation strategy can be 'client' (local dry-run) or 'server' (APIServer dry-run). // +kubebuilder:validation:Enum=client;server // +optional Validation string `json:\"validation,omitempty\"` } The decryption section defines how decryption is handled for Kubernetes manifests: type Decryption struct { // Provider is the name of the decryption engine. // +kubebuilder:validation:Enum=sops // +required Provider string `json:\"provider\"` // The secret name containing the private OpenPGP keys used for decryption. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } KubeConfig references a Kubernetes secret generated by CAPI: type KubeConfig struct { // The secret name containing a 'value' key with the kubeconfig file as the value. // Ref: https://github.com/kubernetes-sigs/cluster-api/blob/release-0.3/util/secret/consts.go#L24 // +required SecretRef corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } The status sub-resource records the result of the last reconciliation: type KustomizationStatus struct { // ObservedGeneration is the last reconciled generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // +optional Conditions [] Condition `json:\"conditions,omitempty\"` // The last successfully applied revision. // The revision format for Git sources is <branch|tag>/<commit-sha>. // +optional LastAppliedRevision string `json:\"lastAppliedRevision,omitempty\"` // LastAttemptedRevision is the revision of the last reconciliation attempt. // +optional LastAttemptedRevision string `json:\"lastAttemptedRevision,omitempty\"` // LastHandledReconcileAt is the last manual reconciliation request (by // annotating the Kustomization) handled by the reconciler. // +optional LastHandledReconcileAt string `json:\"lastHandledReconcileAt,omitempty\"` // The last successfully applied revision metadata. // +optional Snapshot * Snapshot `json:\"snapshot\"` } Status condition types: const ( // ReadyCondition is the name of the condition that // records the readiness status of a Kustomization. ReadyCondition string = \"Ready\" ) Status condition reasons: const ( // ReconciliationSucceededReason represents the fact that the // reconciliation of the Kustomization has succeeded. ReconciliationSucceededReason string = \"ReconciliationSucceeded\" // ReconciliationFailedReason represents the fact that the // reconciliation of the Kustomization has failed. ReconciliationFailedReason string = \"ReconciliationFailed\" // ProgressingReason represents the fact that the // reconciliation of the Kustomization is underway. ProgressingReason string = \"Progressing\" // SuspendedReason represents the fact that the // reconciliation of the Kustomization has been suspended. SuspendedReason string = \"Suspended\" // DependencyNotReady represents the fact that // one of the dependencies of the Kustomization is not ready. DependencyNotReadyReason string = \"DependencyNotReady\" // PruneFailedReason represents the fact that the // pruning of the Kustomization failed. PruneFailedReason string = \"PruneFailed\" // ArtifactFailedReason represents the fact that the // artifact download of the kustomization failed. ArtifactFailedReason string = \"ArtifactFailed\" // BuildFailedReason represents the fact that the // kustomize build of the Kustomization failed. BuildFailedReason string = \"BuildFailed\" // HealthCheckFailedReason represents the fact that // one of the health checks of the Kustomization failed. HealthCheckFailedReason string = \"HealthCheckFailed\" // ValidationFailedReason represents the fact that the // validation of the Kustomization manifests has failed. ValidationFailedReason string = \"ValidationFailed\" )","title":"Specification"},{"location":"components/kustomize/kustomization/#source-reference","text":"The kustomization spec.sourceRef is a reference to an object managed by source-controller . When the source revision changes, it generates a Kubernetes event that triggers a kustomize build and apply. Source supported types: GitRepository Bucket Note that the source should contain the kustomization.yaml and all the Kubernetes manifests and configuration files referenced in the kustomization.yaml. If your Git repository or S3 bucket contains only plain manifests, then a kustomization.yaml will be automatically generated.","title":"Source reference"},{"location":"components/kustomize/kustomization/#generate-kustomizationyaml","text":"If your repository contains plain Kubernetes manifests, the kustomization.yaml file is automatically generated for all the Kubernetes manifests in the spec.path and sub-directories. If the spec.prune is enable, the controller generates a label transformer to enable garbage collection .","title":"Generate kustomization.yaml"},{"location":"components/kustomize/kustomization/#reconciliation","text":"The kustomization spec.interval tells the controller at which interval to fetch the Kubernetes manifest for the source, build the kustomization and apply it on the cluster. The interval time units are s , m and h e.g. interval: 5m , the minimum value should be over 60 seconds. The kustomization execution can be suspended by setting spec.susped to true . The controller can be told to reconcile the kustomization outside of the specified interval by annotating the kustomization object with: const ( // ReconcileAtAnnotation is the annotation used for triggering a // reconciliation outside of the defined schedule. ReconcileAtAnnotation string = \"fluxcd.io/reconcileAt\" ) On-demand execution example: kubectl annotate --overwrite kustomization/podinfo fluxcd.io/reconcileAt = \" $( date +%s ) \"","title":"Reconciliation"},{"location":"components/kustomize/kustomization/#garbage-collection","text":"To enable garbage collection, set spec.prune to true . Garbage collection means that the Kubernetes objects that were previously applied on the cluster but are missing from the current source revision, are removed from cluster automatically. Garbage collection is also performed when a Kustomization object is deleted, triggering a removal of all Kubernetes objects previously applied on the cluster.","title":"Garbage collection"},{"location":"components/kustomize/kustomization/#health-assessment","text":"A kustomization can contain a series of health checks used to determine the rollout status of the deployed workloads and the ready status of custom resources. A health check entry can reference one of the following types: Kubernetes builtin kinds: Deployment, DaemonSet, StatefulSet, PersistentVolumeClaim, Pod, PodDisruptionBudget, Job, CronJob, Service, Secret, ConfigMap, CustomResourceDefinition Toolkit kinds: HelmRelease, HelmRepository, GitRepository, etc Custom resources that are compatible with kstatus Assuming the kustomization source contains a Kubernetes Deployment named backend , a health check can be defined as follows: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend spec : interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp healthChecks : - apiVersion : apps/v1 kind : Deployment name : backend namespace : dev timeout : 2m After applying the kustomize build output, the controller verifies if the rollout completed successfully. If the deployment was successful, the kustomization ready condition is marked as true , if the rollout failed, or if it takes more than the specified timeout to complete, then the kustomization ready condition is set to false . If the deployment becomes healthy on the next execution, then the kustomization is marked as ready. When a Kustomization contains HelmRelease objects, instead of checking the underling Deployments, you can define a health check that waits for the HelmReleases to be reconciled with: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : webapp spec : interval : 15m path : \"./releases/\" prune : true sourceRef : kind : GitRepository name : webapp healthChecks : - apiVersion : helm.toolkit.fluxcd.io/v1beta1 kind : HelmRelease name : frontend namespace : dev - apiVersion : helm.toolkit.fluxcd.io/v1beta1 kind : HelmRelease name : backend namespace : dev timeout : 5m If all the HelmRelease objects are successfully installed or upgraded, then the Kustomization will be marked as ready.","title":"Health assessment"},{"location":"components/kustomize/kustomization/#kustomization-dependencies","text":"When applying a kustomization, you may need to make sure other resources exist before the workloads defined in your kustomization are deployed. For example, a namespace must exist before applying resources to it. With spec.dependsOn you can specify that the execution of a kustomization follows another. When you add dependsOn entries to a kustomization, that kustomization is applied only after all of its dependencies are ready. The readiness state of a kustomization is determined by its last apply status condition. Assuming two kustomizations: * common - contains a namespace and service accounts definitions * backend - contains the workloads to be deployed in that namespace You can instruct the controller to apply the common kustomization before backend : apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : common spec : interval : 5m path : \"./webapp/common/\" prune : true sourceRef : kind : GitRepository name : webapp --- apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend spec : dependsOn : - name : common interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp When combined with health assessment, a kustomization will run after all its dependencies health checks are passing. For example, a service mesh proxy injector should be running before deploying applications inside the mesh. apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : istio namespace : istio-system spec : interval : 5m path : \"./profiles/default/\" sourceRef : kind : GitRepository name : istio healthChecks : - kind : Deployment name : istiod namespace : istio-system timeout : 2m --- apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend spec : dependsOn : - name : common - name : istio namespace : istio-system interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp Note that circular dependencies between kustomizations must be avoided, otherwise the interdependent kustomizations will never be applied on the cluster.","title":"Kustomization dependencies"},{"location":"components/kustomize/kustomization/#role-based-access-control","text":"By default, a kustomization apply runs under the cluster admin account and can create, modify, delete cluster level objects (namespaces, CRDs, etc) and namespeced objects (deployments, ingresses, etc). For certain kustomizations a cluster admin may wish to control what types of Kubernetes objects can be reconciled and under which namespaces. To restrict a kustomization, one can assign a service account under which the reconciliation is performed. Assuming you want to restrict a group of kustomizations to a single namespace, you can create an account with a role binding that grants access only to that namespace: apiVersion : v1 kind : Namespace metadata : name : webapp --- apiVersion : v1 kind : ServiceAccount metadata : name : webapp-reconciler namespace : webapp --- apiVersion : rbac.authorization.k8s.io/v1 kind : Role metadata : name : webapp-reconciler namespace : webapp rules : - apiGroups : [ '*' ] resources : [ '*' ] verbs : [ '*' ] --- apiVersion : rbac.authorization.k8s.io/v1 kind : RoleBinding metadata : name : webapp-reconciler namespace : webapp roleRef : apiGroup : rbac.authorization.k8s.io kind : Role name : webapp-reconciler subjects : - kind : ServiceAccount name : webapp-reconciler namespace : webapp Note that the namespace, RBAC and service account manifests should be placed in a Git source and applied with a kustomization. The kustomizations that are running under that service account should depend-on the one that contains the account. Create a kustomization that prevents altering the cluster state outside of the webapp namespace: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : backend spec : dependsOn : - name : common serviceAccount : name : webapp-reconciler namespace : webapp interval : 5m path : \"./webapp/backend/\" prune : true sourceRef : kind : GitRepository name : webapp When the controller reconciles the frontend-webapp kustomization, it will impersonate the webapp-reconciler account. If the kustomization contains cluster level objects like CRDs or objects belonging to a different namespace, the reconciliation will fail since the account it runs under has no permissions to alter objects outside of the webapp namespace.","title":"Role-based access control"},{"location":"components/kustomize/kustomization/#secrets-decryption","text":"In order to store secrets safely in a public or private Git repository, you can use Mozilla SOPS and encrypt your Kubernetes Secrets data with OpenPGP keys. Generate a GPG key without passphrase using gnupg then use sops to encrypt a Kubernetes secret: sops --pgp = FBC7B9E2A4F9289AC0C1D4843D16CEE4A27381B4 \\ --encrypt --encrypted-regex '^(data|stringData)$' --in-place my-secret.yaml Commit and push the encrypted file to Git. Note that you should encrypt only the data section, encrypting the Kubernetes secret metadata, kind or apiVersion is not supported by kustomize-controller. Create a secret in the gitops-system namespace with the OpenPGP private key: gpg --export-secret-keys --armor FBC7B9E2A4F9289AC0C1D4843D16CEE4A27381B4 | kubectl -n gitops-system create secret generic sops-gpg \\ --from-file = sops.asc = /dev/stdin Configure decryption by referring the private key secret: apiVersion : kustomize.toolkit.fluxcd.io/v1beta1 kind : Kustomization metadata : name : my-secrets spec : interval : 5m path : \"./\" sourceRef : kind : GitRepository name : my-secrets decryption : provider : sops secretRef : name : sops-pgp","title":"Secrets decryption"},{"location":"components/kustomize/kustomization/#status","text":"When the controller completes a kustomization apply, reports the result in the status sub-resource. A successful reconciliation sets the ready condition to true and updates the revision field: status : conditions : - lastTransitionTime : \"2020-09-17T19:28:48Z\" message : \"Applied revision: master/a1afe267b54f38b46b487f6e938a6fd508278c07\" reason : ReconciliationSucceeded status : \"True\" type : Ready lastAppliedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 lastAttemptedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 You can wait for the kustomize controller to complete a reconciliation with: kubectl wait kustomization/backend --for = condition = ready The controller logs the Kubernetes objects: { \"level\" : \"info\" , \"ts\" : \"2020-09-17T07:27:11.921Z\" , \"logger\" : \"controllers.Kustomization\" , \"msg\" : \"Kustomization applied in 1.436096591s\" , \"kustomization\" : \"default/backend\" , \"output\" : { \"service/backend\" : \"created\" , \"deployment.apps/backend\" : \"created\" , \"horizontalpodautoscaler.autoscaling/backend\" : \"created\" } } A failed reconciliation sets the ready condition to false : status : conditions : - lastTransitionTime : \"2020-09-17T07:26:48Z\" message : \"The Service 'backend' is invalid: spec.type: Unsupported value: 'Ingress'\" reason : ValidationFailed status : \"False\" type : Ready lastAppliedRevision : master/a1afe267b54f38b46b487f6e938a6fd508278c07 lastAttemptedRevision : master/7c500d302e38e7e4a3f327343a8a5c21acaaeb87 Note that the last applied revision is updated only on a successful reconciliation. When a reconciliation fails, the controller logs the error and issues a Kubernetes event: { \"level\" : \"error\" , \"ts\" : \"2020-09-17T07:27:11.921Z\" , \"logger\" : \"controllers.Kustomization\" , \"kustomization\" : \"default/backend\" , \"error\" : \"The Service 'backend' is invalid: spec.type: Unsupported value: 'Ingress'\" }","title":"Status"},{"location":"components/notification/alert/","text":"Alert \u00b6 The Alert API defines how events are filtered by severity and involved object, and what provider to use for dispatching. Specification \u00b6 Spec: type AlertSpec struct { // Send events using this provider // +required ProviderRef corev1 . LocalObjectReference `json:\"providerRef\"` // Filter events based on severity, defaults to ('info'). // +kubebuilder:validation:Enum=info;error // +optional EventSeverity string `json:\"eventSeverity,omitempty\"` // Filter events based on the involved objects // +required EventSources [] CrossNamespaceObjectReference `json:\"eventSources\"` // This flag tells the controller to suspend subsequent events dispatching. // Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` } Status: // ProviderStatus defines the observed state of Provider type ProviderStatus struct { // +optional Conditions [] Condition `json:\"conditions,omitempty\"` } Status condition types: const ( // ReadyCondition represents the fact that a given object has passed // validation and was acknowledge by the controller. ReadyCondition string = \"Ready\" ) Example \u00b6 apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Alert metadata : name : webapp namespace : gitops-system spec : providerRef : name : on-call-slack eventSeverity : info eventSources : - kind : GitRepository name : webapp - kind : Bucket name : secrets - kind : Kustomization name : webapp-backend - kind : Kustomization name : webapp-frontend The event severity can be set to info or error . To target all resources of a particular kind in a namespace, you can use the * wildcard: apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Alert metadata : name : all-kustomizations namespace : gitops-system spec : providerRef : name : dev-msteams eventSeverity : error eventSources : - kind : Kustomization namespace : gitops-system name : '*' suspend : false If you don't specify an event source namespace, the alert namespace will be used.","title":"Alert CRD"},{"location":"components/notification/alert/#alert","text":"The Alert API defines how events are filtered by severity and involved object, and what provider to use for dispatching.","title":"Alert"},{"location":"components/notification/alert/#specification","text":"Spec: type AlertSpec struct { // Send events using this provider // +required ProviderRef corev1 . LocalObjectReference `json:\"providerRef\"` // Filter events based on severity, defaults to ('info'). // +kubebuilder:validation:Enum=info;error // +optional EventSeverity string `json:\"eventSeverity,omitempty\"` // Filter events based on the involved objects // +required EventSources [] CrossNamespaceObjectReference `json:\"eventSources\"` // This flag tells the controller to suspend subsequent events dispatching. // Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` } Status: // ProviderStatus defines the observed state of Provider type ProviderStatus struct { // +optional Conditions [] Condition `json:\"conditions,omitempty\"` } Status condition types: const ( // ReadyCondition represents the fact that a given object has passed // validation and was acknowledge by the controller. ReadyCondition string = \"Ready\" )","title":"Specification"},{"location":"components/notification/alert/#example","text":"apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Alert metadata : name : webapp namespace : gitops-system spec : providerRef : name : on-call-slack eventSeverity : info eventSources : - kind : GitRepository name : webapp - kind : Bucket name : secrets - kind : Kustomization name : webapp-backend - kind : Kustomization name : webapp-frontend The event severity can be set to info or error . To target all resources of a particular kind in a namespace, you can use the * wildcard: apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Alert metadata : name : all-kustomizations namespace : gitops-system spec : providerRef : name : dev-msteams eventSeverity : error eventSources : - kind : Kustomization namespace : gitops-system name : '*' suspend : false If you don't specify an event source namespace, the alert namespace will be used.","title":"Example"},{"location":"components/notification/api/","text":"Kustomize API reference Packages: notification.toolkit.fluxcd.io/v1beta1 notification.toolkit.fluxcd.io/v1beta1 Package v1beta1 contains API Schema definitions for the notification v1beta1 API group Resource Types: Alert Provider Receiver Alert Alert is the Schema for the alerts API Field Description apiVersion string notification.toolkit.fluxcd.io/v1beta1 kind string Alert metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec AlertSpec providerRef Kubernetes core/v1.LocalObjectReference Send events using this provider eventSeverity string (Optional) Filter events based on severity, defaults to (\u2018info\u2019). If set to \u2018info\u2019 no events will be filtered. eventSources []CrossNamespaceObjectReference Filter events based on the involved objects suspend bool (Optional) This flag tells the controller to suspend subsequent events dispatching. Defaults to false. status AlertStatus Provider Provider is the Schema for the providers API Field Description apiVersion string notification.toolkit.fluxcd.io/v1beta1 kind string Provider metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec ProviderSpec type string Type of provider channel string (Optional) Alert channel for this provider username string (Optional) Bot username for this provider address string (Optional) HTTP(S) webhook address of this provider secretRef Kubernetes core/v1.LocalObjectReference (Optional) Secret reference containing the provider webhook URL status ProviderStatus Receiver Receiver is the Schema for the receivers API Field Description apiVersion string notification.toolkit.fluxcd.io/v1beta1 kind string Receiver metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec ReceiverSpec type string Type of webhook sender, used to determine the validation procedure and payload deserialization. events []string (Optional) A list of events to handle, e.g. \u2018push\u2019 for GitHub or \u2018Push Hook\u2019 for GitLab. resources []CrossNamespaceObjectReference A list of resources to be notified about changes. secretRef Kubernetes core/v1.LocalObjectReference Secret reference containing the token used to validate the payload authenticity suspend bool (Optional) This flag tells the controller to suspend subsequent events handling. Defaults to false. status ReceiverStatus AlertSpec ( Appears on: Alert ) AlertSpec defines an alerting rule for events involving a list of objects Field Description providerRef Kubernetes core/v1.LocalObjectReference Send events using this provider eventSeverity string (Optional) Filter events based on severity, defaults to (\u2018info\u2019). If set to \u2018info\u2019 no events will be filtered. eventSources []CrossNamespaceObjectReference Filter events based on the involved objects suspend bool (Optional) This flag tells the controller to suspend subsequent events dispatching. Defaults to false. AlertStatus ( Appears on: Alert ) AlertStatus defines the observed state of Alert Field Description conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) CrossNamespaceObjectReference ( Appears on: AlertSpec , ReceiverSpec ) CrossNamespaceObjectReference contains enough information to let you locate the typed referenced object at cluster level Field Description apiVersion string (Optional) API version of the referent kind string Kind of the referent name string Name of the referent namespace string (Optional) Namespace of the referent ProviderSpec ( Appears on: Provider ) ProviderSpec defines the desired state of Provider Field Description type string Type of provider channel string (Optional) Alert channel for this provider username string (Optional) Bot username for this provider address string (Optional) HTTP(S) webhook address of this provider secretRef Kubernetes core/v1.LocalObjectReference (Optional) Secret reference containing the provider webhook URL ProviderStatus ( Appears on: Provider ) ProviderStatus defines the observed state of Provider Field Description conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) ReceiverSpec ( Appears on: Receiver ) ReceiverSpec defines the desired state of Receiver Field Description type string Type of webhook sender, used to determine the validation procedure and payload deserialization. events []string (Optional) A list of events to handle, e.g. \u2018push\u2019 for GitHub or \u2018Push Hook\u2019 for GitLab. resources []CrossNamespaceObjectReference A list of resources to be notified about changes. secretRef Kubernetes core/v1.LocalObjectReference Secret reference containing the token used to validate the payload authenticity suspend bool (Optional) This flag tells the controller to suspend subsequent events handling. Defaults to false. ReceiverStatus ( Appears on: Receiver ) ReceiverStatus defines the observed state of Receiver Field Description conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) url string (Optional) Generated webhook URL in the format of \u2018/hook/sha256sum(token+name+namespace)\u2019. This page was automatically generated with gen-crd-api-reference-docs","title":"Notification API Reference"},{"location":"components/notification/controller/","text":"Notification Controller \u00b6 The Notification Controller is a Kubernetes operator, specialized in handling inbound and outbound events. The controller handles events coming from external systems (GitHub, GitLab, Bitbucket, Harbor, Jenkins, etc) and notifies the GitOps toolkit controllers about source changes. The controller handles events emitted by the GitOps toolkit controllers (source, kustomize, helm) and dispatches them to external systems (Slack, Microsoft Teams, Discord, Rocker) based on event severity and involved objects. Links: Source code fluxcd/notification-controller Specification docs","title":"Overview"},{"location":"components/notification/controller/#notification-controller","text":"The Notification Controller is a Kubernetes operator, specialized in handling inbound and outbound events. The controller handles events coming from external systems (GitHub, GitLab, Bitbucket, Harbor, Jenkins, etc) and notifies the GitOps toolkit controllers about source changes. The controller handles events emitted by the GitOps toolkit controllers (source, kustomize, helm) and dispatches them to external systems (Slack, Microsoft Teams, Discord, Rocker) based on event severity and involved objects. Links: Source code fluxcd/notification-controller Specification docs","title":"Notification Controller"},{"location":"components/notification/event/","text":"Event \u00b6 The Event API defines what information a report of an event issued by a controller should contain. Specification \u00b6 Spec: type Event struct { // The object that this event is about. // +required InvolvedObject corev1 . ObjectReference `json:\"involvedObject\"` // Severity type of this event (info, error) // +required Severity string `json:\"severity\"` // The time at which this event was recorded. // +required Timestamp metav1 . Time `json:\"timestamp\"` // A human-readable description of this event. // Maximum length 39,000 characters // +required Message string `json:\"message\"` // A machine understandable string that gives the reason // for the transition into the object's current status. // +required Reason string `json:\"reason\"` // Metadata of this event, e.g. apply change set. // +optional Metadata map [ string ] string `json:\"metadata,omitempty\"` // Name of the controller that emitted this event, e.g. `source-controller`. // +required ReportingController string `json:\"reportingController\"` // ID of the controller instance, e.g. `source-controller-xyzf`. // +optional ReportingInstance string `json:\"reportingInstance,omitempty\"` } Event severity: const ( EventSeverityInfo string = \"info\" EventSeverityError string = \"error\" ) Controller implementations can use the fluxcd/pkg/recorder package to push events to notification-controller API.","title":"Event"},{"location":"components/notification/event/#event","text":"The Event API defines what information a report of an event issued by a controller should contain.","title":"Event"},{"location":"components/notification/event/#specification","text":"Spec: type Event struct { // The object that this event is about. // +required InvolvedObject corev1 . ObjectReference `json:\"involvedObject\"` // Severity type of this event (info, error) // +required Severity string `json:\"severity\"` // The time at which this event was recorded. // +required Timestamp metav1 . Time `json:\"timestamp\"` // A human-readable description of this event. // Maximum length 39,000 characters // +required Message string `json:\"message\"` // A machine understandable string that gives the reason // for the transition into the object's current status. // +required Reason string `json:\"reason\"` // Metadata of this event, e.g. apply change set. // +optional Metadata map [ string ] string `json:\"metadata,omitempty\"` // Name of the controller that emitted this event, e.g. `source-controller`. // +required ReportingController string `json:\"reportingController\"` // ID of the controller instance, e.g. `source-controller-xyzf`. // +optional ReportingInstance string `json:\"reportingInstance,omitempty\"` } Event severity: const ( EventSeverityInfo string = \"info\" EventSeverityError string = \"error\" ) Controller implementations can use the fluxcd/pkg/recorder package to push events to notification-controller API.","title":"Specification"},{"location":"components/notification/provider/","text":"Provider \u00b6 The Provider API defines how events are encoded and the webhook address where they are dispatched. Specification \u00b6 Spec: type ProviderSpec struct { // Type of provider // +kubebuilder:validation:Enum=slack;discord;msteams;rocket;generic;github;gitlab // +required Type string `json:\"type\"` // Alert channel for this provider // +optional Channel string `json:\"channel,omitempty\"` // Bot username for this provider // +optional Username string `json:\"username,omitempty\"` // HTTP(S) webhook address of this provider // +optional Address string `json:\"address,omitempty\"` // Secret reference containing the provider webhook URL // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } Notification providers: Slack Discord Microsoft Teams Rocket Generic webhook Git commit status providers: GitHub GitLab Status: // ProviderStatus defines the observed state of Provider type ProviderStatus struct { // +optional Conditions [] Condition `json:\"conditions,omitempty\"` } Status condition types: const ( // ReadyCondition represents the fact that a given object has passed // validation and was acknowledge by the controller. ReadyCondition string = \"Ready\" ) Example \u00b6 Notifications \u00b6 apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Provider metadata : name : slack namespace : gitops-system spec : type : slack channel : general # webhook address (ignored if secretRef is specified) address : https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK # secret containing the webhook address (optional) secretRef : name : webhook-url Webhook URL secret: kubectl -n gitops-system create secret generic webhook-url \\ --from-literal = address = https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK Note that the secret must contain an address field. The provider type can be: slack , msteams , rocket , discord , github or generic . When type generic is specified, the notification controller will post the incoming event in JSON format to the webhook address. Git commit status \u00b6 The GitHub/GitLab provider is a special kind of notification provider that based on the state of a Kustomization resource, will update the commit status for the currently reconciled commit id. apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Provider metadata : name : podinfo namespace : gitops-system spec : # provider type can be github or gitlab type : github address : https://github.com/stefanprodan/podinfo secretRef : name : git-api-token The secret referenced in the provider is expected to contain a personal access token to authenticate with the GitHub or GitLab API. kubectl -n gitops-system create secret generic git-api-token \\ --from-literal = token = YOUR-TOKEN","title":"Provider CRD"},{"location":"components/notification/provider/#provider","text":"The Provider API defines how events are encoded and the webhook address where they are dispatched.","title":"Provider"},{"location":"components/notification/provider/#specification","text":"Spec: type ProviderSpec struct { // Type of provider // +kubebuilder:validation:Enum=slack;discord;msteams;rocket;generic;github;gitlab // +required Type string `json:\"type\"` // Alert channel for this provider // +optional Channel string `json:\"channel,omitempty\"` // Bot username for this provider // +optional Username string `json:\"username,omitempty\"` // HTTP(S) webhook address of this provider // +optional Address string `json:\"address,omitempty\"` // Secret reference containing the provider webhook URL // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` } Notification providers: Slack Discord Microsoft Teams Rocket Generic webhook Git commit status providers: GitHub GitLab Status: // ProviderStatus defines the observed state of Provider type ProviderStatus struct { // +optional Conditions [] Condition `json:\"conditions,omitempty\"` } Status condition types: const ( // ReadyCondition represents the fact that a given object has passed // validation and was acknowledge by the controller. ReadyCondition string = \"Ready\" )","title":"Specification"},{"location":"components/notification/provider/#example","text":"","title":"Example"},{"location":"components/notification/provider/#notifications","text":"apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Provider metadata : name : slack namespace : gitops-system spec : type : slack channel : general # webhook address (ignored if secretRef is specified) address : https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK # secret containing the webhook address (optional) secretRef : name : webhook-url Webhook URL secret: kubectl -n gitops-system create secret generic webhook-url \\ --from-literal = address = https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK Note that the secret must contain an address field. The provider type can be: slack , msteams , rocket , discord , github or generic . When type generic is specified, the notification controller will post the incoming event in JSON format to the webhook address.","title":"Notifications"},{"location":"components/notification/provider/#git-commit-status","text":"The GitHub/GitLab provider is a special kind of notification provider that based on the state of a Kustomization resource, will update the commit status for the currently reconciled commit id. apiVersion : notification.toolkit.fluxcd.io/v1beta1 kind : Provider metadata : name : podinfo namespace : gitops-system spec : # provider type can be github or gitlab type : github address : https://github.com/stefanprodan/podinfo secretRef : name : git-api-token The secret referenced in the provider is expected to contain a personal access token to authenticate with the GitHub or GitLab API. kubectl -n gitops-system create secret generic git-api-token \\ --from-literal = token = YOUR-TOKEN","title":"Git commit status"},{"location":"components/notification/receiver/","text":"Receiver \u00b6 The Receiver API defines a webhook receiver that triggers reconciliation for a group of resources. Specification \u00b6 type ReceiverSpec struct { // Type of webhook sender, used to determine // the validation procedure and payload deserialization. // +kubebuilder:validation:Enum=generic;github;gitlab;harbor // +required Type string `json:\"type\"` // A list of events to handle, // e.g. 'push' for GitHub or 'Push Hook' for GitLab. // +optional Events [] string `json:\"events\"` // A list of resources to be notified about changes. // +required Resources [] CrossNamespaceObjectReference `json:\"resources\"` // Secret reference containing the token used // to validate the payload authenticity // +required SecretRef corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // This flag tells the controller to suspend subsequent events handling. // Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` } Receiver types: const ( GenericReceiver string = \"generic\" GitHubReceiver string = \"github\" GitLabReceiver string = \"gitlab\" BitbucketReceiver string = \"bitbucket\" HarborReceiver string = \"harbor\" ) Status \u00b6 type ReceiverStatus struct { // Generated webhook URL in the format // of '/hook/sha256sum(token+name+namespace)'. // +required URL string `json:\"url\"` } Example \u00b6 Generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n gitops-system create secret generic webhook-token \\ --from-literal = token = $TOKEN GitHub receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : github-receiver namespace : gitops-system spec : type : github events : - \"ping\" - \"push\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp - kind : HelmRepository name : webapp Note that you have to set the generated token as the GitHub webhook secret value. The controller uses the X-Hub-Signature HTTP header to verify that the request is legitimate. GitLab receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : gitlab-receiver namespace : gitops-system spec : type : gitlab events : - \"Push Hook\" - \"Tag Push Hook\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp-frontend - kind : GitRepository name : webapp-backend Note that you have to configure the GitLab webhook with the generated token. The controller uses the X-Gitlab-Token HTTP header to verify that the request is legitimate. Bitbucket server receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : bitbucket-receiver namespace : gitops-system spec : type : bitbucket events : - \"repo:refs_changed\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp Note that you have to set the generated token as the Bitbucket server webhook secret value. The controller uses the X-Hub-Signature HTTP header to verify that the request is legitimate. Harbor receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : harbor-receiver namespace : gitops-system spec : type : harbor secretRef : name : webhook-token resources : - kind : HelmRepository name : webapp Note that you have to set the generated token as the Harbor webhook authentication header. The controller uses the Authentication HTTP header to verify that the request is legitimate. Generic receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : generic-receiver namespace : gitops-system spec : type : generic secretRef : name : webhook-token resources : - kind : GitRepository name : webapp - kind : HelmRepository name : webapp - kind : Bucket name : secrets When the receiver type is set to generic , the controller will not perform token validation nor event filtering.","title":"Receiver CRD"},{"location":"components/notification/receiver/#receiver","text":"The Receiver API defines a webhook receiver that triggers reconciliation for a group of resources.","title":"Receiver"},{"location":"components/notification/receiver/#specification","text":"type ReceiverSpec struct { // Type of webhook sender, used to determine // the validation procedure and payload deserialization. // +kubebuilder:validation:Enum=generic;github;gitlab;harbor // +required Type string `json:\"type\"` // A list of events to handle, // e.g. 'push' for GitHub or 'Push Hook' for GitLab. // +optional Events [] string `json:\"events\"` // A list of resources to be notified about changes. // +required Resources [] CrossNamespaceObjectReference `json:\"resources\"` // Secret reference containing the token used // to validate the payload authenticity // +required SecretRef corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // This flag tells the controller to suspend subsequent events handling. // Defaults to false. // +optional Suspend bool `json:\"suspend,omitempty\"` } Receiver types: const ( GenericReceiver string = \"generic\" GitHubReceiver string = \"github\" GitLabReceiver string = \"gitlab\" BitbucketReceiver string = \"bitbucket\" HarborReceiver string = \"harbor\" )","title":"Specification"},{"location":"components/notification/receiver/#status","text":"type ReceiverStatus struct { // Generated webhook URL in the format // of '/hook/sha256sum(token+name+namespace)'. // +required URL string `json:\"url\"` }","title":"Status"},{"location":"components/notification/receiver/#example","text":"Generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n gitops-system create secret generic webhook-token \\ --from-literal = token = $TOKEN GitHub receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : github-receiver namespace : gitops-system spec : type : github events : - \"ping\" - \"push\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp - kind : HelmRepository name : webapp Note that you have to set the generated token as the GitHub webhook secret value. The controller uses the X-Hub-Signature HTTP header to verify that the request is legitimate. GitLab receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : gitlab-receiver namespace : gitops-system spec : type : gitlab events : - \"Push Hook\" - \"Tag Push Hook\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp-frontend - kind : GitRepository name : webapp-backend Note that you have to configure the GitLab webhook with the generated token. The controller uses the X-Gitlab-Token HTTP header to verify that the request is legitimate. Bitbucket server receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : bitbucket-receiver namespace : gitops-system spec : type : bitbucket events : - \"repo:refs_changed\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp Note that you have to set the generated token as the Bitbucket server webhook secret value. The controller uses the X-Hub-Signature HTTP header to verify that the request is legitimate. Harbor receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : harbor-receiver namespace : gitops-system spec : type : harbor secretRef : name : webhook-token resources : - kind : HelmRepository name : webapp Note that you have to set the generated token as the Harbor webhook authentication header. The controller uses the Authentication HTTP header to verify that the request is legitimate. Generic receiver: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : generic-receiver namespace : gitops-system spec : type : generic secretRef : name : webhook-token resources : - kind : GitRepository name : webapp - kind : HelmRepository name : webapp - kind : Bucket name : secrets When the receiver type is set to generic , the controller will not perform token validation nor event filtering.","title":"Example"},{"location":"components/source/api/","text":"Source API reference Packages: source.toolkit.fluxcd.io/v1beta1 source.toolkit.fluxcd.io/v1beta1 Package v1beta1 contains API Schema definitions for the source v1beta1 API group Resource Types: Bucket GitRepository HelmChart HelmRepository Bucket Bucket is the Schema for the buckets API Field Description apiVersion string source.toolkit.fluxcd.io/v1beta1 kind string Bucket metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec BucketSpec provider string (Optional) The S3 compatible storage provider name, default (\u2018generic\u2019). bucketName string The bucket name. endpoint string The bucket endpoint address. insecure bool (Optional) Insecure allows connecting to a non-TLS S3 HTTP endpoint. region string (Optional) The bucket region. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The name of the secret containing authentication credentials for the Bucket. interval Kubernetes meta/v1.Duration The interval at which to check for bucket updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout for download operations, default (\u201820s\u2019). ignore string (Optional) Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). status BucketStatus GitRepository GitRepository is the Schema for the gitrepositories API Field Description apiVersion string source.toolkit.fluxcd.io/v1beta1 kind string GitRepository metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec GitRepositorySpec url string The repository URL, can be a HTTP or SSH address. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The secret name containing the Git credentials. For HTTPS repositories the secret must contain username and password fields. For SSH repositories the secret must contain identity, identity.pub and known_hosts fields. interval Kubernetes meta/v1.Duration The interval at which to check for repository updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout for remote git operations like cloning, default to 20s. ref GitRepositoryRef (Optional) The git reference to checkout and monitor for changes, defaults to master branch. verify GitRepositoryVerification (Optional) Verify OpenPGP signature for the commit that HEAD points to. ignore string (Optional) Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are. status GitRepositoryStatus HelmChart HelmChart is the Schema for the helmcharts API Field Description apiVersion string source.toolkit.fluxcd.io/v1beta1 kind string HelmChart metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec HelmChartSpec chart string The name or path the Helm chart is available at in the SourceRef. version string (Optional) The chart version semver expression, ignored for charts from GitRepository and Bucket sources. Defaults to latest when omitted. sourceRef LocalHelmChartSourceReference The reference to the Source the chart is available at. interval Kubernetes meta/v1.Duration The interval at which to check the Source for updates. valuesFile string (Optional) Alternative values file to use as the default chart values, expected to be a relative path in the SourceRef. Ignored when omitted. status HelmChartStatus HelmRepository HelmRepository is the Schema for the helmrepositories API Field Description apiVersion string source.toolkit.fluxcd.io/v1beta1 kind string HelmRepository metadata Kubernetes meta/v1.ObjectMeta Refer to the Kubernetes API documentation for the fields of the metadata field. spec HelmRepositorySpec url string The Helm repository URL, a valid URL contains at least a protocol and host. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The name of the secret containing authentication credentials for the Helm repository. For HTTP/S basic auth the secret must contain username and password fields. For TLS the secret must contain caFile, keyFile and caCert fields. interval Kubernetes meta/v1.Duration The interval at which to check the upstream for updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout of index downloading, defaults to 60s. status HelmRepositoryStatus Artifact ( Appears on: BucketStatus , GitRepositoryStatus , HelmChartStatus , HelmRepositoryStatus ) Artifact represents the output of a source synchronisation. Field Description path string Path is the relative file path of this artifact. url string URL is the HTTP address of this artifact. revision string (Optional) Revision is a human readable identifier traceable in the origin source system. It can be a Git commit sha, Git tag, a Helm index timestamp, a Helm chart version, etc. checksum string (Optional) Checksum is the SHA1 checksum of the artifact. lastUpdateTime Kubernetes meta/v1.Time LastUpdateTime is the timestamp corresponding to the last update of this artifact. BucketSpec ( Appears on: Bucket ) BucketSpec defines the desired state of an S3 compatible bucket Field Description provider string (Optional) The S3 compatible storage provider name, default (\u2018generic\u2019). bucketName string The bucket name. endpoint string The bucket endpoint address. insecure bool (Optional) Insecure allows connecting to a non-TLS S3 HTTP endpoint. region string (Optional) The bucket region. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The name of the secret containing authentication credentials for the Bucket. interval Kubernetes meta/v1.Duration The interval at which to check for bucket updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout for download operations, default (\u201820s\u2019). ignore string (Optional) Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). BucketStatus ( Appears on: Bucket ) BucketStatus defines the observed state of a bucket Field Description observedGeneration int64 (Optional) ObservedGeneration is the last observed generation. conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) Conditions holds the conditions for the Bucket. url string (Optional) URL is the download link for the artifact output of the last Bucket sync. artifact Artifact (Optional) Artifact represents the output of the last successful Bucket sync. GitRepositoryRef ( Appears on: GitRepositorySpec ) GitRepositoryRef defines the git ref used for pull and checkout operations. Field Description branch string (Optional) The git branch to checkout, defaults to master. tag string (Optional) The git tag to checkout, takes precedence over branch. semver string (Optional) The git tag semver expression, takes precedence over tag. commit string (Optional) The git commit sha to checkout, if specified tag filters will be ignored. GitRepositorySpec ( Appears on: GitRepository ) GitRepositorySpec defines the desired state of a Git repository. Field Description url string The repository URL, can be a HTTP or SSH address. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The secret name containing the Git credentials. For HTTPS repositories the secret must contain username and password fields. For SSH repositories the secret must contain identity, identity.pub and known_hosts fields. interval Kubernetes meta/v1.Duration The interval at which to check for repository updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout for remote git operations like cloning, default to 20s. ref GitRepositoryRef (Optional) The git reference to checkout and monitor for changes, defaults to master branch. verify GitRepositoryVerification (Optional) Verify OpenPGP signature for the commit that HEAD points to. ignore string (Optional) Ignore overrides the set of excluded patterns in the .sourceignore format (which is the same as .gitignore). If not provided, a default will be used, consult the documentation for your version to find out what those are. GitRepositoryStatus ( Appears on: GitRepository ) GitRepositoryStatus defines the observed state of a Git repository. Field Description observedGeneration int64 (Optional) ObservedGeneration is the last observed generation. conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) Conditions holds the conditions for the GitRepository. url string (Optional) URL is the download link for the artifact output of the last repository sync. artifact Artifact (Optional) Artifact represents the output of the last successful repository sync. GitRepositoryVerification ( Appears on: GitRepositorySpec ) GitRepositoryVerification defines the OpenPGP signature verification process. Field Description mode string Mode describes what git object should be verified, currently (\u2018head\u2019). secretRef Kubernetes core/v1.LocalObjectReference The secret name containing the public keys of all trusted git authors. HelmChartSpec ( Appears on: HelmChart ) HelmChartSpec defines the desired state of a Helm chart. Field Description chart string The name or path the Helm chart is available at in the SourceRef. version string (Optional) The chart version semver expression, ignored for charts from GitRepository and Bucket sources. Defaults to latest when omitted. sourceRef LocalHelmChartSourceReference The reference to the Source the chart is available at. interval Kubernetes meta/v1.Duration The interval at which to check the Source for updates. valuesFile string (Optional) Alternative values file to use as the default chart values, expected to be a relative path in the SourceRef. Ignored when omitted. HelmChartStatus ( Appears on: HelmChart ) HelmChartStatus defines the observed state of the HelmChart. Field Description observedGeneration int64 (Optional) ObservedGeneration is the last observed generation. conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) Conditions holds the conditions for the HelmChart. url string (Optional) URL is the download link for the last chart pulled. artifact Artifact (Optional) Artifact represents the output of the last successful chart sync. HelmRepositorySpec ( Appears on: HelmRepository ) HelmRepositorySpec defines the reference to a Helm repository. Field Description url string The Helm repository URL, a valid URL contains at least a protocol and host. secretRef Kubernetes core/v1.LocalObjectReference (Optional) The name of the secret containing authentication credentials for the Helm repository. For HTTP/S basic auth the secret must contain username and password fields. For TLS the secret must contain caFile, keyFile and caCert fields. interval Kubernetes meta/v1.Duration The interval at which to check the upstream for updates. timeout Kubernetes meta/v1.Duration (Optional) The timeout of index downloading, defaults to 60s. HelmRepositoryStatus ( Appears on: HelmRepository ) HelmRepositoryStatus defines the observed state of the HelmRepository. Field Description observedGeneration int64 (Optional) ObservedGeneration is the last observed generation. conditions []github.com/fluxcd/pkg/apis/meta.Condition (Optional) Conditions holds the conditions for the HelmRepository. url string (Optional) URL is the download link for the last index fetched. artifact Artifact (Optional) Artifact represents the output of the last successful repository sync. LocalHelmChartSourceReference ( Appears on: HelmChartSpec ) LocalHelmChartSourceReference contains enough information to let you locate the typed referenced object at namespace level. Field Description apiVersion string (Optional) APIVersion of the referent. kind string Kind of the referent, valid values are (\u2018HelmRepository\u2019, \u2018GitRepository\u2019, \u2018Bucket\u2019). name string Name of the referent. Source Source interface must be supported by all API types. This page was automatically generated with gen-crd-api-reference-docs","title":"Source API Reference"},{"location":"components/source/buckets/","text":"Object storage buckets \u00b6 The Bucket API defines a source for artifacts coming from S3 compatible storage such as Minio, Amazon S3, Google Cloud Storage, Alibaba Cloud OSS and others. Specification \u00b6 Bucket: // BucketSpec defines the desired state of an S3 compatible bucket type BucketSpec struct { // The S3 compatible storage provider name, default ('generic'). // +kubebuilder:validation:Enum=generic;aws // +optional Provider string `json:\"provider,omitempty\"` // The bucket name. // +required BucketName string `json:\"bucketName\"` // The bucket endpoint address. // +required Endpoint string `json:\"endpoint\"` // Insecure allows connecting to a non-TLS S3 HTTP endpoint. // +optional Insecure bool `json:\"insecure,omitempty\"` // The bucket region. // +optional Region string `json:\"region,omitempty\"` // The name of the secret containing authentication credentials // for the Bucket. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check for bucket updates. // +required Interval metav1 . Duration `json:\"interval\"` // The timeout for download operations, default ('20s'). // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Ignore overrides the set of excluded patterns in the .sourceignore format // (which is the same as .gitignore). // +optional Ignore * string `json:\"ignore,omitempty\"` } Supported providers: const ( GenericBucketProvider string = \"generic\" AmazonBucketProvider string = \"aws\" ) Status \u00b6 // BucketStatus defines the observed state of a bucket type BucketStatus struct { // ObservedGeneration is the last observed generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // Conditions holds the conditions for the Bucket. // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the artifact output of the last Bucket sync. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful Bucket sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` } Condition reasons \u00b6 const ( // BucketOperationSucceedReason represents the fact that the bucket listing and // download operations succeeded. BucketOperationSucceedReason string = \"BucketOperationSucceed\" // BucketOperationFailedReason represents the fact that the bucket listing or // download operations failed. BucketOperationFailedReason string = \"BucketOperationFailed\" ) Artifact \u00b6 The resource exposes the latest synchronized state from S3 as an artifact in a gzip compressed TAR archive ( <bucket checksum>.tar.gz ). Excluding files \u00b6 Git files ( .git/ , .gitignore , .gitmodules , and .gitattributes ) are excluded from the archive by default, as well as some extensions ( .jpg, .jpeg, .gif, .png, .wmv, .flv, .tar.gz, .zip ) Excluding additional files from the archive is possible by adding a .sourceignore file in the root of the bucket. The .sourceignore file follows the .gitignore pattern format , pattern entries may overrule default exclusions. Another option is to use the spec.ignore field, for example: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : Bucket metadata : name : podinfo spec : ignore : | # exclude all /* # include deploy dir !/deploy # exclude file extensions from deploy dir /deploy/**/*.md /deploy/**/*.txt When specified, spec.ignore overrides the default exclusion list. Spec examples \u00b6 Static authentication \u00b6 Authentication credentials can be provided with a Kubernetes secret that contains accesskey and secretkey fields: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : Bucket metadata : name : podinfo namespace : gitops-system spec : interval : 1m provider : generic bucketName : podinfo endpoint : minio.minio.svc.cluster.local:9000 insecure : true secretRef : name : minio-credentials --- apiVersion : v1 kind : Secret metadata : name : minio-credentials namespace : gitops-system type : Opaque data : accesskey : <BASE64> secretkey : <BASE64> Note: that for Google Cloud Storage you have to enable S3 compatible access in your GCP project. AWS IAM authentication \u00b6 When the provider is aws and the secretRef is not specified, the credentials are retrieve from the EC2 service: apiVersion : source.toolkit.fluccd.io/v1beta1 kind : Bucket metadata : name : podinfo namespace : gitops-system spec : interval : 5m provider : aws bucketName : podinfo endpoint : s3.amazonaws.com region : us-east-1 timeout : 30s Note: that on EKS you have to create an IAM role for the source-controller service account that grants access to the bucket. Status examples \u00b6 Successful download: status : artifact : checksum : b249024b8544521792a079c4037d0a06dd0497a9 lastUpdateTime : \"2020-09-18T08:34:49Z\" path : bucket/gitops-system/podinfo/aeaba8b6dd51c53084f99b098cfae4f5148ad410.tar.gz revision : aeaba8b6dd51c53084f99b098cfae4f5148ad410 url : http://localhost:9090/bucket/gitops-system/podinfo/aeaba8b6dd51c53084f99b098cfae4f5148ad410.tar.gz conditions : - lastTransitionTime : \"2020-09-18T08:34:49Z\" message : 'Fetched revision: aeaba8b6dd51c53084f99b098cfae4f5148ad410' reason : BucketOperationSucceed status : \"True\" type : Ready observedGeneration : 2 url : http://localhost:9090/bucket/gitops-system/podinfo/latest.tar.gz Failed download: status : conditions : - lastTransitionTime : \"2020-09-18T08:34:49Z\" message : \"bucket 'test' not found\" reason : BucketOperationFailed status : \"False\" type : Ready Wait for ready condition: kubectl -n gitios-system wait bucket/podinfo --for = condition = ready --timeout = 1m","title":"Bucket CRD"},{"location":"components/source/buckets/#object-storage-buckets","text":"The Bucket API defines a source for artifacts coming from S3 compatible storage such as Minio, Amazon S3, Google Cloud Storage, Alibaba Cloud OSS and others.","title":"Object storage buckets"},{"location":"components/source/buckets/#specification","text":"Bucket: // BucketSpec defines the desired state of an S3 compatible bucket type BucketSpec struct { // The S3 compatible storage provider name, default ('generic'). // +kubebuilder:validation:Enum=generic;aws // +optional Provider string `json:\"provider,omitempty\"` // The bucket name. // +required BucketName string `json:\"bucketName\"` // The bucket endpoint address. // +required Endpoint string `json:\"endpoint\"` // Insecure allows connecting to a non-TLS S3 HTTP endpoint. // +optional Insecure bool `json:\"insecure,omitempty\"` // The bucket region. // +optional Region string `json:\"region,omitempty\"` // The name of the secret containing authentication credentials // for the Bucket. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check for bucket updates. // +required Interval metav1 . Duration `json:\"interval\"` // The timeout for download operations, default ('20s'). // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // Ignore overrides the set of excluded patterns in the .sourceignore format // (which is the same as .gitignore). // +optional Ignore * string `json:\"ignore,omitempty\"` } Supported providers: const ( GenericBucketProvider string = \"generic\" AmazonBucketProvider string = \"aws\" )","title":"Specification"},{"location":"components/source/buckets/#status","text":"// BucketStatus defines the observed state of a bucket type BucketStatus struct { // ObservedGeneration is the last observed generation. // +optional ObservedGeneration int64 `json:\"observedGeneration,omitempty\"` // Conditions holds the conditions for the Bucket. // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the artifact output of the last Bucket sync. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful Bucket sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` }","title":"Status"},{"location":"components/source/buckets/#condition-reasons","text":"const ( // BucketOperationSucceedReason represents the fact that the bucket listing and // download operations succeeded. BucketOperationSucceedReason string = \"BucketOperationSucceed\" // BucketOperationFailedReason represents the fact that the bucket listing or // download operations failed. BucketOperationFailedReason string = \"BucketOperationFailed\" )","title":"Condition reasons"},{"location":"components/source/buckets/#artifact","text":"The resource exposes the latest synchronized state from S3 as an artifact in a gzip compressed TAR archive ( <bucket checksum>.tar.gz ).","title":"Artifact"},{"location":"components/source/buckets/#excluding-files","text":"Git files ( .git/ , .gitignore , .gitmodules , and .gitattributes ) are excluded from the archive by default, as well as some extensions ( .jpg, .jpeg, .gif, .png, .wmv, .flv, .tar.gz, .zip ) Excluding additional files from the archive is possible by adding a .sourceignore file in the root of the bucket. The .sourceignore file follows the .gitignore pattern format , pattern entries may overrule default exclusions. Another option is to use the spec.ignore field, for example: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : Bucket metadata : name : podinfo spec : ignore : | # exclude all /* # include deploy dir !/deploy # exclude file extensions from deploy dir /deploy/**/*.md /deploy/**/*.txt When specified, spec.ignore overrides the default exclusion list.","title":"Excluding files"},{"location":"components/source/buckets/#spec-examples","text":"","title":"Spec examples"},{"location":"components/source/buckets/#static-authentication","text":"Authentication credentials can be provided with a Kubernetes secret that contains accesskey and secretkey fields: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : Bucket metadata : name : podinfo namespace : gitops-system spec : interval : 1m provider : generic bucketName : podinfo endpoint : minio.minio.svc.cluster.local:9000 insecure : true secretRef : name : minio-credentials --- apiVersion : v1 kind : Secret metadata : name : minio-credentials namespace : gitops-system type : Opaque data : accesskey : <BASE64> secretkey : <BASE64> Note: that for Google Cloud Storage you have to enable S3 compatible access in your GCP project.","title":"Static authentication"},{"location":"components/source/buckets/#aws-iam-authentication","text":"When the provider is aws and the secretRef is not specified, the credentials are retrieve from the EC2 service: apiVersion : source.toolkit.fluccd.io/v1beta1 kind : Bucket metadata : name : podinfo namespace : gitops-system spec : interval : 5m provider : aws bucketName : podinfo endpoint : s3.amazonaws.com region : us-east-1 timeout : 30s Note: that on EKS you have to create an IAM role for the source-controller service account that grants access to the bucket.","title":"AWS IAM authentication"},{"location":"components/source/buckets/#status-examples","text":"Successful download: status : artifact : checksum : b249024b8544521792a079c4037d0a06dd0497a9 lastUpdateTime : \"2020-09-18T08:34:49Z\" path : bucket/gitops-system/podinfo/aeaba8b6dd51c53084f99b098cfae4f5148ad410.tar.gz revision : aeaba8b6dd51c53084f99b098cfae4f5148ad410 url : http://localhost:9090/bucket/gitops-system/podinfo/aeaba8b6dd51c53084f99b098cfae4f5148ad410.tar.gz conditions : - lastTransitionTime : \"2020-09-18T08:34:49Z\" message : 'Fetched revision: aeaba8b6dd51c53084f99b098cfae4f5148ad410' reason : BucketOperationSucceed status : \"True\" type : Ready observedGeneration : 2 url : http://localhost:9090/bucket/gitops-system/podinfo/latest.tar.gz Failed download: status : conditions : - lastTransitionTime : \"2020-09-18T08:34:49Z\" message : \"bucket 'test' not found\" reason : BucketOperationFailed status : \"False\" type : Ready Wait for ready condition: kubectl -n gitios-system wait bucket/podinfo --for = condition = ready --timeout = 1m","title":"Status examples"},{"location":"components/source/controller/","text":"Source Controller \u00b6 The main role of the source management component is to provide a common interface for artifacts acquisition. The source API defines a set of Kubernetes objects that cluster admins and various automated operators can interact with to offload the Git and Helm repositories operations to a dedicated controller. Features: Validate source definitions Authenticate to sources (SSH, user/password, API token) Validate source authenticity (PGP) Detect source changes based on update policies (semver) Fetch resources on-demand and on-a-schedule Package the fetched resources into a well-known format (tar.gz, yaml) Make the artifacts addressable by their source identifier (sha, version, ts) Make the artifacts available in-cluster to interested 3rd parties Notify interested 3rd parties of source changes and availability (status conditions, events, hooks) Links: Source code fluxcd/source-controller Specification docs","title":"Overview"},{"location":"components/source/controller/#source-controller","text":"The main role of the source management component is to provide a common interface for artifacts acquisition. The source API defines a set of Kubernetes objects that cluster admins and various automated operators can interact with to offload the Git and Helm repositories operations to a dedicated controller. Features: Validate source definitions Authenticate to sources (SSH, user/password, API token) Validate source authenticity (PGP) Detect source changes based on update policies (semver) Fetch resources on-demand and on-a-schedule Package the fetched resources into a well-known format (tar.gz, yaml) Make the artifacts addressable by their source identifier (sha, version, ts) Make the artifacts available in-cluster to interested 3rd parties Notify interested 3rd parties of source changes and availability (status conditions, events, hooks) Links: Source code fluxcd/source-controller Specification docs","title":"Source Controller"},{"location":"components/source/gitrepositories/","text":"Git Repositories \u00b6 The GitRepository API defines a source for artifacts coming from Git. The resource exposes the latest synchronized state from Git as an artifact in a gzip compressed TAR archive . Specification \u00b6 Git repository: // GitRepositorySpec defines the desired state of a Git repository. type GitRepositorySpec struct { // The repository URL, can be a HTTP or SSH address. // +kubebuilder:validation:Pattern=\"^(http|https|ssh)://\" // +required URL string `json:\"url\"` // The secret name containing the Git credentials. // For HTTPS repositories the secret must contain username and password // fields. // For SSH repositories the secret must contain identity, identity.pub and // known_hosts fields. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check for repository updates. // +required Interval metav1 . Duration `json:\"interval\"` // The timeout for remote git operations like cloning, default to 20s. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // The git reference to checkout and monitor for changes, defaults to // master branch. // +optional Reference * GitRepositoryRef `json:\"ref,omitempty\"` // Verify OpenPGP signature for the commit that HEAD points to. // +optional Verification * GitRepositoryVerification `json:\"verify,omitempty\"` // Ignore overrides the set of excluded patterns in the .sourceignore format // (which is the same as .gitignore). If not provided, a default will be used, // consult the documentation for your version to find out what those are. // +optional Ignore * string `json:\"ignore,omitempty\"` } Git repository reference: // GitRepositoryRef defines the git ref used for pull and checkout operations. type GitRepositoryRef struct { // The git branch to checkout, defaults to master. // +optional Branch string `json:\"branch,omitempty\"` // The git tag to checkout, takes precedence over branch. // +optional Tag string `json:\"tag,omitempty\"` // The git tag semver expression, takes precedence over tag. // +optional SemVer string `json:\"semver,omitempty\"` // The git commit sha to checkout, if specified tag filters will be ignored. // +optional Commit string `json:\"commit,omitempty\"` } Git repository cryptographic provenance verification: // GitRepositoryVerification defines the OpenPGP signature verification process. type GitRepositoryVerification struct { // Mode describes what git object should be verified, currently ('head'). // +kubebuilder:validation:Enum=head Mode string `json:\"mode\"` // The secret name containing the public keys of all trusted git authors. SecretRef corev1 . LocalObjectReference `json:\"secretRef\"` } Status \u00b6 // GitRepositoryStatus defines the observed state of the GitRepository. type GitRepositoryStatus struct { // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the artifact output of the last repository // sync. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful repository sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` } Condition reasons \u00b6 const ( // GitOperationSucceedReason represents the fact that the git // clone, pull and checkout operations succeeded. GitOperationSucceedReason string = \"GitOperationSucceed\" // GitOperationFailedReason represents the fact that the git // clone, pull or checkout operations failed. GitOperationFailedReason string = \"GitOperationFailed\" ) Artifact \u00b6 The GitRepository API defines a source for artifacts coming from Git. The resource exposes the latest synchronized state from Git as an artifact in a gzip compressed TAR archive ( <commit hash>.tar.gz ). Excluding files \u00b6 Git files ( .git/ , .gitignore , .gitmodules , and .gitattributes ) are excluded from the archive by default, as well as some extensions ( .jpg, .jpeg, .gif, .png, .wmv, .flv, .tar.gz, .zip ) Excluding additional files from the archive is possible by adding a .sourceignore file in the root of the repository. The .sourceignore file follows the .gitignore pattern format , pattern entries may overrule default exclusions. Another option is to use the spec.ignore field, for example: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : interval : 5m url : https://github.com/stefanprodan/podinfo ignore : | # exclude all /* # include deploy dir !/deploy # exclude file extensions from deploy dir /deploy/**/*.md /deploy/**/*.txt When specified, spec.ignore overrides the default exclusion list. Spec examples \u00b6 Checkout strategies \u00b6 Pull the master branch of a public repository every minute: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo Pull a specific branch: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : v3.x Checkout a specific commit from a branch: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master commit : 363a6a8fe6a7f13e05d34c163b0ef02a777da20a Pull a specific tag: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : tag : 3.2.0 Pull tag based on a semver range : apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : semver : \">=3.1.0-rc.1 <3.2.0\" HTTPS authentication \u00b6 HTTPS authentication requires a Kubernetes secret with username and password fields: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : url : https://github.com/stefanprodan/podinfo secretRef : name : https-credentials --- apiVersion : v1 kind : Secret metadata : name : https-credentials namespace : default type : Opaque data : username : <BASE64> password : <BASE64> Note: that self-signed certificates are not supported. SSH authentication \u00b6 SSH authentication requires a Kubernetes secret with identity and known_hosts fields: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : url : ssh://git@github.com/stefanprodan/podinfo secretRef : name : ssh-credentials --- apiVersion : v1 kind : Secret metadata : name : ssh-credentials namespace : default type : Opaque data : identity : <BASE64> identity.pub : <BASE64> known_hosts : <BASE64> Note: that the SSH address does not support SCP syntax. The URL format is ssh://user@host:port/org/repository . Example of generating the SSH credentials secret: ssh-keygen -q -N \"\" -f ./identity ssh-keyscan github.com > ./known_hosts kubectl create secret generic ssh-credentials \\ --from-file = ./identity \\ --from-file = ./identity.pub \\ --from-file = ./known_hosts GPG signature verification \u00b6 Verify the OpenPGP signature for the commit that master branch HEAD points to: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master verify : mode : head secretRef : name : pgp-public-keys --- apiVersion : v1 kind : Secret metadata : name : pgp-public-keys namespace : default type : Opaque data : author1.asc : <BASE64> author2.asc : <BASE64> Example of generating the PGP public keys secret: gpg --export --armor 3CB12BA185C47B67 > author1.asc gpg --export --armor 6A7436E8790F8689 > author2.asc kubectl create secret generic pgp-public-keys \\ --from-file = author1.asc \\ --from-file = author2.asc Status examples \u00b6 Successful sync: status : artifact : lastUpdateTime : \"2020-04-07T06:59:23Z\" path : /data/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz revision : master/363a6a8fe6a7f13e05d34c163b0ef02a777da20a url : http://<host>/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz conditions : - lastTransitionTime : \"2020-04-07T06:59:23Z\" message : 'Git repoistory artifacts are available at: /data/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz' reason : GitOperationSucceed status : \"True\" type : Ready url : http://<host>/gitrepository/default/podinfo/latest.tar.gz Failed authentication: status : conditions : - lastTransitionTime : \"2020-04-06T06:48:59Z\" message : 'git clone error ssh: handshake failed: ssh: unable to authenticate, attempted methods [none publickey], no supported methods remain' reason : AuthenticationFailed status : \"False\" type : Ready Failed PGP signature verification: status : conditions : - lastTransitionTime : \"2020-04-06T06:48:59Z\" message : 'PGP signature of {Stefan Prodan 2020-04-04 13:36:58 +0300 +0300} can not be verified' reason : VerificationFailed status : \"False\" type : Ready Wait for ready condition: kubectl wait gitrepository/podinfo --for = condition = ready --timeout = 1m","title":"GitRepository CRD"},{"location":"components/source/gitrepositories/#git-repositories","text":"The GitRepository API defines a source for artifacts coming from Git. The resource exposes the latest synchronized state from Git as an artifact in a gzip compressed TAR archive .","title":"Git Repositories"},{"location":"components/source/gitrepositories/#specification","text":"Git repository: // GitRepositorySpec defines the desired state of a Git repository. type GitRepositorySpec struct { // The repository URL, can be a HTTP or SSH address. // +kubebuilder:validation:Pattern=\"^(http|https|ssh)://\" // +required URL string `json:\"url\"` // The secret name containing the Git credentials. // For HTTPS repositories the secret must contain username and password // fields. // For SSH repositories the secret must contain identity, identity.pub and // known_hosts fields. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check for repository updates. // +required Interval metav1 . Duration `json:\"interval\"` // The timeout for remote git operations like cloning, default to 20s. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` // The git reference to checkout and monitor for changes, defaults to // master branch. // +optional Reference * GitRepositoryRef `json:\"ref,omitempty\"` // Verify OpenPGP signature for the commit that HEAD points to. // +optional Verification * GitRepositoryVerification `json:\"verify,omitempty\"` // Ignore overrides the set of excluded patterns in the .sourceignore format // (which is the same as .gitignore). If not provided, a default will be used, // consult the documentation for your version to find out what those are. // +optional Ignore * string `json:\"ignore,omitempty\"` } Git repository reference: // GitRepositoryRef defines the git ref used for pull and checkout operations. type GitRepositoryRef struct { // The git branch to checkout, defaults to master. // +optional Branch string `json:\"branch,omitempty\"` // The git tag to checkout, takes precedence over branch. // +optional Tag string `json:\"tag,omitempty\"` // The git tag semver expression, takes precedence over tag. // +optional SemVer string `json:\"semver,omitempty\"` // The git commit sha to checkout, if specified tag filters will be ignored. // +optional Commit string `json:\"commit,omitempty\"` } Git repository cryptographic provenance verification: // GitRepositoryVerification defines the OpenPGP signature verification process. type GitRepositoryVerification struct { // Mode describes what git object should be verified, currently ('head'). // +kubebuilder:validation:Enum=head Mode string `json:\"mode\"` // The secret name containing the public keys of all trusted git authors. SecretRef corev1 . LocalObjectReference `json:\"secretRef\"` }","title":"Specification"},{"location":"components/source/gitrepositories/#status","text":"// GitRepositoryStatus defines the observed state of the GitRepository. type GitRepositoryStatus struct { // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the artifact output of the last repository // sync. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful repository sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` }","title":"Status"},{"location":"components/source/gitrepositories/#condition-reasons","text":"const ( // GitOperationSucceedReason represents the fact that the git // clone, pull and checkout operations succeeded. GitOperationSucceedReason string = \"GitOperationSucceed\" // GitOperationFailedReason represents the fact that the git // clone, pull or checkout operations failed. GitOperationFailedReason string = \"GitOperationFailed\" )","title":"Condition reasons"},{"location":"components/source/gitrepositories/#artifact","text":"The GitRepository API defines a source for artifacts coming from Git. The resource exposes the latest synchronized state from Git as an artifact in a gzip compressed TAR archive ( <commit hash>.tar.gz ).","title":"Artifact"},{"location":"components/source/gitrepositories/#excluding-files","text":"Git files ( .git/ , .gitignore , .gitmodules , and .gitattributes ) are excluded from the archive by default, as well as some extensions ( .jpg, .jpeg, .gif, .png, .wmv, .flv, .tar.gz, .zip ) Excluding additional files from the archive is possible by adding a .sourceignore file in the root of the repository. The .sourceignore file follows the .gitignore pattern format , pattern entries may overrule default exclusions. Another option is to use the spec.ignore field, for example: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : interval : 5m url : https://github.com/stefanprodan/podinfo ignore : | # exclude all /* # include deploy dir !/deploy # exclude file extensions from deploy dir /deploy/**/*.md /deploy/**/*.txt When specified, spec.ignore overrides the default exclusion list.","title":"Excluding files"},{"location":"components/source/gitrepositories/#spec-examples","text":"","title":"Spec examples"},{"location":"components/source/gitrepositories/#checkout-strategies","text":"Pull the master branch of a public repository every minute: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo Pull a specific branch: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : v3.x Checkout a specific commit from a branch: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master commit : 363a6a8fe6a7f13e05d34c163b0ef02a777da20a Pull a specific tag: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : tag : 3.2.0 Pull tag based on a semver range : apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : semver : \">=3.1.0-rc.1 <3.2.0\"","title":"Checkout strategies"},{"location":"components/source/gitrepositories/#https-authentication","text":"HTTPS authentication requires a Kubernetes secret with username and password fields: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : url : https://github.com/stefanprodan/podinfo secretRef : name : https-credentials --- apiVersion : v1 kind : Secret metadata : name : https-credentials namespace : default type : Opaque data : username : <BASE64> password : <BASE64> Note: that self-signed certificates are not supported.","title":"HTTPS authentication"},{"location":"components/source/gitrepositories/#ssh-authentication","text":"SSH authentication requires a Kubernetes secret with identity and known_hosts fields: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : url : ssh://git@github.com/stefanprodan/podinfo secretRef : name : ssh-credentials --- apiVersion : v1 kind : Secret metadata : name : ssh-credentials namespace : default type : Opaque data : identity : <BASE64> identity.pub : <BASE64> known_hosts : <BASE64> Note: that the SSH address does not support SCP syntax. The URL format is ssh://user@host:port/org/repository . Example of generating the SSH credentials secret: ssh-keygen -q -N \"\" -f ./identity ssh-keyscan github.com > ./known_hosts kubectl create secret generic ssh-credentials \\ --from-file = ./identity \\ --from-file = ./identity.pub \\ --from-file = ./known_hosts","title":"SSH authentication"},{"location":"components/source/gitrepositories/#gpg-signature-verification","text":"Verify the OpenPGP signature for the commit that master branch HEAD points to: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : GitRepository metadata : name : podinfo spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master verify : mode : head secretRef : name : pgp-public-keys --- apiVersion : v1 kind : Secret metadata : name : pgp-public-keys namespace : default type : Opaque data : author1.asc : <BASE64> author2.asc : <BASE64> Example of generating the PGP public keys secret: gpg --export --armor 3CB12BA185C47B67 > author1.asc gpg --export --armor 6A7436E8790F8689 > author2.asc kubectl create secret generic pgp-public-keys \\ --from-file = author1.asc \\ --from-file = author2.asc","title":"GPG signature verification"},{"location":"components/source/gitrepositories/#status-examples","text":"Successful sync: status : artifact : lastUpdateTime : \"2020-04-07T06:59:23Z\" path : /data/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz revision : master/363a6a8fe6a7f13e05d34c163b0ef02a777da20a url : http://<host>/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz conditions : - lastTransitionTime : \"2020-04-07T06:59:23Z\" message : 'Git repoistory artifacts are available at: /data/gitrepository/default/podinfo/363a6a8fe6a7f13e05d34c163b0ef02a777da20a.tar.gz' reason : GitOperationSucceed status : \"True\" type : Ready url : http://<host>/gitrepository/default/podinfo/latest.tar.gz Failed authentication: status : conditions : - lastTransitionTime : \"2020-04-06T06:48:59Z\" message : 'git clone error ssh: handshake failed: ssh: unable to authenticate, attempted methods [none publickey], no supported methods remain' reason : AuthenticationFailed status : \"False\" type : Ready Failed PGP signature verification: status : conditions : - lastTransitionTime : \"2020-04-06T06:48:59Z\" message : 'PGP signature of {Stefan Prodan 2020-04-04 13:36:58 +0300 +0300} can not be verified' reason : VerificationFailed status : \"False\" type : Ready Wait for ready condition: kubectl wait gitrepository/podinfo --for = condition = ready --timeout = 1m","title":"Status examples"},{"location":"components/source/helmcharts/","text":"Helm Charts \u00b6 The HelmChart API defines a source for Helm chart artifacts coming from HelmRepository sources . The resource exposes the latest pulled or packaged chart as an artifact. Specification \u00b6 Helm chart: // HelmChartSpec defines the desired state of a Helm chart. type HelmChartSpec struct { // The name or path the Helm chart is available at in the SourceRef. // +required Chart string `json:\"chart\"` // The chart version semver expression, ignored for charts from GitRepository // and Bucket sources. Defaults to latest when omitted. // +optional Version string `json:\"version,omitempty\"` // The reference to the Source the chart is available at. // +required SourceRef LocalHelmChartSourceReference `json:\"sourceRef\"` // The interval at which to check the Source for updates. // +required Interval metav1 . Duration `json:\"interval\"` // Alternative values file to use as the default chart values, expected to be a // relative path in the SourceRef. Ignored when omitted. // +optional ValuesFile string `json:\"valuesFile,omitempty\"` } Reference types \u00b6 // LocalHelmChartSourceReference contains enough information to let you locate // the typed referenced object at namespace level. type LocalHelmChartSourceReference struct { // APIVersion of the referent. // +optional APIVersion string `json:\"apiVersion,omitempty\"` // Kind of the referent, valid values are ('HelmRepository', 'GitRepository', // 'Bucket'). // +kubebuilder:validation:Enum=HelmRepository;GitRepository;Bucket // +required Kind string `json:\"kind\"` // Name of the referent. // +required Name string `json:\"name\"` } Status \u00b6 // HelmChartStatus defines the observed state of the HelmChart. type HelmChartStatus struct { // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the last chart fetched. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful chart sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` } Condition reasons \u00b6 const ( // ChartPullFailedReason represents the fact that the pull of the Helm chart // failed. ChartPullFailedReason string = \"ChartPullFailed\" // ChartPullSucceededReason represents the fact that the pull of the Helm chart // succeeded. ChartPullSucceededReason string = \"ChartPullSucceeded\" // ChartPackageFailedReason represent the fact that the package of the Helm // chart failed. ChartPackageFailedReason string = \"ChartPackageFailed\" // ChartPackageSucceededReason represents the fact that the package of the Helm // chart succeeded. ChartPackageSucceededReason string = \"ChartPackageSucceeded\" ) Spec examples \u00b6 Pull a specific chart version every five minutes: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : redis spec : chart : redis version : 10.5.7 sourceRef : name : stable kind : HelmRepository interval : 5m Pull the latest chart version that matches the semver range every ten minutes: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : redis spec : chart : redis version : 10.5.x sourceRef : name : stable kind : HelmRepository interval : 10m Check a Git repository every ten minutes for a new version in the Chart.yaml , and package a new chart if the revision differs: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : podinfo spec : chart : ./charts/podinfo sourceRef : name : podinfo kind : GitRepository interval : 10m Check a S3 compatible bucket every ten minutes for a new version in the Chart.yaml , and package a new chart if the revision differs: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : podinfo spec : chart : ./podinfo sourceRef : name : charts kind : Bucket interval : 10m Status examples \u00b6 Successful chart pull: status : url : http://<host>/helmchart/default/redis/redis-10.5.7.tgz conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : Helm chart is available at /data/helmchart/default/redis/redis-10.5.7.tgz reason : ChartPullSucceeded status : \"True\" type : Ready Failed chart pull: status : conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : 'invalid chart URL format' reason : ChartPullFailed status : \"False\" type : Ready Wait for ready condition: kubectl wait helmchart/redis --for = condition = ready --timeout = 1m","title":"HelmChart CRD"},{"location":"components/source/helmcharts/#helm-charts","text":"The HelmChart API defines a source for Helm chart artifacts coming from HelmRepository sources . The resource exposes the latest pulled or packaged chart as an artifact.","title":"Helm Charts"},{"location":"components/source/helmcharts/#specification","text":"Helm chart: // HelmChartSpec defines the desired state of a Helm chart. type HelmChartSpec struct { // The name or path the Helm chart is available at in the SourceRef. // +required Chart string `json:\"chart\"` // The chart version semver expression, ignored for charts from GitRepository // and Bucket sources. Defaults to latest when omitted. // +optional Version string `json:\"version,omitempty\"` // The reference to the Source the chart is available at. // +required SourceRef LocalHelmChartSourceReference `json:\"sourceRef\"` // The interval at which to check the Source for updates. // +required Interval metav1 . Duration `json:\"interval\"` // Alternative values file to use as the default chart values, expected to be a // relative path in the SourceRef. Ignored when omitted. // +optional ValuesFile string `json:\"valuesFile,omitempty\"` }","title":"Specification"},{"location":"components/source/helmcharts/#reference-types","text":"// LocalHelmChartSourceReference contains enough information to let you locate // the typed referenced object at namespace level. type LocalHelmChartSourceReference struct { // APIVersion of the referent. // +optional APIVersion string `json:\"apiVersion,omitempty\"` // Kind of the referent, valid values are ('HelmRepository', 'GitRepository', // 'Bucket'). // +kubebuilder:validation:Enum=HelmRepository;GitRepository;Bucket // +required Kind string `json:\"kind\"` // Name of the referent. // +required Name string `json:\"name\"` }","title":"Reference types"},{"location":"components/source/helmcharts/#status","text":"// HelmChartStatus defines the observed state of the HelmChart. type HelmChartStatus struct { // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the last chart fetched. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful chart sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` }","title":"Status"},{"location":"components/source/helmcharts/#condition-reasons","text":"const ( // ChartPullFailedReason represents the fact that the pull of the Helm chart // failed. ChartPullFailedReason string = \"ChartPullFailed\" // ChartPullSucceededReason represents the fact that the pull of the Helm chart // succeeded. ChartPullSucceededReason string = \"ChartPullSucceeded\" // ChartPackageFailedReason represent the fact that the package of the Helm // chart failed. ChartPackageFailedReason string = \"ChartPackageFailed\" // ChartPackageSucceededReason represents the fact that the package of the Helm // chart succeeded. ChartPackageSucceededReason string = \"ChartPackageSucceeded\" )","title":"Condition reasons"},{"location":"components/source/helmcharts/#spec-examples","text":"Pull a specific chart version every five minutes: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : redis spec : chart : redis version : 10.5.7 sourceRef : name : stable kind : HelmRepository interval : 5m Pull the latest chart version that matches the semver range every ten minutes: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : redis spec : chart : redis version : 10.5.x sourceRef : name : stable kind : HelmRepository interval : 10m Check a Git repository every ten minutes for a new version in the Chart.yaml , and package a new chart if the revision differs: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : podinfo spec : chart : ./charts/podinfo sourceRef : name : podinfo kind : GitRepository interval : 10m Check a S3 compatible bucket every ten minutes for a new version in the Chart.yaml , and package a new chart if the revision differs: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmChart metadata : name : podinfo spec : chart : ./podinfo sourceRef : name : charts kind : Bucket interval : 10m","title":"Spec examples"},{"location":"components/source/helmcharts/#status-examples","text":"Successful chart pull: status : url : http://<host>/helmchart/default/redis/redis-10.5.7.tgz conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : Helm chart is available at /data/helmchart/default/redis/redis-10.5.7.tgz reason : ChartPullSucceeded status : \"True\" type : Ready Failed chart pull: status : conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : 'invalid chart URL format' reason : ChartPullFailed status : \"False\" type : Ready Wait for ready condition: kubectl wait helmchart/redis --for = condition = ready --timeout = 1m","title":"Status examples"},{"location":"components/source/helmrepositories/","text":"Helm Repositories \u00b6 The HelmRepository API defines a source for Helm repositories. The resource exposes the latest synchronized repository index as an artifact. Specification \u00b6 Helm repository: // HelmRepositorySpec defines the reference to a Helm repository. type HelmRepositorySpec struct { // The Helm repository URL, a valid URL contains at least a protocol and host. // +required URL string `json:\"url\"` // The name of the secret containing authentication credentials for the Helm // repository. // For HTTP/S basic auth the secret must contain username and // password fields. // For TLS the secret must contain caFile, keyFile and caCert // fields. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check the upstream for updates. // +required Interval metav1 . Duration `json:\"interval\"` // The timeout of index downloading, defaults to 60s. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` } Status \u00b6 // HelmRepositoryStatus defines the observed state of the HelmRepository. type HelmRepositoryStatus struct { // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the last index fetched. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful repository sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` } Condition reasons \u00b6 const ( // IndexationFailedReason represents the fact that the indexation of the given // Helm repository failed. IndexationFailedReason string = \"IndexationFailed\" // IndexationSucceededReason represents the fact that the indexation of the // given Helm repository succeeded. IndexationSucceededReason string = \"IndexationSucceed\" ) Spec examples \u00b6 Pull the index of a public Helm repository every ten minutes: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmRepository metadata : name : stable spec : url : https://kubernetes-charts.storage.googleapis.com/ interval : 10m Pull the index of a private Helm repository every minute: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmRepository metadata : name : private spec : url : https://charts.example.com secretRef : name : https-credentials interval : 1m --- apiVersion : v1 kind : Secret metadata : name : https-credentials namespace : default type : Opaque data : username : <BASE64> password : <BASE64> certFile : <BASE64> keyFile : <BASE64> caFile : <BASE64> Status examples \u00b6 Successful indexation: status : url : http://<host>/helmrepository/default/stable/index.yaml conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : Helm repository index is available at /data/helmrepository/default/stable/index-21c195d78e699e4b656e2885887d019627838993.yaml reason : IndexationSucceeded status : \"True\" type : Ready Failed indexation: status : conditions : - lastTransitionTime : \"2020-04-10T09:27:21Z\" message : 'failed to fetch https://invalid.example.com/index.yaml : 404 Not Found' reason : IndexationFailed status : \"False\" type : Ready Invalid repository URL: status : conditions : - lastTransitionTime : \"2020-04-10T09:27:21Z\" message : scheme \"invalid\" not supported reason : URLInvalid status : \"False\" type : Ready Wait for ready condition: kubectl wait helmrepository/stable --for = condition = ready --timeout = 1m","title":"HelmRepository CRD"},{"location":"components/source/helmrepositories/#helm-repositories","text":"The HelmRepository API defines a source for Helm repositories. The resource exposes the latest synchronized repository index as an artifact.","title":"Helm Repositories"},{"location":"components/source/helmrepositories/#specification","text":"Helm repository: // HelmRepositorySpec defines the reference to a Helm repository. type HelmRepositorySpec struct { // The Helm repository URL, a valid URL contains at least a protocol and host. // +required URL string `json:\"url\"` // The name of the secret containing authentication credentials for the Helm // repository. // For HTTP/S basic auth the secret must contain username and // password fields. // For TLS the secret must contain caFile, keyFile and caCert // fields. // +optional SecretRef * corev1 . LocalObjectReference `json:\"secretRef,omitempty\"` // The interval at which to check the upstream for updates. // +required Interval metav1 . Duration `json:\"interval\"` // The timeout of index downloading, defaults to 60s. // +optional Timeout * metav1 . Duration `json:\"timeout,omitempty\"` }","title":"Specification"},{"location":"components/source/helmrepositories/#status","text":"// HelmRepositoryStatus defines the observed state of the HelmRepository. type HelmRepositoryStatus struct { // +optional Conditions [] meta . Condition `json:\"conditions,omitempty\"` // URL is the download link for the last index fetched. // +optional URL string `json:\"url,omitempty\"` // Artifact represents the output of the last successful repository sync. // +optional Artifact * Artifact `json:\"artifact,omitempty\"` }","title":"Status"},{"location":"components/source/helmrepositories/#condition-reasons","text":"const ( // IndexationFailedReason represents the fact that the indexation of the given // Helm repository failed. IndexationFailedReason string = \"IndexationFailed\" // IndexationSucceededReason represents the fact that the indexation of the // given Helm repository succeeded. IndexationSucceededReason string = \"IndexationSucceed\" )","title":"Condition reasons"},{"location":"components/source/helmrepositories/#spec-examples","text":"Pull the index of a public Helm repository every ten minutes: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmRepository metadata : name : stable spec : url : https://kubernetes-charts.storage.googleapis.com/ interval : 10m Pull the index of a private Helm repository every minute: apiVersion : source.toolkit.fluxcd.io/v1beta1 kind : HelmRepository metadata : name : private spec : url : https://charts.example.com secretRef : name : https-credentials interval : 1m --- apiVersion : v1 kind : Secret metadata : name : https-credentials namespace : default type : Opaque data : username : <BASE64> password : <BASE64> certFile : <BASE64> keyFile : <BASE64> caFile : <BASE64>","title":"Spec examples"},{"location":"components/source/helmrepositories/#status-examples","text":"Successful indexation: status : url : http://<host>/helmrepository/default/stable/index.yaml conditions : - lastTransitionTime : \"2020-04-10T09:34:45Z\" message : Helm repository index is available at /data/helmrepository/default/stable/index-21c195d78e699e4b656e2885887d019627838993.yaml reason : IndexationSucceeded status : \"True\" type : Ready Failed indexation: status : conditions : - lastTransitionTime : \"2020-04-10T09:27:21Z\" message : 'failed to fetch https://invalid.example.com/index.yaml : 404 Not Found' reason : IndexationFailed status : \"False\" type : Ready Invalid repository URL: status : conditions : - lastTransitionTime : \"2020-04-10T09:27:21Z\" message : scheme \"invalid\" not supported reason : URLInvalid status : \"False\" type : Ready Wait for ready condition: kubectl wait helmrepository/stable --for = condition = ready --timeout = 1m","title":"Status examples"},{"location":"contributing/","text":"Contributing \u00b6 The GitOps Toolkit is Apache 2.0 licensed and accepts contributions via GitHub pull requests. This document outlines some of the conventions on to make it easier to get your contribution accepted. We gratefully welcome improvements to issues and documentation as well as to code. Certificate of Origin \u00b6 By contributing to this project you agree to the Developer Certificate of Origin (DCO). This document was created by the Linux Kernel community and is a simple statement that you, as a contributor, have the legal right to make the contribution. No action from you is required, but it's a good idea to see the DCO file for details before you start contributing code to FluxCD organization. Communications \u00b6 For realtime communications we use Slack: To join the conversation, simply join the CNCF Slack workspace and use the #flux-dev channel. To discuss ideas and specifications we use Github Discussions . For announcements we use a mailing list as well. Simply subscribe to flux-dev on cncf.io to join the conversation (there you can also add calendar invites to your Google calendar for our Flux meeting ). Understanding the GitOps Toolkit \u00b6 If you are entirely new to the GitOps Toolkit, you might want to take a look at the introductory talk and demo . This project is composed of: /f/toolkit : The GitOps Toolkit CLI /f/source-manager : Kubernetes operator for managing sources /f/kustomize-controller : Kubernetes operator for building GitOps pipelines with Kustomize /f/helm-controller : Kubernetes operator for building GitOps pipelines with Helm /f/notification-controller : Kubernetes operator for handling inbound and outbound events Understanding the code \u00b6 To get started with developing controllers, you might want to review our guide which walks you through writing a short and concise controller that watches out for source changes. How to run the test suite \u00b6 You can run the unit tests by simply doing make test Acceptance policy \u00b6 These things will make a PR more likely to be accepted: a well-described requirement tests for new code tests for old code! new code and tests follow the conventions in old code and tests a good commit message (see below) all code must abide Go Code Review Comments names should abide What's in a name code must build on both Linux and Darwin, via plain go build code should have appropriate test coverage and tests should be written to work with go test In general, we will merge a PR once one maintainer has endorsed it. For substantial changes, more people may become involved, and you might get asked to resubmit the PR or divide the changes into more than one PR. Format of the Commit Message \u00b6 For the GitOps Toolkit controllers we prefer the following rules for good commit messages: Limit the subject to 50 characters and write as the continuation of the sentence \"If applied, this commit will ...\" Explain what and why in the body, if more than a trivial change; wrap it at 72 characters. The following article has some more helpful advice on documenting your work.","title":"Contributing"},{"location":"contributing/#contributing","text":"The GitOps Toolkit is Apache 2.0 licensed and accepts contributions via GitHub pull requests. This document outlines some of the conventions on to make it easier to get your contribution accepted. We gratefully welcome improvements to issues and documentation as well as to code.","title":"Contributing"},{"location":"contributing/#certificate-of-origin","text":"By contributing to this project you agree to the Developer Certificate of Origin (DCO). This document was created by the Linux Kernel community and is a simple statement that you, as a contributor, have the legal right to make the contribution. No action from you is required, but it's a good idea to see the DCO file for details before you start contributing code to FluxCD organization.","title":"Certificate of Origin"},{"location":"contributing/#communications","text":"For realtime communications we use Slack: To join the conversation, simply join the CNCF Slack workspace and use the #flux-dev channel. To discuss ideas and specifications we use Github Discussions . For announcements we use a mailing list as well. Simply subscribe to flux-dev on cncf.io to join the conversation (there you can also add calendar invites to your Google calendar for our Flux meeting ).","title":"Communications"},{"location":"contributing/#understanding-the-gitops-toolkit","text":"If you are entirely new to the GitOps Toolkit, you might want to take a look at the introductory talk and demo . This project is composed of: /f/toolkit : The GitOps Toolkit CLI /f/source-manager : Kubernetes operator for managing sources /f/kustomize-controller : Kubernetes operator for building GitOps pipelines with Kustomize /f/helm-controller : Kubernetes operator for building GitOps pipelines with Helm /f/notification-controller : Kubernetes operator for handling inbound and outbound events","title":"Understanding the GitOps Toolkit"},{"location":"contributing/#understanding-the-code","text":"To get started with developing controllers, you might want to review our guide which walks you through writing a short and concise controller that watches out for source changes.","title":"Understanding the code"},{"location":"contributing/#how-to-run-the-test-suite","text":"You can run the unit tests by simply doing make test","title":"How to run the test suite"},{"location":"contributing/#acceptance-policy","text":"These things will make a PR more likely to be accepted: a well-described requirement tests for new code tests for old code! new code and tests follow the conventions in old code and tests a good commit message (see below) all code must abide Go Code Review Comments names should abide What's in a name code must build on both Linux and Darwin, via plain go build code should have appropriate test coverage and tests should be written to work with go test In general, we will merge a PR once one maintainer has endorsed it. For substantial changes, more people may become involved, and you might get asked to resubmit the PR or divide the changes into more than one PR.","title":"Acceptance policy"},{"location":"contributing/#format-of-the-commit-message","text":"For the GitOps Toolkit controllers we prefer the following rules for good commit messages: Limit the subject to 50 characters and write as the continuation of the sentence \"If applied, this commit will ...\" Explain what and why in the body, if more than a trivial change; wrap it at 72 characters. The following article has some more helpful advice on documenting your work.","title":"Format of the Commit Message"},{"location":"dev-guides/source-watcher/","text":"Watching for source changes \u00b6 In this guide you'll be developing a Kubernetes controller with Kubebuilder that subscribes to GitRepository events and reacts to revision changes by downloading the artifact produced by source-controller . Prerequisites \u00b6 On your dev machine install the following tools: go >= 1.13 kubebuilder >= 2.3 kind >= 0.8 kubectl >= 1.18 kustomize >= 3.5 docker >= 19.03 Install the GitOps Toolkit \u00b6 Create a cluster for testing: kind create cluster --name dev Install the toolkit CLI: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash Verify that your dev machine satisfies the prerequisites with: gotk check --pre Install the toolkit controllers on the dev cluster: gotk install Clone the sample controller \u00b6 You'll be using stefanprodan/source-watcher as a template for developing your own controller. The source-watcher was scaffolded with kubebuilder init . Clone the source-watcher repo: git clone https://github.com/stefanprodan/source-watcher cd source-watcher Build the controller: make Run the controller \u00b6 Port forward to source-controller artifacts server: kubectl -n gotk-system port-forward svc/source-controller 8181 :80 Export the local address as SOURCE_HOST : export SOURCE_HOST = localhost:8181 Run source-watcher locally: make run Create a Git source: gotk create source git test \\ --url = https://github.com/stefanprodan/podinfo \\ --tag = 4 .0.0 The source-watcher should log the revision: New revision detected {\"gitrepository\": \"gotk-system/test\", \"revision\": \"4.0.0/ab953493ee14c3c9800bda0251e0c507f9741408\"} Extracted tarball into /var/folders/77/3y6x_p2j2g9fspdkzjbm5_s40000gn/T/test292235827: 123 files, 29 dirs (32.603415ms) Processing files... Change the Git tag: gotk create source git test \\ --url = https://github.com/stefanprodan/podinfo \\ --tag = 4 .0.1 The source-watcher should log the new revision: New revision detected {\"gitrepository\": \"gotk-system/test\", \"revision\": \"4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27\"} The source-controller reports the revision under GitRepository.Status.Artifact.Revision in the format: <branch|tag>/<commit> . How it works \u00b6 The GitRepositoryWatcher controller does the following: subscribes to GitRepository events detects when the Git revision changes downloads and extracts the source artifact write to stdout the extracted file names // GitRepositoryWatcher watches GitRepository objects for revision changes type GitRepositoryWatcher struct { client . Client Log logr . Logger Scheme * runtime . Scheme } // +kubebuilder:rbac:groups=source.toolkit.fluxcd.io,resources=gitrepositories,verbs=get;list;watch // +kubebuilder:rbac:groups=source.toolkit.fluxcd.io,resources=gitrepositories/status,verbs=get func ( r * GitRepositoryWatcher ) Reconcile ( req ctrl . Request ) ( ctrl . Result , error ) { // set timeout for the reconciliation ctx , cancel := context . WithTimeout ( context . Background (), 15 * time . Second ) defer cancel () // get source object var repository sourcev1 . GitRepository if err := r . Get ( ctx , req . NamespacedName , & repository ); err != nil { return ctrl . Result {}, client . IgnoreNotFound ( err ) } log := r . Log . WithValues ( strings . ToLower ( repository . Kind ), req . NamespacedName ) log . Info ( \"New revision detected\" , \"revision\" , repository . Status . Artifact . Revision ) // create tmp dir tmpDir , err := ioutil . TempDir ( \"\" , repository . Name ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to create temp dir, error: %w\" , err ) } defer os . RemoveAll ( tmpDir ) // download and extract artifact summary , err := r . fetchArtifact ( ctx , repository , tmpDir ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to fetch artifact, error: %w\" , err ) } log . Info ( summary ) // list artifact content files , err := ioutil . ReadDir ( tmpDir ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to list files, error: %w\" , err ) } // do something with the artifact content for _ , f := range files { log . Info ( \"Processing \" + f . Name ()) } return ctrl . Result {}, nil } func ( r * GitRepositoryWatcher ) SetupWithManager ( mgr ctrl . Manager ) error { return ctrl . NewControllerManagedBy ( mgr ). For ( & sourcev1 . GitRepository {}). WithEventFilter ( GitRepositoryRevisionChangePredicate {}). Complete ( r ) } To add the watcher to an existing project, copy the controller and the revision change predicate to your controllers dir: gitrepository_watcher.go gitrepository_predicate.go In your main.go init function, register the Source API schema: import sourcev1 \"github.com/fluxcd/source-controller/api/v1beta1\" func init () { _ = clientgoscheme . AddToScheme ( scheme ) _ = sourcev1 . AddToScheme ( scheme ) // +kubebuilder:scaffold:scheme } Start the controller in the main function: func main () { if err = ( & controllers . GitRepositoryWatcher { Client : mgr . GetClient (), Log : ctrl . Log . WithName ( \"controllers\" ). WithName ( \"GitRepositoryWatcher\" ), Scheme : mgr . GetScheme (), }). SetupWithManager ( mgr ); err != nil { setupLog . Error ( err , \"unable to create controller\" , \"controller\" , \"GitRepositoryWatcher\" ) os . Exit ( 1 ) } } Note that the watcher controller depends on Kubernetes client-go >= 1.18. Your go.mod should require controller-runtime v0.6 or newer: require ( k8s . io / apimachinery v0 .18.4 k8s . io / client - go v0 .18.4 sigs . k8s . io / controller - runtime v0 .6.0 ) That's it! Happy hacking!","title":"Watching for source changes"},{"location":"dev-guides/source-watcher/#watching-for-source-changes","text":"In this guide you'll be developing a Kubernetes controller with Kubebuilder that subscribes to GitRepository events and reacts to revision changes by downloading the artifact produced by source-controller .","title":"Watching for source changes"},{"location":"dev-guides/source-watcher/#prerequisites","text":"On your dev machine install the following tools: go >= 1.13 kubebuilder >= 2.3 kind >= 0.8 kubectl >= 1.18 kustomize >= 3.5 docker >= 19.03","title":"Prerequisites"},{"location":"dev-guides/source-watcher/#install-the-gitops-toolkit","text":"Create a cluster for testing: kind create cluster --name dev Install the toolkit CLI: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash Verify that your dev machine satisfies the prerequisites with: gotk check --pre Install the toolkit controllers on the dev cluster: gotk install","title":"Install the GitOps Toolkit"},{"location":"dev-guides/source-watcher/#clone-the-sample-controller","text":"You'll be using stefanprodan/source-watcher as a template for developing your own controller. The source-watcher was scaffolded with kubebuilder init . Clone the source-watcher repo: git clone https://github.com/stefanprodan/source-watcher cd source-watcher Build the controller: make","title":"Clone the sample controller"},{"location":"dev-guides/source-watcher/#run-the-controller","text":"Port forward to source-controller artifacts server: kubectl -n gotk-system port-forward svc/source-controller 8181 :80 Export the local address as SOURCE_HOST : export SOURCE_HOST = localhost:8181 Run source-watcher locally: make run Create a Git source: gotk create source git test \\ --url = https://github.com/stefanprodan/podinfo \\ --tag = 4 .0.0 The source-watcher should log the revision: New revision detected {\"gitrepository\": \"gotk-system/test\", \"revision\": \"4.0.0/ab953493ee14c3c9800bda0251e0c507f9741408\"} Extracted tarball into /var/folders/77/3y6x_p2j2g9fspdkzjbm5_s40000gn/T/test292235827: 123 files, 29 dirs (32.603415ms) Processing files... Change the Git tag: gotk create source git test \\ --url = https://github.com/stefanprodan/podinfo \\ --tag = 4 .0.1 The source-watcher should log the new revision: New revision detected {\"gitrepository\": \"gotk-system/test\", \"revision\": \"4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27\"} The source-controller reports the revision under GitRepository.Status.Artifact.Revision in the format: <branch|tag>/<commit> .","title":"Run the controller"},{"location":"dev-guides/source-watcher/#how-it-works","text":"The GitRepositoryWatcher controller does the following: subscribes to GitRepository events detects when the Git revision changes downloads and extracts the source artifact write to stdout the extracted file names // GitRepositoryWatcher watches GitRepository objects for revision changes type GitRepositoryWatcher struct { client . Client Log logr . Logger Scheme * runtime . Scheme } // +kubebuilder:rbac:groups=source.toolkit.fluxcd.io,resources=gitrepositories,verbs=get;list;watch // +kubebuilder:rbac:groups=source.toolkit.fluxcd.io,resources=gitrepositories/status,verbs=get func ( r * GitRepositoryWatcher ) Reconcile ( req ctrl . Request ) ( ctrl . Result , error ) { // set timeout for the reconciliation ctx , cancel := context . WithTimeout ( context . Background (), 15 * time . Second ) defer cancel () // get source object var repository sourcev1 . GitRepository if err := r . Get ( ctx , req . NamespacedName , & repository ); err != nil { return ctrl . Result {}, client . IgnoreNotFound ( err ) } log := r . Log . WithValues ( strings . ToLower ( repository . Kind ), req . NamespacedName ) log . Info ( \"New revision detected\" , \"revision\" , repository . Status . Artifact . Revision ) // create tmp dir tmpDir , err := ioutil . TempDir ( \"\" , repository . Name ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to create temp dir, error: %w\" , err ) } defer os . RemoveAll ( tmpDir ) // download and extract artifact summary , err := r . fetchArtifact ( ctx , repository , tmpDir ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to fetch artifact, error: %w\" , err ) } log . Info ( summary ) // list artifact content files , err := ioutil . ReadDir ( tmpDir ) if err != nil { return ctrl . Result {}, fmt . Errorf ( \"unable to list files, error: %w\" , err ) } // do something with the artifact content for _ , f := range files { log . Info ( \"Processing \" + f . Name ()) } return ctrl . Result {}, nil } func ( r * GitRepositoryWatcher ) SetupWithManager ( mgr ctrl . Manager ) error { return ctrl . NewControllerManagedBy ( mgr ). For ( & sourcev1 . GitRepository {}). WithEventFilter ( GitRepositoryRevisionChangePredicate {}). Complete ( r ) } To add the watcher to an existing project, copy the controller and the revision change predicate to your controllers dir: gitrepository_watcher.go gitrepository_predicate.go In your main.go init function, register the Source API schema: import sourcev1 \"github.com/fluxcd/source-controller/api/v1beta1\" func init () { _ = clientgoscheme . AddToScheme ( scheme ) _ = sourcev1 . AddToScheme ( scheme ) // +kubebuilder:scaffold:scheme } Start the controller in the main function: func main () { if err = ( & controllers . GitRepositoryWatcher { Client : mgr . GetClient (), Log : ctrl . Log . WithName ( \"controllers\" ). WithName ( \"GitRepositoryWatcher\" ), Scheme : mgr . GetScheme (), }). SetupWithManager ( mgr ); err != nil { setupLog . Error ( err , \"unable to create controller\" , \"controller\" , \"GitRepositoryWatcher\" ) os . Exit ( 1 ) } } Note that the watcher controller depends on Kubernetes client-go >= 1.18. Your go.mod should require controller-runtime v0.6 or newer: require ( k8s . io / apimachinery v0 .18.4 k8s . io / client - go v0 .18.4 sigs . k8s . io / controller - runtime v0 .6.0 ) That's it! Happy hacking!","title":"How it works"},{"location":"faq/","text":"Frequently asked questions \u00b6 General questions \u00b6 What does the GitOps Toolkit mean for Flux? \u00b6 Flux v1 is a monolithic do-it-all operator; the GitOps Toolkit separates the functionalities into specialized controllers. Flux v2 will be a curated configuration of the GitOps Toolkit, which you can install and operate simply using the gotk command. You can easily pick and choose the functionality you need and extend it to serve your own purposes. The timeline we are looking at right now is: Put Flux v1 into maintenance mode (no new features being added; bugfixes and CVEs patched only). Continue work on GitOps Toolkit roadmap . We will provide transition guides for specific user groups, e.g. users of Flux v1 in read-only mode, or of Helm Operator v1, etc. once the functionality is integrated in the GitOps Toolkit and it's deemed \"ready\". Once the use-cases of Flux v1 are covered, we will continue supporting Flux v1 for 6 months. This will be the transition period before it's considered unsupported. Why did you rewrite Flux? \u00b6 The GitOps Toolkit implements its functionality in individual controllers, which allowed us to address long-standing feature requests much more easily. By basing these controllers on modern Kubernetes tooling ( controller-runtime libraries), they can be dynamically configured with Kubernetes custom resources either by cluster admins or by other automated tools -- and you get greatly increased observability. This gave us the opportunity to build the GitOps Toolkit with the top Flux feature requests in mind: Supporting multiple source Git repositories Operational insight through health checks, events and alerts Multi-tenancy capabilities, like applying each source repository with its own set of permissions On top of that, testing the GitOps Toolkit and understanding the codebase becomes a lot easier. What are significant new differences between Flux v1 and the GitOps Toolkit? \u00b6 Reconciliation \u00b6 Flux v1 Toolkit component driven \"Flux v2\" Limited to a single Git repository Multiple Git repositories Declarative config via arguments in the Flux deployment GitRepository custom resource, which produces an artifact which can be reconciled by other controllers Follow HEAD of Git branches Supports Git branches, pinning on commits and tags, follow SemVer tag ranges Suspending of reconciliation by downscaling Flux deployment Reconciliation can be paused per resource by suspending the GitRepository Credentials config via Arguments and/or Secret volume mounts in the Flux pod Credentials config per GitRepository resource: SSH private key, HTTP/S username/password/token, OpenPGP public keys kustomize support \u00b6 Flux v1 Toolkit component driven \"Flux v2\" Declarative config through .flux.yaml files in the Git repository Declarative config through a Kustomization custom resource, consuming the artifact from the GitRepository Manifests are generated via shell exec and then reconciled by fluxd Generation, server-side validation, and reconciliation is handled by a specialised kustomize-controller Reconciliation using the service account of the Flux deployment Support for service account impersonation Garbage collection needs cluster role binding for Flux to query the Kubernetes discovery API Garbage collection needs no cluster role binding or access to Kubernetes discovery API Support for custom commands and generators executed by fluxd in a POSIX shell No support for custom commands Helm integration \u00b6 Flux v1 Toolkit component driven \"Flux v2\" Declarative config in a single Helm custom resource Declarative config through HelmRepository , GitRepository , HelmChart and HelmRelease custom resources Chart synchronisation embedded in the operator Extensive release configuration options, and a reconciliation interval per source Support for fixed SemVer versions from Helm repositories Support for SemVer ranges for HelmChart resources Git repository synchronisation on a global interval Planned support for charts from GitRepository sources Limited observability via the status object of the HelmRelease resource Better observability via the HelmRelease status object, Kubernetes events, and notifications Resource heavy, relatively slow Better performance Chart changes from Git sources are determined from Git metadata Chart changes must be accompanied by a version bump in Chart.yaml to produce a new artifact Chart dependencies for charts from Git sources are downloaded by the operator Chart dependencies must be committed to Git Notifications, webhooks, observability \u00b6 Flux v1 Toolkit component driven \"Flux v2\" Emits \"custom Flux events\" to a webhook endpoint Emits Kubernetes events for all custom resources part of the Toolkit RPC endpoint can be configured to a 3rd party solution like FluxCloud to be forwarded as notifications to e.g. Slack Toolkit components can be configured to POST the events to a notification-controller endpoint. Selective forwarding of POSTed events as notifications using Provider and Alert custom resources. Webhook receiver is a side-project Webhook receiver, handling a wide range of platforms, is included Unstructured logging Structured logging for all components Custom Prometheus metrics Generic / common controller-runtime Prometheus metrics How can I get involved? \u00b6 There are a variety of ways and we look forward to having you on board building the future of GitOps together: Discuss the direction of the GitOps Toolkit with us Join us in #flux-dev on the CNCF Slack Check out our contributor docs Take a look at the roadmap of the GitOps Toolkit Are there any breaking changes? \u00b6 In Flux v1 Kustomize support was implemented through .flux.yaml files in the Git repository. As indicated in the comparison table above, while this approach worked, we found it to be error-prone and hard to debug. The new Kustomization CR should make troubleshooting much easier. Unfortunately we needed to drop the support for custom commands as running arbitrary shell scripts in-cluster poses serious security concerns. Helm users: we redesigned the HelmRelease API and the automation will work quite differently, so upgrading to HelmRelease v2 will require a little work from you, but you will gain more flexibility, better observability and performance. Is the GitOps Toolkit related to the GitOps Engine? \u00b6 In an announcement in August 2019, the expectation was set that the Flux project would integrate the GitOps Engine, then being factored out of ArgoCD. Since the result would be backward-incompatible, it would require a major version bump: Flux v2. After experimentation and considerable thought, we (the maintainers) have found a path to Flux v2 that we think better serves our vision of GitOps: the GitOps Toolkit. In consequence, we do not now plan to integrate GitOps Engine into Flux.","title":"FAQ"},{"location":"faq/#frequently-asked-questions","text":"","title":"Frequently asked questions"},{"location":"faq/#general-questions","text":"","title":"General questions"},{"location":"faq/#what-does-the-gitops-toolkit-mean-for-flux","text":"Flux v1 is a monolithic do-it-all operator; the GitOps Toolkit separates the functionalities into specialized controllers. Flux v2 will be a curated configuration of the GitOps Toolkit, which you can install and operate simply using the gotk command. You can easily pick and choose the functionality you need and extend it to serve your own purposes. The timeline we are looking at right now is: Put Flux v1 into maintenance mode (no new features being added; bugfixes and CVEs patched only). Continue work on GitOps Toolkit roadmap . We will provide transition guides for specific user groups, e.g. users of Flux v1 in read-only mode, or of Helm Operator v1, etc. once the functionality is integrated in the GitOps Toolkit and it's deemed \"ready\". Once the use-cases of Flux v1 are covered, we will continue supporting Flux v1 for 6 months. This will be the transition period before it's considered unsupported.","title":"What does the GitOps Toolkit mean for Flux?"},{"location":"faq/#why-did-you-rewrite-flux","text":"The GitOps Toolkit implements its functionality in individual controllers, which allowed us to address long-standing feature requests much more easily. By basing these controllers on modern Kubernetes tooling ( controller-runtime libraries), they can be dynamically configured with Kubernetes custom resources either by cluster admins or by other automated tools -- and you get greatly increased observability. This gave us the opportunity to build the GitOps Toolkit with the top Flux feature requests in mind: Supporting multiple source Git repositories Operational insight through health checks, events and alerts Multi-tenancy capabilities, like applying each source repository with its own set of permissions On top of that, testing the GitOps Toolkit and understanding the codebase becomes a lot easier.","title":"Why did you rewrite Flux?"},{"location":"faq/#what-are-significant-new-differences-between-flux-v1-and-the-gitops-toolkit","text":"","title":"What are significant new differences between Flux v1 and the GitOps Toolkit?"},{"location":"faq/#reconciliation","text":"Flux v1 Toolkit component driven \"Flux v2\" Limited to a single Git repository Multiple Git repositories Declarative config via arguments in the Flux deployment GitRepository custom resource, which produces an artifact which can be reconciled by other controllers Follow HEAD of Git branches Supports Git branches, pinning on commits and tags, follow SemVer tag ranges Suspending of reconciliation by downscaling Flux deployment Reconciliation can be paused per resource by suspending the GitRepository Credentials config via Arguments and/or Secret volume mounts in the Flux pod Credentials config per GitRepository resource: SSH private key, HTTP/S username/password/token, OpenPGP public keys","title":"Reconciliation"},{"location":"faq/#kustomize-support","text":"Flux v1 Toolkit component driven \"Flux v2\" Declarative config through .flux.yaml files in the Git repository Declarative config through a Kustomization custom resource, consuming the artifact from the GitRepository Manifests are generated via shell exec and then reconciled by fluxd Generation, server-side validation, and reconciliation is handled by a specialised kustomize-controller Reconciliation using the service account of the Flux deployment Support for service account impersonation Garbage collection needs cluster role binding for Flux to query the Kubernetes discovery API Garbage collection needs no cluster role binding or access to Kubernetes discovery API Support for custom commands and generators executed by fluxd in a POSIX shell No support for custom commands","title":"kustomize support"},{"location":"faq/#helm-integration","text":"Flux v1 Toolkit component driven \"Flux v2\" Declarative config in a single Helm custom resource Declarative config through HelmRepository , GitRepository , HelmChart and HelmRelease custom resources Chart synchronisation embedded in the operator Extensive release configuration options, and a reconciliation interval per source Support for fixed SemVer versions from Helm repositories Support for SemVer ranges for HelmChart resources Git repository synchronisation on a global interval Planned support for charts from GitRepository sources Limited observability via the status object of the HelmRelease resource Better observability via the HelmRelease status object, Kubernetes events, and notifications Resource heavy, relatively slow Better performance Chart changes from Git sources are determined from Git metadata Chart changes must be accompanied by a version bump in Chart.yaml to produce a new artifact Chart dependencies for charts from Git sources are downloaded by the operator Chart dependencies must be committed to Git","title":"Helm integration"},{"location":"faq/#notifications-webhooks-observability","text":"Flux v1 Toolkit component driven \"Flux v2\" Emits \"custom Flux events\" to a webhook endpoint Emits Kubernetes events for all custom resources part of the Toolkit RPC endpoint can be configured to a 3rd party solution like FluxCloud to be forwarded as notifications to e.g. Slack Toolkit components can be configured to POST the events to a notification-controller endpoint. Selective forwarding of POSTed events as notifications using Provider and Alert custom resources. Webhook receiver is a side-project Webhook receiver, handling a wide range of platforms, is included Unstructured logging Structured logging for all components Custom Prometheus metrics Generic / common controller-runtime Prometheus metrics","title":"Notifications, webhooks, observability"},{"location":"faq/#how-can-i-get-involved","text":"There are a variety of ways and we look forward to having you on board building the future of GitOps together: Discuss the direction of the GitOps Toolkit with us Join us in #flux-dev on the CNCF Slack Check out our contributor docs Take a look at the roadmap of the GitOps Toolkit","title":"How can I get involved?"},{"location":"faq/#are-there-any-breaking-changes","text":"In Flux v1 Kustomize support was implemented through .flux.yaml files in the Git repository. As indicated in the comparison table above, while this approach worked, we found it to be error-prone and hard to debug. The new Kustomization CR should make troubleshooting much easier. Unfortunately we needed to drop the support for custom commands as running arbitrary shell scripts in-cluster poses serious security concerns. Helm users: we redesigned the HelmRelease API and the automation will work quite differently, so upgrading to HelmRelease v2 will require a little work from you, but you will gain more flexibility, better observability and performance.","title":"Are there any breaking changes?"},{"location":"faq/#is-the-gitops-toolkit-related-to-the-gitops-engine","text":"In an announcement in August 2019, the expectation was set that the Flux project would integrate the GitOps Engine, then being factored out of ArgoCD. Since the result would be backward-incompatible, it would require a major version bump: Flux v2. After experimentation and considerable thought, we (the maintainers) have found a path to Flux v2 that we think better serves our vision of GitOps: the GitOps Toolkit. In consequence, we do not now plan to integrate GitOps Engine into Flux.","title":"Is the GitOps Toolkit related to the GitOps Engine?"},{"location":"get-started/","text":"Get started with GitOps Toolkit \u00b6 Prerequisites \u00b6 You will need two Kubernetes clusters version 1.16 or newer and kubectl version 1.18. For a quick local test, you can use Kubernetes kind . Any other Kubernetes setup will work as well though. In order to follow the guide you'll need a GitHub account and a personal access token that can create repositories (check all permissions under repo ). Export your GitHub personal access token and username: export GITHUB_TOKEN = <your-token> export GITHUB_USER = <your-username> Install the toolkit CLI \u00b6 To install the latest gotk release on MacOS and Linux using Homebrew run: brew tap fluxcd/tap brew install gotk Or install gotk by downloading precompiled binaries using a Bash script: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash The install script downloads the gotk binary to /usr/local/bin . Binaries for macOS and Linux AMD64/ARM are available for download on the release page . To configure your shell to load gotk completions add to your Bash profile: # ~/.bashrc or ~/.bash_profile . < ( gotk completion bash ) zsh , fish , and powershell are also supported with their own sub-commands. GitOps workflow \u00b6 You'll be using a dedicated Git repository e.g. fleet-infra to manage one or more Kubernetes clusters. This guide assumes that you have two clusters, one for staging and one for production. Using the toolkit CLI you'll do the following: configure each cluster to synchronise with a directory inside the fleet repository register app sources (git repositories) that contain plain Kubernetes manifests or Kustomize overlays configure app deployments on both clusters (pre-releases on staging, semver releases on production) Staging bootstrap \u00b6 Create the staging cluster using Kubernetes kind or set the kubectl context to an existing cluster: kind create cluster --name staging kubectl cluster-info --context kind-staging Verify that your staging cluster satisfies the prerequisites with: $ gotk check --pre \u25ba checking prerequisites \u2714 kubectl 1.18.3 >=1.18.0 \u2714 kubernetes 1.18.2 >=1.16.0 \u2714 prerequisites checks passed Run the bootstrap command: gotk bootstrap github \\ --owner = $GITHUB_USER \\ --repository = fleet-infra \\ --branch = main \\ --path = staging-cluster \\ --personal The bootstrap command creates a repository if one doesn't exist and commits the toolkit components manifests to the default branch at the specified path. Then it configures the target cluster to synchronize with the specified path inside the repository. If you wish to create the repository under a GitHub organization: gotk bootstrap github \\ --owner = <organization> \\ --repository = <repo-name> \\ --branch = <organization default branch> \\ --team = <team1-slug> \\ --team = <team2-slug> \\ --path = staging-cluster Example output: $ gotk bootstrap github --owner=gitopsrun --repository=fleet-infra --path=staging-cluster --team=devs \u25ba connecting to github.com \u2714 repository created \u2714 devs team access granted \u2714 repository cloned \u271a generating manifests \u2714 components manifests pushed \u25ba installing components in gotk-system namespace deployment \"source-controller\" successfully rolled out deployment \"kustomize-controller\" successfully rolled out deployment \"notification-controller\" successfully rolled out \u2714 install completed \u25ba configuring deploy key \u2714 deploy key configured \u25ba generating sync manifests \u2714 sync manifests pushed \u25ba applying sync manifests \u25ce waiting for cluster sync \u2714 bootstrap finished If you prefer GitLab, export GITLAB_TOKEN env var and use the command gotk bootstrap gitlab . Idempotency It is safe to run the bootstrap command as many times as you want. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. You can target a specific toolkit version with gotk bootstrap --version=<semver> . Staging workflow \u00b6 Clone the repository with: git clone https://github.com/ $GITHUB_USER /fleet-infra cd fleet-infra Create a git source pointing to a public repository master branch: gotk create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --branch = master \\ --interval = 30s \\ --export > ./staging-cluster/webapp-source.yaml Create a kustomization for synchronizing the common manifests on the cluster: gotk create kustomization webapp-common \\ --source = webapp \\ --path = \"./deploy/webapp/common\" \\ --prune = true \\ --validation = client \\ --interval = 1h \\ --export > ./staging-cluster/webapp-common.yaml Create a kustomization for the backend service that depends on common: gotk create kustomization webapp-backend \\ --depends-on = webapp-common \\ --source = webapp \\ --path = \"./deploy/webapp/backend\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/backend.webapp\" \\ --health-check-timeout = 2m \\ --export > ./staging-cluster/webapp-backend.yaml Create a kustomization for the frontend service that depends on backend: gotk create kustomization webapp-frontend \\ --depends-on = webapp-backend \\ --source = webapp \\ --path = \"./deploy/webapp/frontend\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/frontend.webapp\" \\ --health-check-timeout = 2m \\ --export > ./staging-cluster/webapp-frontend.yaml Push changes to origin: git add -A && git commit -m \"add staging webapp\" && git push In about 30s the synchronization should start: $ watch gotk get kustomizations \u2714 gotk-system last applied revision master/35d5765a1acb9e9ce66cad7274c6fe03eee1e8eb \u2714 webapp-backend reconciling \u2714 webapp-common last applied revision master/f43f9b2eb6766e07f318d266a99d2ec7c940b0cf \u2717 webapp-frontend dependency 'gotk-system/webapp-backend' is not ready When the synchronization finishes you can check that the webapp services are running: $ kubectl -n webapp get deployments,services NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/backend 1/1 1 1 4m1s deployment.apps/frontend 1/1 1 1 3m31s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/backend ClusterIP 10.52.10.22 <none> 9898/TCP,9999/TCP 4m1s service/frontend ClusterIP 10.52.9.85 <none> 80/TCP 3m31s Tip From this moment forward, any changes made to the webapp Kubernetes manifests in the master branch will be synchronised with the staging cluster. If a Kubernetes manifest is removed from the webapp repository, the reconciler will remove it from your cluster. If you delete a kustomization from the fleet-infra repo, the reconciler will remove all Kubernetes objects that were previously applied from that kustomization. If you alter the webapp deployment using kubectl edit , the changes will be reverted to match the state described in git. When dealing with an incident, you can pause the reconciliation of a kustomization with gotk suspend kustomization <name> . Once the debugging session is over, you can re-enable the reconciliation with gotk resume kustomization <name> . Production bootstrap \u00b6 On production clusters, you may wish to deploy stable releases of an application. When creating a git source instead of a branch, you can specify a git tag or a semver expression. Create the production cluster using Kubernetes kind or set the kubectl context to an existing cluster: kind create cluster --name production kubectl cluster-info --context kind-production Run the bootstrap for the production environment: gotk bootstrap github \\ --owner = $GITHUB_USER \\ --repository = fleet-infra \\ --path = prod-cluster \\ --personal Pull the changes locally: git pull Production workflow \u00b6 Create a git source using a semver range to target stable releases: gotk create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0 <4.0.2\" \\ --interval = 30s \\ --export > ./prod-cluster/webapp-source.yaml Create a kustomization for webapp pointing to the production overlay: gotk create kustomization webapp \\ --source = webapp \\ --path = \"./deploy/overlays/production\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/frontend.production\" \\ --health-check = \"Deployment/backend.production\" \\ --health-check-timeout = 2m \\ --export > ./prod-cluster/webapp-production.yaml Push changes to origin: git add -A && git commit -m \"add prod webapp\" && git push List git sources: $ gotk get sources git \u2714 gotk-system last fetched revision master/99072ee132abdead8b7799d7891eae2f524eb73d \u2714 webapp last fetched revision 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 The kubectl equivalent is kubectl -n gotk-system get gitrepositories . List kustomization: $ gotk get kustomizations \u2714 gotk-system last applied revision master/99072ee132abdead8b7799d7891eae2f524eb73d \u2714 webapp last applied revision 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 The kubectl equivalent is kubectl -n gotk-system get kustomizations . If you want to upgrade to the latest 4.x version, you can change the semver expression to: gotk create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0 <5.0.0\" \\ --interval = 30s \\ --export > ./prod-cluster/webapp-source.yaml git add -A && git commit -m \"update prod webapp\" && git push Trigger a git sync: $ gotk reconcile ks gotk-system --with-source \u25ba annotating source gotk-system \u2714 source annotated \u25ce waiting for reconcilitation \u2714 git reconciliation completed \u2714 fetched revision master/d751ea264d48bf0db8b588d1d08184834ac8fec9 \u25ce waiting for kustomization reconcilitation \u2714 kustomization reconcilitation completed \u2714 applied revision master/d751ea264d48bf0db8b588d1d08184834ac8fec9 The kubectl equivalent is kubectl -n gotk-system annotate gitrepository/gotk-system fluxcd.io/reconcileAt=\"$(date +%s)\" . Wait for the webapp to be upgraded: $ watch gotk get kustomizations \u2714 gotk-system last applied revision master/d751ea264d48bf0db8b588d1d08184834ac8fec9 \u2714 webapp last applied revision 4.0.5/f43f9b2eb6766e07f318d266a99d2ec7c940b0cf","title":"Get Started"},{"location":"get-started/#get-started-with-gitops-toolkit","text":"","title":"Get started with GitOps Toolkit"},{"location":"get-started/#prerequisites","text":"You will need two Kubernetes clusters version 1.16 or newer and kubectl version 1.18. For a quick local test, you can use Kubernetes kind . Any other Kubernetes setup will work as well though. In order to follow the guide you'll need a GitHub account and a personal access token that can create repositories (check all permissions under repo ). Export your GitHub personal access token and username: export GITHUB_TOKEN = <your-token> export GITHUB_USER = <your-username>","title":"Prerequisites"},{"location":"get-started/#install-the-toolkit-cli","text":"To install the latest gotk release on MacOS and Linux using Homebrew run: brew tap fluxcd/tap brew install gotk Or install gotk by downloading precompiled binaries using a Bash script: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash The install script downloads the gotk binary to /usr/local/bin . Binaries for macOS and Linux AMD64/ARM are available for download on the release page . To configure your shell to load gotk completions add to your Bash profile: # ~/.bashrc or ~/.bash_profile . < ( gotk completion bash ) zsh , fish , and powershell are also supported with their own sub-commands.","title":"Install the toolkit CLI"},{"location":"get-started/#gitops-workflow","text":"You'll be using a dedicated Git repository e.g. fleet-infra to manage one or more Kubernetes clusters. This guide assumes that you have two clusters, one for staging and one for production. Using the toolkit CLI you'll do the following: configure each cluster to synchronise with a directory inside the fleet repository register app sources (git repositories) that contain plain Kubernetes manifests or Kustomize overlays configure app deployments on both clusters (pre-releases on staging, semver releases on production)","title":"GitOps workflow"},{"location":"get-started/#staging-bootstrap","text":"Create the staging cluster using Kubernetes kind or set the kubectl context to an existing cluster: kind create cluster --name staging kubectl cluster-info --context kind-staging Verify that your staging cluster satisfies the prerequisites with: $ gotk check --pre \u25ba checking prerequisites \u2714 kubectl 1.18.3 >=1.18.0 \u2714 kubernetes 1.18.2 >=1.16.0 \u2714 prerequisites checks passed Run the bootstrap command: gotk bootstrap github \\ --owner = $GITHUB_USER \\ --repository = fleet-infra \\ --branch = main \\ --path = staging-cluster \\ --personal The bootstrap command creates a repository if one doesn't exist and commits the toolkit components manifests to the default branch at the specified path. Then it configures the target cluster to synchronize with the specified path inside the repository. If you wish to create the repository under a GitHub organization: gotk bootstrap github \\ --owner = <organization> \\ --repository = <repo-name> \\ --branch = <organization default branch> \\ --team = <team1-slug> \\ --team = <team2-slug> \\ --path = staging-cluster Example output: $ gotk bootstrap github --owner=gitopsrun --repository=fleet-infra --path=staging-cluster --team=devs \u25ba connecting to github.com \u2714 repository created \u2714 devs team access granted \u2714 repository cloned \u271a generating manifests \u2714 components manifests pushed \u25ba installing components in gotk-system namespace deployment \"source-controller\" successfully rolled out deployment \"kustomize-controller\" successfully rolled out deployment \"notification-controller\" successfully rolled out \u2714 install completed \u25ba configuring deploy key \u2714 deploy key configured \u25ba generating sync manifests \u2714 sync manifests pushed \u25ba applying sync manifests \u25ce waiting for cluster sync \u2714 bootstrap finished If you prefer GitLab, export GITLAB_TOKEN env var and use the command gotk bootstrap gitlab . Idempotency It is safe to run the bootstrap command as many times as you want. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. You can target a specific toolkit version with gotk bootstrap --version=<semver> .","title":"Staging bootstrap"},{"location":"get-started/#staging-workflow","text":"Clone the repository with: git clone https://github.com/ $GITHUB_USER /fleet-infra cd fleet-infra Create a git source pointing to a public repository master branch: gotk create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --branch = master \\ --interval = 30s \\ --export > ./staging-cluster/webapp-source.yaml Create a kustomization for synchronizing the common manifests on the cluster: gotk create kustomization webapp-common \\ --source = webapp \\ --path = \"./deploy/webapp/common\" \\ --prune = true \\ --validation = client \\ --interval = 1h \\ --export > ./staging-cluster/webapp-common.yaml Create a kustomization for the backend service that depends on common: gotk create kustomization webapp-backend \\ --depends-on = webapp-common \\ --source = webapp \\ --path = \"./deploy/webapp/backend\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/backend.webapp\" \\ --health-check-timeout = 2m \\ --export > ./staging-cluster/webapp-backend.yaml Create a kustomization for the frontend service that depends on backend: gotk create kustomization webapp-frontend \\ --depends-on = webapp-backend \\ --source = webapp \\ --path = \"./deploy/webapp/frontend\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/frontend.webapp\" \\ --health-check-timeout = 2m \\ --export > ./staging-cluster/webapp-frontend.yaml Push changes to origin: git add -A && git commit -m \"add staging webapp\" && git push In about 30s the synchronization should start: $ watch gotk get kustomizations \u2714 gotk-system last applied revision master/35d5765a1acb9e9ce66cad7274c6fe03eee1e8eb \u2714 webapp-backend reconciling \u2714 webapp-common last applied revision master/f43f9b2eb6766e07f318d266a99d2ec7c940b0cf \u2717 webapp-frontend dependency 'gotk-system/webapp-backend' is not ready When the synchronization finishes you can check that the webapp services are running: $ kubectl -n webapp get deployments,services NAME READY UP-TO-DATE AVAILABLE AGE deployment.apps/backend 1/1 1 1 4m1s deployment.apps/frontend 1/1 1 1 3m31s NAME TYPE CLUSTER-IP EXTERNAL-IP PORT(S) AGE service/backend ClusterIP 10.52.10.22 <none> 9898/TCP,9999/TCP 4m1s service/frontend ClusterIP 10.52.9.85 <none> 80/TCP 3m31s Tip From this moment forward, any changes made to the webapp Kubernetes manifests in the master branch will be synchronised with the staging cluster. If a Kubernetes manifest is removed from the webapp repository, the reconciler will remove it from your cluster. If you delete a kustomization from the fleet-infra repo, the reconciler will remove all Kubernetes objects that were previously applied from that kustomization. If you alter the webapp deployment using kubectl edit , the changes will be reverted to match the state described in git. When dealing with an incident, you can pause the reconciliation of a kustomization with gotk suspend kustomization <name> . Once the debugging session is over, you can re-enable the reconciliation with gotk resume kustomization <name> .","title":"Staging workflow"},{"location":"get-started/#production-bootstrap","text":"On production clusters, you may wish to deploy stable releases of an application. When creating a git source instead of a branch, you can specify a git tag or a semver expression. Create the production cluster using Kubernetes kind or set the kubectl context to an existing cluster: kind create cluster --name production kubectl cluster-info --context kind-production Run the bootstrap for the production environment: gotk bootstrap github \\ --owner = $GITHUB_USER \\ --repository = fleet-infra \\ --path = prod-cluster \\ --personal Pull the changes locally: git pull","title":"Production bootstrap"},{"location":"get-started/#production-workflow","text":"Create a git source using a semver range to target stable releases: gotk create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0 <4.0.2\" \\ --interval = 30s \\ --export > ./prod-cluster/webapp-source.yaml Create a kustomization for webapp pointing to the production overlay: gotk create kustomization webapp \\ --source = webapp \\ --path = \"./deploy/overlays/production\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/frontend.production\" \\ --health-check = \"Deployment/backend.production\" \\ --health-check-timeout = 2m \\ --export > ./prod-cluster/webapp-production.yaml Push changes to origin: git add -A && git commit -m \"add prod webapp\" && git push List git sources: $ gotk get sources git \u2714 gotk-system last fetched revision master/99072ee132abdead8b7799d7891eae2f524eb73d \u2714 webapp last fetched revision 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 The kubectl equivalent is kubectl -n gotk-system get gitrepositories . List kustomization: $ gotk get kustomizations \u2714 gotk-system last applied revision master/99072ee132abdead8b7799d7891eae2f524eb73d \u2714 webapp last applied revision 4.0.1/113360052b3153e439a0cf8de76b8e3d2a7bdf27 The kubectl equivalent is kubectl -n gotk-system get kustomizations . If you want to upgrade to the latest 4.x version, you can change the semver expression to: gotk create source git webapp \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0 <5.0.0\" \\ --interval = 30s \\ --export > ./prod-cluster/webapp-source.yaml git add -A && git commit -m \"update prod webapp\" && git push Trigger a git sync: $ gotk reconcile ks gotk-system --with-source \u25ba annotating source gotk-system \u2714 source annotated \u25ce waiting for reconcilitation \u2714 git reconciliation completed \u2714 fetched revision master/d751ea264d48bf0db8b588d1d08184834ac8fec9 \u25ce waiting for kustomization reconcilitation \u2714 kustomization reconcilitation completed \u2714 applied revision master/d751ea264d48bf0db8b588d1d08184834ac8fec9 The kubectl equivalent is kubectl -n gotk-system annotate gitrepository/gotk-system fluxcd.io/reconcileAt=\"$(date +%s)\" . Wait for the webapp to be upgraded: $ watch gotk get kustomizations \u2714 gotk-system last applied revision master/d751ea264d48bf0db8b588d1d08184834ac8fec9 \u2714 webapp last applied revision 4.0.5/f43f9b2eb6766e07f318d266a99d2ec7c940b0cf","title":"Production workflow"},{"location":"guides/helmreleases/","text":"Manage Helm Releases \u00b6 The helm-controller allows you to declaratively manage Helm chart releases with Kubernetes manifests. It makes use of the artifacts produced by the source-controller from HelmRepository , GitRepository , and HelmChart resources. The helm-controller is part of the default toolkit installation. Prerequisites \u00b6 To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . Define a chart source \u00b6 To be able to release a Helm chart, the source that contains the chart (either a HelmRepository or GitRepository ) has to be known first to the source-controller, so that the HelmRelease can reference to it. A cluster administrator should register trusted sources by creating the resources in the gotk-system namespace. By default, the source-controller watches for sources only in the gotk-system namespace, this way cluster admins can prevent untrusted sources from being registered by users. Helm repository \u00b6 Helm repositories are the recommended source to retrieve Helm charts from, as they are lightweight in processing and make it possible to configure a semantic version selector for the chart version that should be released. They can be declared by creating a HelmRepository resource, the source-controller will fetch the Helm repository index for this resource on an interval and expose it as an artifact: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmRepository metadata : name : podinfo namespace : gotk-system spec : interval : 1m url : https://stefanprodan.github.io/podinfo The interval defines at which interval the Helm repository index is fetched, and should be at least 1m . Setting this to a higher value means newer chart versions will be detected at a slower pace, a push-based fetch can be introduced using webhook receivers The url can be any HTTP/S Helm repository URL. Authentication HTTP/S basic and TLS authentication can be configured for private Helm repositories. See the HelmRepository CRD docs for more details. Git repository \u00b6 Charts from Git repositories can be released by declaring a GitRepository , the source-controller will fetch the contents of the repository on an interval and expose it as an artifact. The source-controller can build and expose Helm charts as artifacts from the contents of the GitRepository artifact (more about this later on in the guide). There are two caveats you should be aware of: To make the source-controller produce a new chart artifact, the version in the Chart.yaml of the chart must be bumped. Chart dependencies must be committed to Git, as the source-controller does not attempt to download them. This limitation may be removed in a future release. An example GitRepository : apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo namespace : gotk-system spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master ignore : | # exclude all /* # include charts directory !/charts/ The interval defines at which interval the Git repository contents are fetched, and should be at least 1m . Setting this to a higher value means newer chart versions will be detected at a slower pace, a push-based fetch can be introduced using webhook receivers The url can be any HTTP/S or SSH address (the latter requiring authentication). The ref defines the checkout strategy, and is set to follow the master branch in the above example. For other strategies like tags or commits, see the GitRepository CRD docs . The ignore defines file and folder exclusion for the artifact produced, and follows the .gitignore pattern format . The above example only includes the charts directory of the repository and omits all other files. Authentication HTTP/S basic and SSH authentication can be configured for private Git repositories. See the GitRepository CRD docs for more details. Define a Helm release \u00b6 With the chart source created, define a new HelmRelease to release the Helm chart: apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : podinfo namespace : default spec : interval : 5m chart : spec : chart : <name|path> version : '4.0.x' sourceRef : kind : <HelmRepository|GitRepository> name : podinfo namespace : gotk-system interval : 1m values : replicaCount : 2 The chart.spec values are used by the helm-controller as a template to create a new HelmChart resource in the same namespace as the sourceRef . The source-controller will then lookup the chart in the artifact of the referenced source, and either fetch the chart for a HelmRepository , or build it from a GitRepository . It will then make it available as a HelmChart artifact to be used by the helm-controller. The chart.spec.chart can either contain: The name of the chart as made available by the HelmRepository (without any aliases), for example: podinfo The relative path the chart can be found at in the GitRepository , for example: ./charts/podinfo The chart.spec.version can be a fixed semver, or any semver range (i.e. >=4.0.0 <5.0.0 ). It is ignored for HelmRelease resources that reference a GitRepository source. Advanced configuration The HelmRelease offers an extensive set of configurable flags for finer grain control over how Helm actions are performed. See the HelmRelease CRD docs for more details. Refer to values in ConfigMap and Secret resources \u00b6 It is possible to define a list of ConfigMap and Secret resources from which to take values. The values are merged in the order given, with the later values overwriting earlier. These values always have a lower priority than the values inlined in the HelmRelease via the spec.values parameter. spec : valuesFrom : - kind : ConfigMap name : prod-env-values valuesKey : values-prod.yaml - kind : Secret name : prod-tls-values valuesKey : crt targetPath : tls.crt The definition of the listed keys is as follows: kind : Kind of the values referent ( ConfigMap or Secret ). name : Name of the values referent, in the same namespace as the HelmRelease . valuesKey (Optional) : The data key where the values.yaml or a specific value can be found. Defaults to values.yaml when omitted. targetPath (Optional) : The YAML dot notation path at which the value should be merged. When set, the valuesKey is expected to be a single flat value. Defaults to None when omitted, which results in the values getting merged at the root. Note The targetPath supports the same formatting as you would supply as an argument to the helm binary using --set [path]=[value] . In addition to this, the referred value can contain the same value formats (e.g. {a,b,c} for a list). You can read more about the available formats and limitations in the Helm documentation . Configure notifications \u00b6 The default toolkit installation configures the helm-controller to broadcast events to the notification-controller . To receive the events as notifications, a Provider needs to be setup first as described in the notifications guide . Once you have set up the Provider , create a new Alert resource in the gotk-system to start receiving notifications about the Helm release: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Alert metadata : generation : 2 name : helm-podinfo namespace : gotk-system spec : providerRef : name : slack eventSeverity : info eventSources : - kind : HelmRepository name : podinfo - kind : HelmChart name : default-podinfo - kind : HelmRelease name : podinfo namespace : default Configure webhook receivers \u00b6 When using semver ranges for Helm releases, you may want to trigger an update as soon as a new chart version is published to your Helm repository. In order to notify source-controller about a chart update, you can setup webhook receivers . First generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n gotk-system create secret generic webhook-token \\ --from-literal = token = $TOKEN When using Harbor as your Helm repository, you can define a receiver with: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : helm-podinfo namespace : gotk-system spec : type : harbor secretRef : name : webhook-token resources : - kind : HelmRepository name : podinfo The notification-controller generates a unique URL using the provided token and the receiver name/namespace. Find the URL with: $ kubectl -n gotk-system get receiver/helm-podinfo NAME READY STATUS helm-podinfo True Receiver initialised with URL: /hook/bed6d00b5555b1603e1f59b94d7fdbca58089cb5663633fb83f2815dc626d92b Log in to the Harbor interface, go to Projects, select a project, and select Webhooks. Fill the form with: Endpoint URL: compose the address using the receiver LB and the generated URL http://<LoadBalancerAddress>/<ReceiverURL> Auth Header: use the token string With the above settings, when you upload a chart, the following happens: Harbor sends the chart push event to the receiver address Notification controller validates the authenticity of the payload using the auth header Source controller is notified about the changes Source controller pulls the changes into the cluster and updates the HelmChart version Helm controller is notified about the version change and upgrades the release Note Besides Harbor, you can define receivers for GitHub , GitLab , Bitbucket and any other system that supports webhooks e.g. Jenkins, CircleCI, etc. See the Receiver CRD docs for more details.","title":"Manage Helm Releases"},{"location":"guides/helmreleases/#manage-helm-releases","text":"The helm-controller allows you to declaratively manage Helm chart releases with Kubernetes manifests. It makes use of the artifacts produced by the source-controller from HelmRepository , GitRepository , and HelmChart resources. The helm-controller is part of the default toolkit installation.","title":"Manage Helm Releases"},{"location":"guides/helmreleases/#prerequisites","text":"To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide .","title":"Prerequisites"},{"location":"guides/helmreleases/#define-a-chart-source","text":"To be able to release a Helm chart, the source that contains the chart (either a HelmRepository or GitRepository ) has to be known first to the source-controller, so that the HelmRelease can reference to it. A cluster administrator should register trusted sources by creating the resources in the gotk-system namespace. By default, the source-controller watches for sources only in the gotk-system namespace, this way cluster admins can prevent untrusted sources from being registered by users.","title":"Define a chart source"},{"location":"guides/helmreleases/#helm-repository","text":"Helm repositories are the recommended source to retrieve Helm charts from, as they are lightweight in processing and make it possible to configure a semantic version selector for the chart version that should be released. They can be declared by creating a HelmRepository resource, the source-controller will fetch the Helm repository index for this resource on an interval and expose it as an artifact: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmRepository metadata : name : podinfo namespace : gotk-system spec : interval : 1m url : https://stefanprodan.github.io/podinfo The interval defines at which interval the Helm repository index is fetched, and should be at least 1m . Setting this to a higher value means newer chart versions will be detected at a slower pace, a push-based fetch can be introduced using webhook receivers The url can be any HTTP/S Helm repository URL. Authentication HTTP/S basic and TLS authentication can be configured for private Helm repositories. See the HelmRepository CRD docs for more details.","title":"Helm repository"},{"location":"guides/helmreleases/#git-repository","text":"Charts from Git repositories can be released by declaring a GitRepository , the source-controller will fetch the contents of the repository on an interval and expose it as an artifact. The source-controller can build and expose Helm charts as artifacts from the contents of the GitRepository artifact (more about this later on in the guide). There are two caveats you should be aware of: To make the source-controller produce a new chart artifact, the version in the Chart.yaml of the chart must be bumped. Chart dependencies must be committed to Git, as the source-controller does not attempt to download them. This limitation may be removed in a future release. An example GitRepository : apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : podinfo namespace : gotk-system spec : interval : 1m url : https://github.com/stefanprodan/podinfo ref : branch : master ignore : | # exclude all /* # include charts directory !/charts/ The interval defines at which interval the Git repository contents are fetched, and should be at least 1m . Setting this to a higher value means newer chart versions will be detected at a slower pace, a push-based fetch can be introduced using webhook receivers The url can be any HTTP/S or SSH address (the latter requiring authentication). The ref defines the checkout strategy, and is set to follow the master branch in the above example. For other strategies like tags or commits, see the GitRepository CRD docs . The ignore defines file and folder exclusion for the artifact produced, and follows the .gitignore pattern format . The above example only includes the charts directory of the repository and omits all other files. Authentication HTTP/S basic and SSH authentication can be configured for private Git repositories. See the GitRepository CRD docs for more details.","title":"Git repository"},{"location":"guides/helmreleases/#define-a-helm-release","text":"With the chart source created, define a new HelmRelease to release the Helm chart: apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : podinfo namespace : default spec : interval : 5m chart : spec : chart : <name|path> version : '4.0.x' sourceRef : kind : <HelmRepository|GitRepository> name : podinfo namespace : gotk-system interval : 1m values : replicaCount : 2 The chart.spec values are used by the helm-controller as a template to create a new HelmChart resource in the same namespace as the sourceRef . The source-controller will then lookup the chart in the artifact of the referenced source, and either fetch the chart for a HelmRepository , or build it from a GitRepository . It will then make it available as a HelmChart artifact to be used by the helm-controller. The chart.spec.chart can either contain: The name of the chart as made available by the HelmRepository (without any aliases), for example: podinfo The relative path the chart can be found at in the GitRepository , for example: ./charts/podinfo The chart.spec.version can be a fixed semver, or any semver range (i.e. >=4.0.0 <5.0.0 ). It is ignored for HelmRelease resources that reference a GitRepository source. Advanced configuration The HelmRelease offers an extensive set of configurable flags for finer grain control over how Helm actions are performed. See the HelmRelease CRD docs for more details.","title":"Define a Helm release"},{"location":"guides/helmreleases/#refer-to-values-in-configmap-and-secret-resources","text":"It is possible to define a list of ConfigMap and Secret resources from which to take values. The values are merged in the order given, with the later values overwriting earlier. These values always have a lower priority than the values inlined in the HelmRelease via the spec.values parameter. spec : valuesFrom : - kind : ConfigMap name : prod-env-values valuesKey : values-prod.yaml - kind : Secret name : prod-tls-values valuesKey : crt targetPath : tls.crt The definition of the listed keys is as follows: kind : Kind of the values referent ( ConfigMap or Secret ). name : Name of the values referent, in the same namespace as the HelmRelease . valuesKey (Optional) : The data key where the values.yaml or a specific value can be found. Defaults to values.yaml when omitted. targetPath (Optional) : The YAML dot notation path at which the value should be merged. When set, the valuesKey is expected to be a single flat value. Defaults to None when omitted, which results in the values getting merged at the root. Note The targetPath supports the same formatting as you would supply as an argument to the helm binary using --set [path]=[value] . In addition to this, the referred value can contain the same value formats (e.g. {a,b,c} for a list). You can read more about the available formats and limitations in the Helm documentation .","title":"Refer to values in ConfigMap and Secret resources"},{"location":"guides/helmreleases/#configure-notifications","text":"The default toolkit installation configures the helm-controller to broadcast events to the notification-controller . To receive the events as notifications, a Provider needs to be setup first as described in the notifications guide . Once you have set up the Provider , create a new Alert resource in the gotk-system to start receiving notifications about the Helm release: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Alert metadata : generation : 2 name : helm-podinfo namespace : gotk-system spec : providerRef : name : slack eventSeverity : info eventSources : - kind : HelmRepository name : podinfo - kind : HelmChart name : default-podinfo - kind : HelmRelease name : podinfo namespace : default","title":"Configure notifications"},{"location":"guides/helmreleases/#configure-webhook-receivers","text":"When using semver ranges for Helm releases, you may want to trigger an update as soon as a new chart version is published to your Helm repository. In order to notify source-controller about a chart update, you can setup webhook receivers . First generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n gotk-system create secret generic webhook-token \\ --from-literal = token = $TOKEN When using Harbor as your Helm repository, you can define a receiver with: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : helm-podinfo namespace : gotk-system spec : type : harbor secretRef : name : webhook-token resources : - kind : HelmRepository name : podinfo The notification-controller generates a unique URL using the provided token and the receiver name/namespace. Find the URL with: $ kubectl -n gotk-system get receiver/helm-podinfo NAME READY STATUS helm-podinfo True Receiver initialised with URL: /hook/bed6d00b5555b1603e1f59b94d7fdbca58089cb5663633fb83f2815dc626d92b Log in to the Harbor interface, go to Projects, select a project, and select Webhooks. Fill the form with: Endpoint URL: compose the address using the receiver LB and the generated URL http://<LoadBalancerAddress>/<ReceiverURL> Auth Header: use the token string With the above settings, when you upload a chart, the following happens: Harbor sends the chart push event to the receiver address Notification controller validates the authenticity of the payload using the auth header Source controller is notified about the changes Source controller pulls the changes into the cluster and updates the HelmChart version Helm controller is notified about the version change and upgrades the release Note Besides Harbor, you can define receivers for GitHub , GitLab , Bitbucket and any other system that supports webhooks e.g. Jenkins, CircleCI, etc. See the Receiver CRD docs for more details.","title":"Configure webhook receivers"},{"location":"guides/installation/","text":"Installation \u00b6 This guide walks you through setting up the GitOps Toolkit to manage one or more Kubernetes clusters. Prerequisites \u00b6 You will need a Kubernetes cluster version 1.16 or newer and kubectl version 1.18 or newer. Install the toolkit CLI \u00b6 With Homebrew: brew tap fluxcd/tap brew install gotk With Bash: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash # enable completions in ~/.bash_profile . < ( gotk completion bash ) Command-line completion for zsh , fish , and powershell are also supported with their own sub-commands. Binaries for macOS and Linux AMD64/ARM are available for download on the release page . Verify that your cluster satisfies the prerequisites with: gotk check --pre Bootstrap \u00b6 Using the gotk bootstrap command you can install the toolkit on a Kubernetes cluster and configure it to manage itself from a Git repository. The bootstrap creates a Git repository if one doesn't exist and commits the toolkit components manifests to the main branch. Then it configures the target cluster to synchronize with that repository by setting up SSH deploy keys. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. The bootstrap is idempotent, it's safe to run the command as many times as you want. You can choose what components to install and for which cluster with: gotk bootstrap <GIT-PROVIDER> \\ --components = source-controller,kustomize-controller,helm-controller,notification-controller \\ --path = my-cluster \\ --version = latest ARM When deploying to a Kubernetes cluster with ARM architecture, you can use --arch=arm for ARMv7 32-bit container images and --arch=arm64 for ARMv8 64-bit container images. If you wish to install a specific version, use the toolkit release tag e.g. --version=v0.0.14 . With --path you can configure the directory which will be used to reconcile the target cluster. To control multiple clusters from the same Git repository, you have to set a unique path per cluster e.g. staging-cluster and production-cluster : \u251c\u2500\u2500 staging-cluster # <- path=staging-cluster \u2502 \u2514\u2500\u2500 gotk-system # <- namespace dir generated by bootstrap \u2502 \u251c\u2500\u2500 toolkit-components.yaml \u2502 \u251c\u2500\u2500 toolkit-kustomization.yaml \u2502 \u2514\u2500\u2500 toolkit-source.yaml \u2514\u2500\u2500 production-cluster # <- path=production-cluster \u2514\u2500\u2500 gotk-system Change the default branch If you wish to change the branch to something else than main, create the repository manually, push a branch to origin and then use gotk bootstrap <GIT-PROVIDER> --branch=your-branch . GitHub and GitHub Enterprise \u00b6 Generate a personal access token that can create repositories by checking all permissions under repo . Export your GitHub personal access token as an environment variable: export GITHUB_TOKEN = <your-token> Run the bootstrap for a repository on your personal GitHub account: gotk bootstrap github \\ --owner = my-github-username \\ --repository = my-repository \\ --path = my-cluster \\ --personal Run the bootstrap for a repository owned by a GitHub organization: gotk bootstrap github \\ --owner = my-github-organization \\ --repository = my-repository \\ --team = team1-slug \\ --team = team2-slug \\ --path = my-cluster When you specify a list of teams, those teams will be granted maintainer access to the repository. To run the bootstrap for a repository hosted on GitHub Enterprise, you have to specify your GitHub hostname: gotk bootstrap github \\ --hostname = my-github-enterprise.com \\ --owner = my-github-organization \\ --repository = my-repository \\ --branch = main \\ --path = my-cluster GitLab and GitLab Enterprise \u00b6 Generate a personal access token that grants complete read/write access to the GitLab API. Export your GitLab personal access token as an environment variable: export GITLAB_TOKEN = <your-token> Run the bootstrap for a repository on your personal GitLab account: gotk bootstrap gitlab \\ --owner = my-gitlab-username \\ --repository = my-repository \\ --branch = master \\ --path = my-cluster \\ --personal Run the bootstrap for a repository owned by a GitLab group: gotk bootstrap gitlab \\ --owner = my-gitlab-group \\ --repository = my-repository \\ --branch = master \\ --path = my-cluster To run the bootstrap for a repository hosted on GitLab on-prem or enterprise, you have to specify your GitLab hostname: gotk bootstrap gitlab \\ --hostname = my-gitlab.com \\ --owner = my-gitlab-group \\ --repository = my-repository \\ --branch = master \\ --path = my-cluster Generic Git Server \u00b6 For other Git providers such as Bitbucket, Gogs, Gitea, etc you can manually setup the repository and the deploy key. Create a Git repository and clone it locally: git clone ssh://<host>/<org>/my-repository cd my-repository Create a directory inside the repository: mkdir -p ./my-cluster/gotk-system Generate the toolkit manifests with: gotk install --version = latest \\ --arch = amd64 \\ # on ARM64/AARCH64 clusters use --arch=arm64 --export > ./my-cluster/gotk-system/toolkit-components.yaml If your cluster must pull images from a private container registry, first you should pull the toolkit images from GitHub Container Registry and push them to your registry, for example: docker pull ghcr.io/fluxcd/source-controller:v0.0.14 docker tag ghcr.io/fluxcd/source-controller:v0.0.14 registry.internal/fluxcd/source-controller:v0.0.14 docker push registry.internal/fluxcd/source-controller:v0.0.14 Create the pull secret in the gotk-system namespace: kubectl create ns gotk-system kubectl -n gotk-system create secret generic regcred \\ --from-file = .dockerconfigjson = /.docker/config.json \\ --type = kubernetes.io/dockerconfigjson Set your registry domain, and the pull secret when generating the manifests: gotk install --version = latest \\ --registry = registry.internal/fluxcd \\ --image-pull-secret = regcred \\ --export > ./my-cluster/gotk-system/toolkit-components.yaml Commit and push the manifest to the master branch: git add -A && git commit -m \"add toolkit manifests\" && git push Apply the manifests on your cluster: kubectl apply -f ./my-cluster/gotk-system/toolkit-components.yaml Verify that the toolkit controllers have started: gotk check Create a GitRepository object on your cluster by specifying the SSH address of your repo: gotk create source git gotk-system \\ --url = ssh://<host>/<org>/my-repository \\ --ssh-key-algorithm = ecdsa \\ --ssh-ecdsa-curve = p521 \\ --branch = master \\ --interval = 1m You will be prompted to add a deploy key to your repository. If you don't specify the SSH algorithm, then gotk will generate an RSA 2048 bits key. If your Git server supports basic auth, you can set the URL to HTTPS and specify the credentials with: gotk create source git gotk-system \\ --url = https://<host>/<org>/my-repository \\ --username = my-username \\ --password = my-password \\ --branch = master \\ --interval = 1m Create a Kustomization object on your cluster: gotk create kustomization gotk-system \\ --source = gotk-system \\ --path = \"./my-cluster\" \\ --prune = true \\ --interval = 10m Export both objects, commit and push the manifests to Git: gotk export source git gotk-system \\ > ./my-cluster/gotk-system/toolkit-source.yaml gotk export kustomization gotk-system \\ > ./my-cluster/gotk-system/toolkit-kustomization.yaml git add -A && git commit -m \"add toolkit reconciliation\" && git push To upgrade the toolkit to a newer version, run the install command and commit the changes: gotk install --version = latest \\ --export > ./my-cluster/gotk-system/toolkit-components.yaml git add -A && git commit -m \"update toolkit\" && git push The source-controller will pull the changes on the cluster, then the kustomize-controller will perform a rolling update of all toolkit components including itself. Dev install \u00b6 For testing purposes you can install the toolkit without storing its manifests in a Git repository. Here is the equivalent to fluxctl install : gotk install \\ --components = source-controller,kustomize-controller Then you can register Git repositories and reconcile them on your cluster: gotk create source git podinfo \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0\" \\ --interval = 1m gotk create kustomization podinfo-default \\ --source = podinfo \\ --path = \"./kustomize\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/podinfo.default\" \\ --health-check-timeout = 2m Here is the equivalent to helm install helm-operator : gotk install \\ --components = source-controller,kustomize-controller,helm-controller Then you can register Helm repositories and create Helm releases: gotk create source helm stable \\ --interval = 1h \\ --url = https://kubernetes-charts.storage.googleapis.com gotk create helmrelease sealed-secrets \\ --interval = 1h \\ --release-name = sealed-secrets \\ --target-namespace = gotk-system \\ --source = HelmRepository/stable \\ --chart = sealed-secrets \\ --chart-version = \"1.10.x\" Monitoring with Prometheus and Grafana \u00b6 The GitOps Toolkit comes with an optional monitoring stack. You can install the stack in the gotk-system namespace with: kustomize build github.com/fluxcd/toolkit/manifests/monitoring | kubectl apply -f- The monitoring stack is composed of: Prometheus server - collects metrics from the toolkit controllers and stores them for 2h Grafana dashboards - displays the control plane resource usage and reconciliation stats If you wish to use your own Prometheus and Grafana instances, then you can import the dashboards from GitHub . Hint Note that the toolkit controllers expose the /metrics endpoint on port 8080 . When using Prometheus Operator you should create PodMonitor objects to configure scraping. When Prometheus is running outside of the gotk-system namespace, you have to create a network policy that allows traffic on port 8080 from the namespace where Prometheus is deployed. Uninstall \u00b6 You can uninstall the toolkit components with: gotk uninstall --crds The above command will delete the toolkit custom resources definitions, the controllers and the namespace where they were installed.","title":"Installation"},{"location":"guides/installation/#installation","text":"This guide walks you through setting up the GitOps Toolkit to manage one or more Kubernetes clusters.","title":"Installation"},{"location":"guides/installation/#prerequisites","text":"You will need a Kubernetes cluster version 1.16 or newer and kubectl version 1.18 or newer.","title":"Prerequisites"},{"location":"guides/installation/#install-the-toolkit-cli","text":"With Homebrew: brew tap fluxcd/tap brew install gotk With Bash: curl -s https://toolkit.fluxcd.io/install.sh | sudo bash # enable completions in ~/.bash_profile . < ( gotk completion bash ) Command-line completion for zsh , fish , and powershell are also supported with their own sub-commands. Binaries for macOS and Linux AMD64/ARM are available for download on the release page . Verify that your cluster satisfies the prerequisites with: gotk check --pre","title":"Install the toolkit CLI"},{"location":"guides/installation/#bootstrap","text":"Using the gotk bootstrap command you can install the toolkit on a Kubernetes cluster and configure it to manage itself from a Git repository. The bootstrap creates a Git repository if one doesn't exist and commits the toolkit components manifests to the main branch. Then it configures the target cluster to synchronize with that repository by setting up SSH deploy keys. If the toolkit components are present on the cluster, the bootstrap command will perform an upgrade if needed. The bootstrap is idempotent, it's safe to run the command as many times as you want. You can choose what components to install and for which cluster with: gotk bootstrap <GIT-PROVIDER> \\ --components = source-controller,kustomize-controller,helm-controller,notification-controller \\ --path = my-cluster \\ --version = latest ARM When deploying to a Kubernetes cluster with ARM architecture, you can use --arch=arm for ARMv7 32-bit container images and --arch=arm64 for ARMv8 64-bit container images. If you wish to install a specific version, use the toolkit release tag e.g. --version=v0.0.14 . With --path you can configure the directory which will be used to reconcile the target cluster. To control multiple clusters from the same Git repository, you have to set a unique path per cluster e.g. staging-cluster and production-cluster : \u251c\u2500\u2500 staging-cluster # <- path=staging-cluster \u2502 \u2514\u2500\u2500 gotk-system # <- namespace dir generated by bootstrap \u2502 \u251c\u2500\u2500 toolkit-components.yaml \u2502 \u251c\u2500\u2500 toolkit-kustomization.yaml \u2502 \u2514\u2500\u2500 toolkit-source.yaml \u2514\u2500\u2500 production-cluster # <- path=production-cluster \u2514\u2500\u2500 gotk-system Change the default branch If you wish to change the branch to something else than main, create the repository manually, push a branch to origin and then use gotk bootstrap <GIT-PROVIDER> --branch=your-branch .","title":"Bootstrap"},{"location":"guides/installation/#github-and-github-enterprise","text":"Generate a personal access token that can create repositories by checking all permissions under repo . Export your GitHub personal access token as an environment variable: export GITHUB_TOKEN = <your-token> Run the bootstrap for a repository on your personal GitHub account: gotk bootstrap github \\ --owner = my-github-username \\ --repository = my-repository \\ --path = my-cluster \\ --personal Run the bootstrap for a repository owned by a GitHub organization: gotk bootstrap github \\ --owner = my-github-organization \\ --repository = my-repository \\ --team = team1-slug \\ --team = team2-slug \\ --path = my-cluster When you specify a list of teams, those teams will be granted maintainer access to the repository. To run the bootstrap for a repository hosted on GitHub Enterprise, you have to specify your GitHub hostname: gotk bootstrap github \\ --hostname = my-github-enterprise.com \\ --owner = my-github-organization \\ --repository = my-repository \\ --branch = main \\ --path = my-cluster","title":"GitHub and GitHub Enterprise"},{"location":"guides/installation/#gitlab-and-gitlab-enterprise","text":"Generate a personal access token that grants complete read/write access to the GitLab API. Export your GitLab personal access token as an environment variable: export GITLAB_TOKEN = <your-token> Run the bootstrap for a repository on your personal GitLab account: gotk bootstrap gitlab \\ --owner = my-gitlab-username \\ --repository = my-repository \\ --branch = master \\ --path = my-cluster \\ --personal Run the bootstrap for a repository owned by a GitLab group: gotk bootstrap gitlab \\ --owner = my-gitlab-group \\ --repository = my-repository \\ --branch = master \\ --path = my-cluster To run the bootstrap for a repository hosted on GitLab on-prem or enterprise, you have to specify your GitLab hostname: gotk bootstrap gitlab \\ --hostname = my-gitlab.com \\ --owner = my-gitlab-group \\ --repository = my-repository \\ --branch = master \\ --path = my-cluster","title":"GitLab and GitLab Enterprise"},{"location":"guides/installation/#generic-git-server","text":"For other Git providers such as Bitbucket, Gogs, Gitea, etc you can manually setup the repository and the deploy key. Create a Git repository and clone it locally: git clone ssh://<host>/<org>/my-repository cd my-repository Create a directory inside the repository: mkdir -p ./my-cluster/gotk-system Generate the toolkit manifests with: gotk install --version = latest \\ --arch = amd64 \\ # on ARM64/AARCH64 clusters use --arch=arm64 --export > ./my-cluster/gotk-system/toolkit-components.yaml If your cluster must pull images from a private container registry, first you should pull the toolkit images from GitHub Container Registry and push them to your registry, for example: docker pull ghcr.io/fluxcd/source-controller:v0.0.14 docker tag ghcr.io/fluxcd/source-controller:v0.0.14 registry.internal/fluxcd/source-controller:v0.0.14 docker push registry.internal/fluxcd/source-controller:v0.0.14 Create the pull secret in the gotk-system namespace: kubectl create ns gotk-system kubectl -n gotk-system create secret generic regcred \\ --from-file = .dockerconfigjson = /.docker/config.json \\ --type = kubernetes.io/dockerconfigjson Set your registry domain, and the pull secret when generating the manifests: gotk install --version = latest \\ --registry = registry.internal/fluxcd \\ --image-pull-secret = regcred \\ --export > ./my-cluster/gotk-system/toolkit-components.yaml Commit and push the manifest to the master branch: git add -A && git commit -m \"add toolkit manifests\" && git push Apply the manifests on your cluster: kubectl apply -f ./my-cluster/gotk-system/toolkit-components.yaml Verify that the toolkit controllers have started: gotk check Create a GitRepository object on your cluster by specifying the SSH address of your repo: gotk create source git gotk-system \\ --url = ssh://<host>/<org>/my-repository \\ --ssh-key-algorithm = ecdsa \\ --ssh-ecdsa-curve = p521 \\ --branch = master \\ --interval = 1m You will be prompted to add a deploy key to your repository. If you don't specify the SSH algorithm, then gotk will generate an RSA 2048 bits key. If your Git server supports basic auth, you can set the URL to HTTPS and specify the credentials with: gotk create source git gotk-system \\ --url = https://<host>/<org>/my-repository \\ --username = my-username \\ --password = my-password \\ --branch = master \\ --interval = 1m Create a Kustomization object on your cluster: gotk create kustomization gotk-system \\ --source = gotk-system \\ --path = \"./my-cluster\" \\ --prune = true \\ --interval = 10m Export both objects, commit and push the manifests to Git: gotk export source git gotk-system \\ > ./my-cluster/gotk-system/toolkit-source.yaml gotk export kustomization gotk-system \\ > ./my-cluster/gotk-system/toolkit-kustomization.yaml git add -A && git commit -m \"add toolkit reconciliation\" && git push To upgrade the toolkit to a newer version, run the install command and commit the changes: gotk install --version = latest \\ --export > ./my-cluster/gotk-system/toolkit-components.yaml git add -A && git commit -m \"update toolkit\" && git push The source-controller will pull the changes on the cluster, then the kustomize-controller will perform a rolling update of all toolkit components including itself.","title":"Generic Git Server"},{"location":"guides/installation/#dev-install","text":"For testing purposes you can install the toolkit without storing its manifests in a Git repository. Here is the equivalent to fluxctl install : gotk install \\ --components = source-controller,kustomize-controller Then you can register Git repositories and reconcile them on your cluster: gotk create source git podinfo \\ --url = https://github.com/stefanprodan/podinfo \\ --tag-semver = \">=4.0.0\" \\ --interval = 1m gotk create kustomization podinfo-default \\ --source = podinfo \\ --path = \"./kustomize\" \\ --prune = true \\ --validation = client \\ --interval = 10m \\ --health-check = \"Deployment/podinfo.default\" \\ --health-check-timeout = 2m Here is the equivalent to helm install helm-operator : gotk install \\ --components = source-controller,kustomize-controller,helm-controller Then you can register Helm repositories and create Helm releases: gotk create source helm stable \\ --interval = 1h \\ --url = https://kubernetes-charts.storage.googleapis.com gotk create helmrelease sealed-secrets \\ --interval = 1h \\ --release-name = sealed-secrets \\ --target-namespace = gotk-system \\ --source = HelmRepository/stable \\ --chart = sealed-secrets \\ --chart-version = \"1.10.x\"","title":"Dev install"},{"location":"guides/installation/#monitoring-with-prometheus-and-grafana","text":"The GitOps Toolkit comes with an optional monitoring stack. You can install the stack in the gotk-system namespace with: kustomize build github.com/fluxcd/toolkit/manifests/monitoring | kubectl apply -f- The monitoring stack is composed of: Prometheus server - collects metrics from the toolkit controllers and stores them for 2h Grafana dashboards - displays the control plane resource usage and reconciliation stats If you wish to use your own Prometheus and Grafana instances, then you can import the dashboards from GitHub . Hint Note that the toolkit controllers expose the /metrics endpoint on port 8080 . When using Prometheus Operator you should create PodMonitor objects to configure scraping. When Prometheus is running outside of the gotk-system namespace, you have to create a network policy that allows traffic on port 8080 from the namespace where Prometheus is deployed.","title":"Monitoring with Prometheus and Grafana"},{"location":"guides/installation/#uninstall","text":"You can uninstall the toolkit components with: gotk uninstall --crds The above command will delete the toolkit custom resources definitions, the controllers and the namespace where they were installed.","title":"Uninstall"},{"location":"guides/mozilla-sops/","text":"Manage Kubernetes secrets with Mozilla SOPS \u00b6 In order to store secrets safely in a public or private Git repository, you can use Mozilla's SOPS CLI to encrypt Kubernetes secrets with OpenPGP, AWS KMS, GCP KMS and Azure Key Vault. Prerequisites \u00b6 To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . Install gnupg and sops : brew install gnupg sops Generate a GPG key \u00b6 Generate a GPG key with OpenPGP without specifying a passphrase: $ gpg --full-generate-key Real name: stefanprodan Email address: stefanprodan@users.noreply.github.com Comment: You selected this USER-ID: \"stefanprodan <stefanprodan@users.noreply.github.com>\" Retrieve the GPG key ID (second row of the sec column): $ gpg --list-secret-keys stefanprodan@users.noreply.github.com sec rsa3072 2020-09-06 [SC] 1F3D1CED2F865F5E59CA564553241F147E7C5FA4 Export the public and private keypair from your local GPG keyring and create a Kubernetes secret named sops-gpg in the gotk-system namespace: gpg --export-secret-keys \\ --armor 1F3D1CED2F865F5E59CA564553241F147E7C5FA4 | kubectl create secret generic sops-gpg \\ --namespace = gotk-system \\ --from-file = sops.asc = /dev/stdin Encrypt secrets \u00b6 Generate a Kubernetes secret manifest with kubectl: kubectl -n default create secret generic basic-auth \\ --from-literal = user = admin \\ --from-literal = password = change-me \\ --dry-run = client \\ -o yaml > basic-auth.yaml Encrypt the secret with sops using your GPG key: sops --encrypt \\ --pgp = 1F3D1CED2F865F5E59CA564553241F147E7C5FA4 \\ --encrypted-regex '^(data|stringData)$' \\ --in-place basic-auth.yaml Hint Note that you should encrypt only the data section. Encrypting the Kubernetes secret metadata, kind or apiVersion is not supported by kustomize-controller. You can now commit the encrypted secret to your Git repository. Configure secrets decryption \u00b6 Registry the Git repository on your cluster: gotk create source git my-secrets \\ --url = https://github.com/my-org/my-secrets Create a kustomization for reconciling the secrets on the cluster: gotk create kustomization my-secrets \\ --source = my-secrets \\ --prune = true \\ --interval = 10m \\ --decryption-provider = sops \\ --decryption-secret = sops-gpg Note that the sops-gpg can contain more than one key, sops will try to decrypt the secrets by iterating over all the private keys until it finds one that works. Hint When using AWS/GCP KMS or Azure Key Vault, you'll have to bind an IAM Role with read access to the KMS keys to the default service account of the gotk-system namespace for kustomize-controller to be able to fetch keys from KMS. GitOps workflow \u00b6 A cluster admin should create the Kubernetes secret with the PGP keys on each cluster and add the GitRepository/Kustomization manifests to the fleet repository. Git repository manifest: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : my-secrets namespace : gotk-system spec : interval : 1m url : https://github.com/my-org/my-secrets Kustomization manifest: apiVersion : kustomize.toolkit.fluxcd.io/v1alpha1 kind : Kustomization metadata : name : my-secrets namespace : gotk-system spec : interval : 10m0s sourceRef : kind : GitRepository name : my-secrets path : ./ prune : true decryption : provider : sops secretRef : name : sops-gpg Hint You can generate the above manifests using gotk create <kind> --export > manifest.yaml . Assuming a team member wants to deploy an application that needs to connect to a database using a username and password, they'll be doing the following: create a Kubernetes Secret manifest locally with the db credentials e.g. db-auth.yaml encrypt the secret data field with sops create a Kubernetes Deployment manifest for the app e.g. app-deployment.yaml add the Secret to the Deployment manifest as a volume mount or env var commit the manifests db-auth.yaml and app-deployment.yaml to a Git repository that's being synced by the GitOps toolkit controllers Once the manifests have been pushed to the Git repository, the following happens: source-controller pulls the changes from Git kustomize-controller loads the GPG keys from the sops-pgp secret kustomize-controller decrypts the Kubernetes secrets with sops and applies them on the cluster kubelet creates the pods and mounts the secret as a volume or env variable inside the app container","title":"Mozilla SOPS"},{"location":"guides/mozilla-sops/#manage-kubernetes-secrets-with-mozilla-sops","text":"In order to store secrets safely in a public or private Git repository, you can use Mozilla's SOPS CLI to encrypt Kubernetes secrets with OpenPGP, AWS KMS, GCP KMS and Azure Key Vault.","title":"Manage Kubernetes secrets with Mozilla SOPS"},{"location":"guides/mozilla-sops/#prerequisites","text":"To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . Install gnupg and sops : brew install gnupg sops","title":"Prerequisites"},{"location":"guides/mozilla-sops/#generate-a-gpg-key","text":"Generate a GPG key with OpenPGP without specifying a passphrase: $ gpg --full-generate-key Real name: stefanprodan Email address: stefanprodan@users.noreply.github.com Comment: You selected this USER-ID: \"stefanprodan <stefanprodan@users.noreply.github.com>\" Retrieve the GPG key ID (second row of the sec column): $ gpg --list-secret-keys stefanprodan@users.noreply.github.com sec rsa3072 2020-09-06 [SC] 1F3D1CED2F865F5E59CA564553241F147E7C5FA4 Export the public and private keypair from your local GPG keyring and create a Kubernetes secret named sops-gpg in the gotk-system namespace: gpg --export-secret-keys \\ --armor 1F3D1CED2F865F5E59CA564553241F147E7C5FA4 | kubectl create secret generic sops-gpg \\ --namespace = gotk-system \\ --from-file = sops.asc = /dev/stdin","title":"Generate a GPG key"},{"location":"guides/mozilla-sops/#encrypt-secrets","text":"Generate a Kubernetes secret manifest with kubectl: kubectl -n default create secret generic basic-auth \\ --from-literal = user = admin \\ --from-literal = password = change-me \\ --dry-run = client \\ -o yaml > basic-auth.yaml Encrypt the secret with sops using your GPG key: sops --encrypt \\ --pgp = 1F3D1CED2F865F5E59CA564553241F147E7C5FA4 \\ --encrypted-regex '^(data|stringData)$' \\ --in-place basic-auth.yaml Hint Note that you should encrypt only the data section. Encrypting the Kubernetes secret metadata, kind or apiVersion is not supported by kustomize-controller. You can now commit the encrypted secret to your Git repository.","title":"Encrypt secrets"},{"location":"guides/mozilla-sops/#configure-secrets-decryption","text":"Registry the Git repository on your cluster: gotk create source git my-secrets \\ --url = https://github.com/my-org/my-secrets Create a kustomization for reconciling the secrets on the cluster: gotk create kustomization my-secrets \\ --source = my-secrets \\ --prune = true \\ --interval = 10m \\ --decryption-provider = sops \\ --decryption-secret = sops-gpg Note that the sops-gpg can contain more than one key, sops will try to decrypt the secrets by iterating over all the private keys until it finds one that works. Hint When using AWS/GCP KMS or Azure Key Vault, you'll have to bind an IAM Role with read access to the KMS keys to the default service account of the gotk-system namespace for kustomize-controller to be able to fetch keys from KMS.","title":"Configure secrets decryption"},{"location":"guides/mozilla-sops/#gitops-workflow","text":"A cluster admin should create the Kubernetes secret with the PGP keys on each cluster and add the GitRepository/Kustomization manifests to the fleet repository. Git repository manifest: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : my-secrets namespace : gotk-system spec : interval : 1m url : https://github.com/my-org/my-secrets Kustomization manifest: apiVersion : kustomize.toolkit.fluxcd.io/v1alpha1 kind : Kustomization metadata : name : my-secrets namespace : gotk-system spec : interval : 10m0s sourceRef : kind : GitRepository name : my-secrets path : ./ prune : true decryption : provider : sops secretRef : name : sops-gpg Hint You can generate the above manifests using gotk create <kind> --export > manifest.yaml . Assuming a team member wants to deploy an application that needs to connect to a database using a username and password, they'll be doing the following: create a Kubernetes Secret manifest locally with the db credentials e.g. db-auth.yaml encrypt the secret data field with sops create a Kubernetes Deployment manifest for the app e.g. app-deployment.yaml add the Secret to the Deployment manifest as a volume mount or env var commit the manifests db-auth.yaml and app-deployment.yaml to a Git repository that's being synced by the GitOps toolkit controllers Once the manifests have been pushed to the Git repository, the following happens: source-controller pulls the changes from Git kustomize-controller loads the GPG keys from the sops-pgp secret kustomize-controller decrypts the Kubernetes secrets with sops and applies them on the cluster kubelet creates the pods and mounts the secret as a volume or env variable inside the app container","title":"GitOps workflow"},{"location":"guides/notifications/","text":"Setup Notifications \u00b6 When operating a cluster, different teams may wish to receive notifications about the status of their GitOps pipelines. For example, the on-call team would receive alerts about reconciliation failures in the cluster, while the dev team may wish to be alerted when a new version of an app was deployed and if the deployment is healthy. Prerequisites \u00b6 To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The GitOps toolkit controllers emit Kubernetes events whenever a resource status changes. You can use the notification-controller to forward these events to Slack, Microsoft Teams, Discord or Rocket chart. The notification controller is part of the default toolkit installation. Define a provider \u00b6 First create a secret with your Slack incoming webhook: kubectl -n gotk-system create secret generic slack-url \\ --from-literal = address = https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK Note that the secret must contain an address field, it can be a Slack, Microsoft Teams, Discord or Rocket webhook URL. Create a notification provider for Slack by referencing the above secret: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Provider metadata : name : slack namespace : gotk-system spec : type : slack channel : general secretRef : name : slack-url The provider type can be slack , msteams , discord , rocket , github , gitlab or generic . When type generic is specified, the notification controller will post the incoming event in JSON format to the webhook address. This way you can create custom handlers that can store the events in Elasticsearch, CloudWatch, Stackdriver, etc. Define an alert \u00b6 Create an alert definition for all repositories and kustomizations: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Alert metadata : name : on-call-webapp namespace : gotk-system spec : providerRef : name : slack eventSeverity : info eventSources : - kind : GitRepository name : '*' - kind : Kustomization name : '*' Apply the above files or commit them to the fleet-infra repository. To verify that the alert has been acknowledge by the notification controller do: $ kubectl -n gotk-system get alerts NAME READY STATUS AGE on-call-webapp True Initialized 1m Multiple alerts can be used to send notifications to different channels or Slack organizations. The event severity can be set to info or error . When the severity is set to error , the kustomize controller will alert on any error encountered during the reconciliation process. This includes kustomize build and validation errors, apply errors and health check failures. When the verbosity is set to info , the controller will alert if: a Kubernetes object was created, updated or deleted heath checks are passing a dependency is delaying the execution an error occurs Git commit status \u00b6 The github and gitlab provider are slightly different to the other chat providers. These providers will link an event back to its source by writing a commit status event to the repository. For more information about how a commit status works, refer to the GitHub or GitLab documentation. The first image is an example of how it may look like in GitHub while the one below is an example for GitLab. Currently the provider will only work with Alerts for Kustomization resources as the events have to be linked with a specific git commit. Any other event that does not contain a commit reference will be ignored by the provider. Each status will contain some additional information from the event which includes the resource kind, name and reason for the event. It will be displayed in the format of {{ .Kind }}/{{ .Name }} - {{ .Reason }} . To get started the git provider require an authentication token to communicate with the API. Follow the GitHub or Gitlab for a detailed guide how to create a token. Store the generated token in a Secret with the following data format. apiVersion : v1 kind : Secret metadata : name : github namespace : gitops-system data : token : <token> Creating a git provider is very similar to creating other types of providers. The only caveat being that the provider address needs to point to the same git repository as the Kustomization resource refers to. apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Provider metadata : name : podinfo namespace : gotk-system spec : type : github channel : general address : https://github.com/stefanprodan/podinfo secretRef : name : github --- apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Alert metadata : name : podinfo namespace : gotk-system spec : providerRef : name : podinfo eventSeverity : info eventSources : - kind : Kustomization name : podinfo namespace : gotk-system The secret referenced in the provider is expected to contain a personal access token to authenticate with the GitHub API. apiVersion : v1 kind : Secret metadata : name : github namespace : gotk-system data : token : <token>","title":"Setup Notifications"},{"location":"guides/notifications/#setup-notifications","text":"When operating a cluster, different teams may wish to receive notifications about the status of their GitOps pipelines. For example, the on-call team would receive alerts about reconciliation failures in the cluster, while the dev team may wish to be alerted when a new version of an app was deployed and if the deployment is healthy.","title":"Setup Notifications"},{"location":"guides/notifications/#prerequisites","text":"To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The GitOps toolkit controllers emit Kubernetes events whenever a resource status changes. You can use the notification-controller to forward these events to Slack, Microsoft Teams, Discord or Rocket chart. The notification controller is part of the default toolkit installation.","title":"Prerequisites"},{"location":"guides/notifications/#define-a-provider","text":"First create a secret with your Slack incoming webhook: kubectl -n gotk-system create secret generic slack-url \\ --from-literal = address = https://hooks.slack.com/services/YOUR/SLACK/WEBHOOK Note that the secret must contain an address field, it can be a Slack, Microsoft Teams, Discord or Rocket webhook URL. Create a notification provider for Slack by referencing the above secret: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Provider metadata : name : slack namespace : gotk-system spec : type : slack channel : general secretRef : name : slack-url The provider type can be slack , msteams , discord , rocket , github , gitlab or generic . When type generic is specified, the notification controller will post the incoming event in JSON format to the webhook address. This way you can create custom handlers that can store the events in Elasticsearch, CloudWatch, Stackdriver, etc.","title":"Define a provider"},{"location":"guides/notifications/#define-an-alert","text":"Create an alert definition for all repositories and kustomizations: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Alert metadata : name : on-call-webapp namespace : gotk-system spec : providerRef : name : slack eventSeverity : info eventSources : - kind : GitRepository name : '*' - kind : Kustomization name : '*' Apply the above files or commit them to the fleet-infra repository. To verify that the alert has been acknowledge by the notification controller do: $ kubectl -n gotk-system get alerts NAME READY STATUS AGE on-call-webapp True Initialized 1m Multiple alerts can be used to send notifications to different channels or Slack organizations. The event severity can be set to info or error . When the severity is set to error , the kustomize controller will alert on any error encountered during the reconciliation process. This includes kustomize build and validation errors, apply errors and health check failures. When the verbosity is set to info , the controller will alert if: a Kubernetes object was created, updated or deleted heath checks are passing a dependency is delaying the execution an error occurs","title":"Define an alert"},{"location":"guides/notifications/#git-commit-status","text":"The github and gitlab provider are slightly different to the other chat providers. These providers will link an event back to its source by writing a commit status event to the repository. For more information about how a commit status works, refer to the GitHub or GitLab documentation. The first image is an example of how it may look like in GitHub while the one below is an example for GitLab. Currently the provider will only work with Alerts for Kustomization resources as the events have to be linked with a specific git commit. Any other event that does not contain a commit reference will be ignored by the provider. Each status will contain some additional information from the event which includes the resource kind, name and reason for the event. It will be displayed in the format of {{ .Kind }}/{{ .Name }} - {{ .Reason }} . To get started the git provider require an authentication token to communicate with the API. Follow the GitHub or Gitlab for a detailed guide how to create a token. Store the generated token in a Secret with the following data format. apiVersion : v1 kind : Secret metadata : name : github namespace : gitops-system data : token : <token> Creating a git provider is very similar to creating other types of providers. The only caveat being that the provider address needs to point to the same git repository as the Kustomization resource refers to. apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Provider metadata : name : podinfo namespace : gotk-system spec : type : github channel : general address : https://github.com/stefanprodan/podinfo secretRef : name : github --- apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Alert metadata : name : podinfo namespace : gotk-system spec : providerRef : name : podinfo eventSeverity : info eventSources : - kind : Kustomization name : podinfo namespace : gotk-system The secret referenced in the provider is expected to contain a personal access token to authenticate with the GitHub API. apiVersion : v1 kind : Secret metadata : name : github namespace : gotk-system data : token : <token>","title":"Git commit status"},{"location":"guides/sealed-secrets/","text":"Sealed Secrets \u00b6 In order to store secrets safely in a public or private Git repository, you can use Bitnami's sealed-secrets controller and encrypt your Kubernetes Secrets into SealedSecrets. The sealed secrets can be decrypted only by the controller running in your cluster and nobody else can obtain the original secret, even if they have access to the Git repository. Prerequisites \u00b6 To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The sealed-secrets controller comes with a companion CLI tool called kubeseal. With kubeseal you can create SealedSecret custom resources in YAML format and store those in your Git repository. Install the kubeseal CLI: brew install kubeseal For Linux or Windows you can download the kubeseal binary from GitHub . Deploy sealed-secrets with a HelmRelease \u00b6 You'll be using helm-controller APIs to install the sealed-secrets controller from its Helm chart . First you have to register the Helm repository where the sealed-secrets chart is published: gotk create source helm stable \\ --interval = 1h \\ --url = https://kubernetes-charts.storage.googleapis.com With interval we configure source-controller to download the Helm repository index every hour. If a newer version of sealed-secrets is published, source-controller will signal helm-controller that a new chart is available. Create a Helm release that installs the latest version of sealed-secrets controller: gotk create helmrelease sealed-secrets \\ --interval = 1h \\ --release-name = sealed-secrets \\ --target-namespace = gotk-system \\ --source = HelmRepository/stable \\ --chart = sealed-secrets \\ --chart-version = \"1.10.x\" With chart version 1.10.x we configure helm-controller to automatically upgrade the release when a new chart patch version is fetched by source-controller. At startup, the sealed-secrets controller generates a 4096-bit RSA key pair and persists the private and public keys as Kubernetes secrets in the gotk-system namespace. You can retrieve the public key with: kubeseal --fetch-cert \\ --controller-name = sealed-secrets \\ --controller-namespace = gotk-system \\ > pub-sealed-secrets.pem The public key can be safely stored in Git, and can be used to encrypt secrets without direct access to the Kubernetes cluster. Encrypt secrets \u00b6 Generate a Kubernetes secret manifest with kubectl: kubectl -n default create secret generic basic-auth \\ --from-literal = user = admin \\ --from-literal = password = change-me \\ --dry-run \\ -o yaml > basic-auth.yaml Encrypt the secret with kubeseal: kubeseal --format = yaml --cert = pub-sealed-secrets.pem \\ < basic-auth.yaml > basic-auth-sealed.yaml Delete the plain secret and apply the sealed one: rm basic-auth.yaml kubectl apply -f basic-auth-sealed.yaml Verify that the sealed-secrets controller has created the basic-auth Kubernetes Secret: $ kubectl -n default get secrets basic-auth NAME TYPE DATA AGE basic-auth Opaque 2 1m43s GitOps workflow \u00b6 A cluster admin should add the stable HelmRepository manifest and the sealed-secrets HelmRelease to the fleet repository. Helm repository manifest: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmRepository metadata : name : stable namespace : gotk-system spec : interval : 1h0m0s url : https://kubernetes-charts.storage.googleapis.com Helm release manifest: apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : sealed-secrets namespace : gotk-system spec : chart : spec : chart : sealed-secrets sourceRef : kind : HelmRepository name : stable version : \"1.10.x\" interval : 1h0m0s releaseName : sealed-secrets targetNamespace : gotk-system Hint You can generate the above manifests using gotk create <kind> --export > manifest.yaml . Once the sealed-secrets controller is installed, the admin fetches the public key and shares it with the teams that operate on the fleet clusters via Git. When a team member wants to create a Kubernetes Secret on a cluster, they uses kubeseal and the public key corresponding to that cluster to generate a SealedSecret. Assuming a team member wants to deploy an application that needs to connect to a database using a username and password, they'll be doing the following: create a Kubernetes Secret manifest locally with the db credentials e.g. db-auth.yaml encrypt the secret with kubeseal as db-auth-sealed.yaml delete the original secret file db-auth.yaml create a Kubernetes Deployment manifest for the app e.g. app-deployment.yaml add the Secret to the Deployment manifest as a volume mount or env var using the original name db-auth commit the manifests db-auth-sealed.yaml and app-deployment.yaml to a Git repository that's being synced by the GitOps toolkit controllers Once the manifests have been pushed to the Git repository, the following happens: source-controller pulls the changes from Git kustomize-controller applies the SealedSecret and the Deployment manifests sealed-secrets controller decrypts the SealedSecret and creates a Kubernetes Secret kubelet creates the pods and mounts the secret as a volume or env variable inside the app container","title":"Sealed Secrets"},{"location":"guides/sealed-secrets/#sealed-secrets","text":"In order to store secrets safely in a public or private Git repository, you can use Bitnami's sealed-secrets controller and encrypt your Kubernetes Secrets into SealedSecrets. The sealed secrets can be decrypted only by the controller running in your cluster and nobody else can obtain the original secret, even if they have access to the Git repository.","title":"Sealed Secrets"},{"location":"guides/sealed-secrets/#prerequisites","text":"To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The sealed-secrets controller comes with a companion CLI tool called kubeseal. With kubeseal you can create SealedSecret custom resources in YAML format and store those in your Git repository. Install the kubeseal CLI: brew install kubeseal For Linux or Windows you can download the kubeseal binary from GitHub .","title":"Prerequisites"},{"location":"guides/sealed-secrets/#deploy-sealed-secrets-with-a-helmrelease","text":"You'll be using helm-controller APIs to install the sealed-secrets controller from its Helm chart . First you have to register the Helm repository where the sealed-secrets chart is published: gotk create source helm stable \\ --interval = 1h \\ --url = https://kubernetes-charts.storage.googleapis.com With interval we configure source-controller to download the Helm repository index every hour. If a newer version of sealed-secrets is published, source-controller will signal helm-controller that a new chart is available. Create a Helm release that installs the latest version of sealed-secrets controller: gotk create helmrelease sealed-secrets \\ --interval = 1h \\ --release-name = sealed-secrets \\ --target-namespace = gotk-system \\ --source = HelmRepository/stable \\ --chart = sealed-secrets \\ --chart-version = \"1.10.x\" With chart version 1.10.x we configure helm-controller to automatically upgrade the release when a new chart patch version is fetched by source-controller. At startup, the sealed-secrets controller generates a 4096-bit RSA key pair and persists the private and public keys as Kubernetes secrets in the gotk-system namespace. You can retrieve the public key with: kubeseal --fetch-cert \\ --controller-name = sealed-secrets \\ --controller-namespace = gotk-system \\ > pub-sealed-secrets.pem The public key can be safely stored in Git, and can be used to encrypt secrets without direct access to the Kubernetes cluster.","title":"Deploy sealed-secrets with a HelmRelease"},{"location":"guides/sealed-secrets/#encrypt-secrets","text":"Generate a Kubernetes secret manifest with kubectl: kubectl -n default create secret generic basic-auth \\ --from-literal = user = admin \\ --from-literal = password = change-me \\ --dry-run \\ -o yaml > basic-auth.yaml Encrypt the secret with kubeseal: kubeseal --format = yaml --cert = pub-sealed-secrets.pem \\ < basic-auth.yaml > basic-auth-sealed.yaml Delete the plain secret and apply the sealed one: rm basic-auth.yaml kubectl apply -f basic-auth-sealed.yaml Verify that the sealed-secrets controller has created the basic-auth Kubernetes Secret: $ kubectl -n default get secrets basic-auth NAME TYPE DATA AGE basic-auth Opaque 2 1m43s","title":"Encrypt secrets"},{"location":"guides/sealed-secrets/#gitops-workflow","text":"A cluster admin should add the stable HelmRepository manifest and the sealed-secrets HelmRelease to the fleet repository. Helm repository manifest: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : HelmRepository metadata : name : stable namespace : gotk-system spec : interval : 1h0m0s url : https://kubernetes-charts.storage.googleapis.com Helm release manifest: apiVersion : helm.toolkit.fluxcd.io/v2alpha1 kind : HelmRelease metadata : name : sealed-secrets namespace : gotk-system spec : chart : spec : chart : sealed-secrets sourceRef : kind : HelmRepository name : stable version : \"1.10.x\" interval : 1h0m0s releaseName : sealed-secrets targetNamespace : gotk-system Hint You can generate the above manifests using gotk create <kind> --export > manifest.yaml . Once the sealed-secrets controller is installed, the admin fetches the public key and shares it with the teams that operate on the fleet clusters via Git. When a team member wants to create a Kubernetes Secret on a cluster, they uses kubeseal and the public key corresponding to that cluster to generate a SealedSecret. Assuming a team member wants to deploy an application that needs to connect to a database using a username and password, they'll be doing the following: create a Kubernetes Secret manifest locally with the db credentials e.g. db-auth.yaml encrypt the secret with kubeseal as db-auth-sealed.yaml delete the original secret file db-auth.yaml create a Kubernetes Deployment manifest for the app e.g. app-deployment.yaml add the Secret to the Deployment manifest as a volume mount or env var using the original name db-auth commit the manifests db-auth-sealed.yaml and app-deployment.yaml to a Git repository that's being synced by the GitOps toolkit controllers Once the manifests have been pushed to the Git repository, the following happens: source-controller pulls the changes from Git kustomize-controller applies the SealedSecret and the Deployment manifests sealed-secrets controller decrypts the SealedSecret and creates a Kubernetes Secret kubelet creates the pods and mounts the secret as a volume or env variable inside the app container","title":"GitOps workflow"},{"location":"guides/webhook-receivers/","text":"Setup Webhook Receivers \u00b6 The GitOps toolkit controllers are by design pull-based . In order to notify the controllers about changes in Git or Helm repositories, you can setup webhooks and trigger a cluster reconciliation every time a source changes. Using webhook receivers, you can build push-based GitOps pipelines that react to external events. Prerequisites \u00b6 To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The notification controller can handle events coming from external systems (GitHub, GitLab, Bitbucket, Harbor, Jenkins, etc) and notify the GitOps toolkit controllers about source changes. The notification controller is part of the default toolkit installation. Expose the webhook receiver \u00b6 In order to receive Git push or Helm chart upload events, you'll have to expose the webhook receiver endpoint outside of your Kubernetes cluster on a public address. The notification controller handles webhook requests on port 9292 . This port can be used to create a Kubernetes LoadBalancer Service or Ingress. Create a LoadBalancer service: apiVersion : v1 kind : Service metadata : name : receiver namespace : gotk-system spec : type : LoadBalancer selector : app : notification-controller ports : - name : http port : 80 protocol : TCP targetPort : 9292 Wait for Kubernetes to assign a public address with: watch kubectl -n gotk-system get svc/receiver Define a Git repository \u00b6 Create a Git source pointing to a GitHub repository that you have control over: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : webapp namespace : gotk-system spec : interval : 60m url : https://github.com/<GH-ORG>/<GH-REPO> ref : branch : master Authentication SSH or token based authentication can be configured for private repositories. See the GitRepository CRD docs for more details. Define a Git repository receiver \u00b6 First generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n gotk-system create secret generic webhook-token \\ --from-literal = token = $TOKEN Create a receiver for GitHub and specify the GitRepository object: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : webapp namespace : gotk-system spec : type : github events : - \"ping\" - \"push\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp Note Besides GitHub, you can define receivers for GitLab , Bitbucket , Harbor and any other system that supports webhooks e.g. Jenkins, CircleCI, etc. See the Receiver CRD docs for more details. The notification controller generates a unique URL using the provided token and the receiver name/namespace. Find the URL with: $ kubectl -n gotk-system get receiver/webapp NAME READY STATUS webapp True Receiver initialised with URL: /hook/bed6d00b5555b1603e1f59b94d7fdbca58089cb5663633fb83f2815dc626d92b On GitHub, navigate to your repository and click on the \"Add webhook\" button under \"Settings/Webhooks\". Fill the form with: Payload URL : compose the address using the receiver LB and the generated URL http://<LoadBalancerAddress>/<ReceiverURL> Secret : use the token string With the above settings, when you push a commit to the repository, the following happens: GitHub sends the Git push event to the receiver address Notification controller validates the authenticity of the payload using HMAC Source controller is notified about the changes Source controller pulls the changes into the cluster and updates the GitRepository revision Kustomize controller is notified about the revision change Kustomize controller reconciles all the Kustomizations that reference the GitRepository object","title":"Setup Webhook Receivers"},{"location":"guides/webhook-receivers/#setup-webhook-receivers","text":"The GitOps toolkit controllers are by design pull-based . In order to notify the controllers about changes in Git or Helm repositories, you can setup webhooks and trigger a cluster reconciliation every time a source changes. Using webhook receivers, you can build push-based GitOps pipelines that react to external events.","title":"Setup Webhook Receivers"},{"location":"guides/webhook-receivers/#prerequisites","text":"To follow this guide you'll need a Kubernetes cluster with the GitOps toolkit controllers installed on it. Please see the get started guide or the installation guide . The notification controller can handle events coming from external systems (GitHub, GitLab, Bitbucket, Harbor, Jenkins, etc) and notify the GitOps toolkit controllers about source changes. The notification controller is part of the default toolkit installation.","title":"Prerequisites"},{"location":"guides/webhook-receivers/#expose-the-webhook-receiver","text":"In order to receive Git push or Helm chart upload events, you'll have to expose the webhook receiver endpoint outside of your Kubernetes cluster on a public address. The notification controller handles webhook requests on port 9292 . This port can be used to create a Kubernetes LoadBalancer Service or Ingress. Create a LoadBalancer service: apiVersion : v1 kind : Service metadata : name : receiver namespace : gotk-system spec : type : LoadBalancer selector : app : notification-controller ports : - name : http port : 80 protocol : TCP targetPort : 9292 Wait for Kubernetes to assign a public address with: watch kubectl -n gotk-system get svc/receiver","title":"Expose the webhook receiver"},{"location":"guides/webhook-receivers/#define-a-git-repository","text":"Create a Git source pointing to a GitHub repository that you have control over: apiVersion : source.toolkit.fluxcd.io/v1alpha1 kind : GitRepository metadata : name : webapp namespace : gotk-system spec : interval : 60m url : https://github.com/<GH-ORG>/<GH-REPO> ref : branch : master Authentication SSH or token based authentication can be configured for private repositories. See the GitRepository CRD docs for more details.","title":"Define a Git repository"},{"location":"guides/webhook-receivers/#define-a-git-repository-receiver","text":"First generate a random string and create a secret with a token field: TOKEN = $( head -c 12 /dev/urandom | shasum | cut -d ' ' -f1 ) echo $TOKEN kubectl -n gotk-system create secret generic webhook-token \\ --from-literal = token = $TOKEN Create a receiver for GitHub and specify the GitRepository object: apiVersion : notification.toolkit.fluxcd.io/v1alpha1 kind : Receiver metadata : name : webapp namespace : gotk-system spec : type : github events : - \"ping\" - \"push\" secretRef : name : webhook-token resources : - kind : GitRepository name : webapp Note Besides GitHub, you can define receivers for GitLab , Bitbucket , Harbor and any other system that supports webhooks e.g. Jenkins, CircleCI, etc. See the Receiver CRD docs for more details. The notification controller generates a unique URL using the provided token and the receiver name/namespace. Find the URL with: $ kubectl -n gotk-system get receiver/webapp NAME READY STATUS webapp True Receiver initialised with URL: /hook/bed6d00b5555b1603e1f59b94d7fdbca58089cb5663633fb83f2815dc626d92b On GitHub, navigate to your repository and click on the \"Add webhook\" button under \"Settings/Webhooks\". Fill the form with: Payload URL : compose the address using the receiver LB and the generated URL http://<LoadBalancerAddress>/<ReceiverURL> Secret : use the token string With the above settings, when you push a commit to the repository, the following happens: GitHub sends the Git push event to the receiver address Notification controller validates the authenticity of the payload using HMAC Source controller is notified about the changes Source controller pulls the changes into the cluster and updates the GitRepository revision Kustomize controller is notified about the revision change Kustomize controller reconciles all the Kustomizations that reference the GitRepository object","title":"Define a Git repository receiver"},{"location":"internal/release/","text":"Release \u00b6 To release a new version the following steps should be followed: Create a <next semver> tag form master and push it to remote. Confirm CI builds and releases the newly tagged version.","title":"Release"},{"location":"internal/release/#release","text":"To release a new version the following steps should be followed: Create a <next semver> tag form master and push it to remote. Confirm CI builds and releases the newly tagged version.","title":"Release"},{"location":"proposals/go-git-providers/","text":"go-git-providers \u00b6 Abstract \u00b6 This proposal aims to create a library with the import path github.com/fluxcd/go-git-providers ' (import name: gitprovider ), which provides an abstraction layer for talking to Git providers like GitHub, GitLab and Bitbucket. This would become a new repository, specifically targeted at being a general-purpose Git provider client for multiple providers and domains. Goals \u00b6 Support multiple Git provider backends (e.g. GitHub, GitLab, Bitbucket, etc.) using the same interface Support talking to multiple domains at once, including custom domains (e.g. talking to \"gitlab.com\" and \"version.aalto.fi\" from the same client) Support both no authentication (for public repos), basic auth, and OAuth2 for authentication Manipulating the following resources: Organizations : GET , LIST (both all accessible top-level orgs and sub-orgs) For a given Organization : Teams : GET and LIST Repositories : GET , LIST and POST Team Access : LIST , POST and DELETE Credentials : LIST , POST and DELETE Support sub-organizations (or \"sub-groups\" in GitLab) if possible Support reconciling an object for idempotent operations Pagination is automatically handled for LIST requests Transparently can manage teams (collections of users, sub-groups in Gitlab) with varying access to repos Follow library best practices in order to be easy to vendor (e.g. use major vX versioning & go.mod) Non-goals \u00b6 Support for features not mentioned above Design decisions \u00b6 A context.Context should be passed to every request as the first argument There should be two interfaces per resource, if applicable: one collection-specific interface, with a plural name (e.g. OrganizationsClient ), that has methods like Get() and List() one instance-specific interface, with a singular name (e.g. OrganizationClient ), that operates on that instance, e.g. allowing access to child resources, e.g. Teams() Every Create() signature shall have a {Resource}CreateOptions struct as the last argument. Delete() and similar methods may use the same pattern if needed All *Options structs shall be passed by value (i.e. non-nillable) and contain only nillable, optional fields All optional fields in the type structs shall be nillable It should be possible to create a fake API client for testing, implementing the same interfaces All type structs shall have a Validate() method, and optionally a Default() one All type structs shall expose their internal representation (from the underlying library) through the InternalGetter interface with a method GetInternal() interface{} Typed errors shall be returned, wrapped using Go 1.14's new features Go-style enums are used when there are only a few supported values for a field Every field is documented using Godoc comment, including +required or +optional to clearly signify its importance Support serializing the types to JSON (if needed for e.g. debugging) by adding tags Implementation \u00b6 Provider package \u00b6 The provider package, e.g. at github.com/fluxcd/go-git-providers/github , will have constructor methods so a client can be created, e.g. as follows: // Create a client for github.com without any authentication c := github . NewClient () // Create a client for an enterprise GitHub account, without any authentication c = github . NewClient ( github . WithBaseURL ( \"enterprise.github.com\" )) // Create a client for github.com using a personal oauth2 token c = github . NewClient ( github . WithOAuth2 ( \"<token-here>\" )) Client \u00b6 The definition of a Client is as follows: // Client is an interface that allows talking to a Git provider type Client interface { // The Client allows accessing all known resources ResourceClient // SupportedDomain returns the supported domain // This field is set at client creation time, and can't be changed SupportedDomain () string // ProviderID returns the provider ID (e.g. \"github\", \"gitlab\") for this client // This field is set at client creation time, and can't be changed ProviderID () ProviderID // Raw returns the Go client used under the hood for accessing the Git provider Raw () interface {} } As one can see, the Client is scoped for a single backing domain. ProviderID is a typed string, and every implementation package defines their own constant, e.g. const ProviderName = gitprovider.ProviderID(\"github\") . The ResourceClient actually allows talking to resources of the API, both for single objects, and collections: // ResourceClient allows access to resource-specific clients type ResourceClient interface { // Organization gets the OrganizationClient for the specific top-level organization // ErrNotTopLevelOrganization will be returned if the organization is not top-level when using Organization ( o OrganizationRef ) OrganizationClient // Organizations returns the OrganizationsClient handling sets of organizations Organizations () OrganizationsClient // Repository gets the RepositoryClient for the specified RepositoryRef Repository ( r RepositoryRef ) RepositoryClient // Repositories returns the RepositoriesClient handling sets of organizations Repositories () RepositoriesClient } In order to reference organizations and repositories, there are the OrganizationRef and RepositoryRef interfaces: // OrganizationRef references an organization in a Git provider type OrganizationRef interface { // String returns the HTTPS URL fmt . Stringer // GetDomain returns the URL-domain for the Git provider backend, e.g. gitlab.com or version.aalto.fi GetDomain () string // GetOrganization returns the top-level organization, i.e. \"weaveworks\" or \"kubernetes-sigs\" GetOrganization () string // GetSubOrganizations returns the names of sub-organizations (or sub-groups), // e.g. [\"engineering\", \"frontend\"] would be returned for gitlab.com/weaveworks/engineering/frontend GetSubOrganizations () [] string } // RepositoryRef references a repository hosted by a Git provider type RepositoryRef interface { // RepositoryRef requires an OrganizationRef to fully-qualify a repo reference OrganizationRef // GetRepository returns the name of the repository GetRepository () string } Along with these, there is OrganizationInfo and RepositoryInfo which implement the above mentioned interfaces in a straightforward way. If you want to create an OrganizationRef or RepositoryRef , you can either use NewOrganizationInfo() or NewRepositoryInfo() , filling in all parts of the reference, or use the ParseRepositoryURL(r string) (RepositoryRef, error) or ParseOrganizationURL(o string) (OrganizationRef, error) methods. As mentioned above, only one target domain is supported by the Client . This means e.g. that if the Client is configured for GitHub, and you feed it a GitLab URL to parse, ErrDomainUnsupported will be returned. This brings us to a higher-level client abstraction, MultiClient . MultiClient \u00b6 In order to automatically support multiple domains and providers using the same interface, MultiClient is introduced. The user would use the MultiClient as follows: // Create a client to github.com without authentication gh := github . NewClient () // Create a client to gitlab.com, authenticating with basic auth gl := gitlab . NewClient ( gitlab . WithBasicAuth ( \"<username>\" , \"<password\" )) // Create a client to the GitLab instance at version.aalto.fi, with a given OAuth2 token aalto := gitlab . NewClient ( gitlab . WithBaseURL ( \"version.aalto.fi\" ), gitlab . WithOAuth2Token ( \"<your-token>\" )) // Create a MultiClient which supports talking to any of these backends client := gitprovider . NewMultiClient ( gh , gl , aalto ) The interface definition of MultiClient is similar to that one of Client , both embedding ResourceClient , but it also allows access to domain-specific underlying Client 's: // MultiClient allows talking to multiple Git providers at once type MultiClient interface { // The MultiClient allows accessing all known resources, automatically choosing the right underlying // Client based on the resource's domain ResourceClient // SupportedDomains returns a list of known domains SupportedDomains () [] string // ClientForDomain returns the Client used for a specific domain ClientForDomain ( domain string ) ( Client , bool ) } OrganizationsClient \u00b6 The OrganizationsClient provides access to a set of organizations, as follows: // OrganizationsClient operates on organizations the user has access to type OrganizationsClient interface { // Get a specific organization the user has access to // This might also refer to a sub-organization // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , o OrganizationRef ) ( * Organization , error ) // List all top-level organizations the specific user has access to // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context ) ([] Organization , error ) // Children returns the immediate child-organizations for the specific OrganizationRef o. // The OrganizationRef may point to any sub-organization that exists // This is not supported in GitHub // Children should return all available organizations, using multiple paginated requests if needed Children ( ctx context . Context , o OrganizationRef ) ([] Organization , error ) // Possibly add Create/Update/Delete methods later } The Organization struct is fairly straightforward for now: // Organization represents an (top-level- or sub-) organization type Organization struct { // OrganizationInfo provides the required fields // (Domain, Organization and SubOrganizations) required for being an OrganizationRef OrganizationInfo `json:\",inline\"` // InternalHolder implements the InternalGetter interface // +optional InternalHolder `json:\",inline\"` // Name is the human-friendly name of this organization, e.g. \"Weaveworks\" or \"Kubernetes SIGs\" // +required Name string `json:\"name\"` // Description returns a description for the organization // No default value at POST-time // +optional Description * string `json:\"description\"` } The OrganizationInfo struct is a straightforward struct just implementing the OrganizationRef interface with basic fields & getters. InternalHolder is implementing the InternalGetter interface as follows, and is embedded into all main structs: // InternalGetter allows access to the underlying object type InternalGetter interface { // GetInternal returns the underlying struct that's used GetInternal () interface {} } // InternalHolder can be embedded into other structs to implement the InternalGetter interface type InternalHolder struct { // Internal contains the underlying object. // +optional Internal interface {} `json:\"-\"` } OrganizationClient \u00b6 OrganizationClient allows access to a specific organization's underlying resources as follows: // OrganizationClient operates on a given/specific organization type OrganizationClient interface { // Teams gives access to the TeamsClient for this specific organization Teams () OrganizationTeamsClient } Organization Teams \u00b6 Teams belonging to a certain organization can at this moment be fetched on an individual basis, or listed. // OrganizationTeamsClient handles teams organization-wide type OrganizationTeamsClient interface { // Get a team within the specific organization // teamName may include slashes, to point to e.g. \"sub-teams\" i.e. subgroups in Gitlab // teamName must not be an empty string // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , teamName string ) ( * Team , error ) // List all teams (recursively, in terms of subgroups) within the specific organization // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context ) ([] Team , error ) // Possibly add Create/Update/Delete methods later } The Team struct is defined as follows: // Team is a representation for a team of users inside of an organization type Team struct { // Team embeds OrganizationInfo which makes it automatically comply with OrganizationRef OrganizationInfo `json:\",inline\"` // Team embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Name describes the name of the team. The team name may contain slashes // +required Name string `json:\"name\"` // Members points to a set of user names (logins) of the members of this team // +required Members [] string `json:\"members\"` } In GitLab, teams could be modelled as users in a sub-group. Those users can later be added as a single unit to access a given repository. RepositoriesClient \u00b6 RepositoriesClient provides access to a set of repositories for the user. // RepositoriesClient operates on repositories the user has access to type RepositoriesClient interface { // Get returns the repository at the given path // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , r RepositoryRef ) ( * Repository , error ) // List all repositories in the given organization // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context , o OrganizationRef ) ([] Repository , error ) // Create creates a repository at the given organization path, with the given URL-encoded name and options // ErrAlreadyExists will be returned if the resource already exists Create ( ctx context . Context , r * Repository , opts RepositoryCreateOptions ) ( * Repository , error ) // Reconcile makes sure r is the actual state in the backing Git provider. If r doesn't exist // under the hood, it is created. If r is already the actual state, this is a no-op. If r isn't // the actual state, the resource will either be updated or deleted/recreated. Reconcile ( ctx context . Context , r * Repository ) error } RepositoryCreateOptions has options like AutoInit *bool , LicenseTemplate *string and so forth to allow an one-time initialization step. The Repository struct is defined as follows: // Repository represents a Git repository provided by a Git provider type Repository struct { // RepositoryInfo provides the required fields // (Domain, Organization, SubOrganizations and RepositoryName) // required for being an RepositoryRef RepositoryInfo `json:\",inline\"` // InternalHolder implements the InternalGetter interface // +optional InternalHolder `json:\",inline\"` // Description returns a description for the repository // No default value at POST-time // +optional Description * string `json:\"description\"` // Visibility returns the desired visibility for the repository // Default value at POST-time: RepoVisibilityPrivate // +optional Visibility * RepoVisibility } // GetCloneURL gets the clone URL for the specified transport type func ( r * Repository ) GetCloneURL ( transport TransportType ) string { return GetCloneURL ( r , transport ) } As can be seen, there is also a GetCloneURL function for the repository which allows resolving the URL from which to clone the repo, for a given transport method ( ssh and https are supported TransportType s) RepositoryClient \u00b6 RepositoryClient allows access to a given repository's underlying resources, like follows: // RepositoryClient operates on a given/specific repository type RepositoryClient interface { // TeamAccess gives access to what teams have access to this specific repository TeamAccess () RepositoryTeamAccessClient // Credentials gives access to manipulating credentials for accessing this specific repository Credentials () RepositoryCredentialsClient } Repository Teams \u00b6 RepositoryTeamAccessClient allows adding & removing teams from the list of authorized persons to access a repository. // RepositoryTeamAccessClient operates on the teams list for a specific repository type RepositoryTeamAccessClient interface { // Create adds a given team to the repo's team access control list // ErrAlreadyExists will be returned if the resource already exists // The embedded RepositoryInfo of ta does not need to be populated, but if it is, // it must equal to the RepositoryRef given to the RepositoryClient. Create ( ctx context . Context , ta * TeamAccess , opts RepositoryAddTeamOptions ) error // Lists the team access control list for this repo List ( ctx context . Context ) ([] TeamAccess , error ) // Reconcile makes sure ta is the actual state in the backing Git provider. If ta doesn't exist // under the hood, it is created. If ta is already the actual state, this is a no-op. If ta isn't // the actual state, the resource will either be updated or deleted/recreated. // The embedded RepositoryInfo of ta does not need to be populated, but if it is, // it must equal to the RepositoryRef given to the RepositoryClient. Reconcile ( ctx context . Context , ta * TeamAccess ) error // Delete removes the given team from the repo's team access control list // ErrNotFound is returned if the resource does not exist Delete ( ctx context . Context , teamName string ) error } The TeamAccess struct looks as follows: // TeamAccess describes a binding between a repository and a team type TeamAccess struct { // TeamAccess embeds RepositoryInfo which makes it automatically comply with RepositoryRef // +optional RepositoryInfo `json:\",inline\"` // TeamAccess embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Name describes the name of the team. The team name may contain slashes // +required Name string `json:\"name\"` // Permission describes the permission level for which the team is allowed to operate // Default: read // Available options: See the TeamRepositoryPermission enum // +optional Permission * TeamRepositoryPermission } Repository Credentials \u00b6 RepositoryCredentialsClient allows adding & removing credentials (e.g. deploy keys) from accessing a specific repository. // RepositoryCredentialsClient operates on the access credential list for a specific repository type RepositoryCredentialsClient interface { // Create a credential with the given human-readable name, the given bytes and optional options // ErrAlreadyExists will be returned if the resource already exists Create ( ctx context . Context , c RepositoryCredential , opts CredentialCreateOptions ) error // Lists all credentials for the given credential type List ( ctx context . Context , t RepositoryCredentialType ) ([] RepositoryCredential , error ) // Reconcile makes sure c is the actual state in the backing Git provider. If c doesn't exist // under the hood, it is created. If c is already the actual state, this is a no-op. If c isn't // the actual state, the resource will either be updated or deleted/recreated. Reconcile ( ctx context . Context , c RepositoryCredential ) error // Deletes a credential from the repo. name corresponds to GetName() of the credential // ErrNotFound is returned if the resource does not exist Delete ( ctx context . Context , t RepositoryCredentialType , name string ) error } In order to support multiple different types of credentials, RepositoryCredential is an interface: // RepositoryCredential is a credential that allows access (either read-only or read-write) to the repo type RepositoryCredential interface { // GetType returns the type of the credential GetType () RepositoryCredentialType // GetName returns a name (or title/description) of the credential GetName () string // GetData returns the key that will be authorized to access the repo, this can e.g. be a SSH public key GetData () [] byte // IsReadOnly returns whether this credential is authorized to write to the repository or not IsReadOnly () bool } The default implementation of RepositoryCredential is DeployKey : // DeployKey represents a short-lived credential (e.g. an SSH public key) used for accessing a repository type DeployKey struct { // DeployKey embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Title is the human-friendly interpretation of what the key is for (and does) // +required Title string `json:\"title\"` // Key specifies the public part of the deploy (e.g. SSH) key // +required Key [] byte `json:\"key\"` // ReadOnly specifies whether this DeployKey can write to the repository or not // Default value at POST-time: true // +optional ReadOnly * bool `json:\"readOnly\"` }","title":"go-git-providers"},{"location":"proposals/go-git-providers/#go-git-providers","text":"","title":"go-git-providers"},{"location":"proposals/go-git-providers/#abstract","text":"This proposal aims to create a library with the import path github.com/fluxcd/go-git-providers ' (import name: gitprovider ), which provides an abstraction layer for talking to Git providers like GitHub, GitLab and Bitbucket. This would become a new repository, specifically targeted at being a general-purpose Git provider client for multiple providers and domains.","title":"Abstract"},{"location":"proposals/go-git-providers/#goals","text":"Support multiple Git provider backends (e.g. GitHub, GitLab, Bitbucket, etc.) using the same interface Support talking to multiple domains at once, including custom domains (e.g. talking to \"gitlab.com\" and \"version.aalto.fi\" from the same client) Support both no authentication (for public repos), basic auth, and OAuth2 for authentication Manipulating the following resources: Organizations : GET , LIST (both all accessible top-level orgs and sub-orgs) For a given Organization : Teams : GET and LIST Repositories : GET , LIST and POST Team Access : LIST , POST and DELETE Credentials : LIST , POST and DELETE Support sub-organizations (or \"sub-groups\" in GitLab) if possible Support reconciling an object for idempotent operations Pagination is automatically handled for LIST requests Transparently can manage teams (collections of users, sub-groups in Gitlab) with varying access to repos Follow library best practices in order to be easy to vendor (e.g. use major vX versioning & go.mod)","title":"Goals"},{"location":"proposals/go-git-providers/#non-goals","text":"Support for features not mentioned above","title":"Non-goals"},{"location":"proposals/go-git-providers/#design-decisions","text":"A context.Context should be passed to every request as the first argument There should be two interfaces per resource, if applicable: one collection-specific interface, with a plural name (e.g. OrganizationsClient ), that has methods like Get() and List() one instance-specific interface, with a singular name (e.g. OrganizationClient ), that operates on that instance, e.g. allowing access to child resources, e.g. Teams() Every Create() signature shall have a {Resource}CreateOptions struct as the last argument. Delete() and similar methods may use the same pattern if needed All *Options structs shall be passed by value (i.e. non-nillable) and contain only nillable, optional fields All optional fields in the type structs shall be nillable It should be possible to create a fake API client for testing, implementing the same interfaces All type structs shall have a Validate() method, and optionally a Default() one All type structs shall expose their internal representation (from the underlying library) through the InternalGetter interface with a method GetInternal() interface{} Typed errors shall be returned, wrapped using Go 1.14's new features Go-style enums are used when there are only a few supported values for a field Every field is documented using Godoc comment, including +required or +optional to clearly signify its importance Support serializing the types to JSON (if needed for e.g. debugging) by adding tags","title":"Design decisions"},{"location":"proposals/go-git-providers/#implementation","text":"","title":"Implementation"},{"location":"proposals/go-git-providers/#provider-package","text":"The provider package, e.g. at github.com/fluxcd/go-git-providers/github , will have constructor methods so a client can be created, e.g. as follows: // Create a client for github.com without any authentication c := github . NewClient () // Create a client for an enterprise GitHub account, without any authentication c = github . NewClient ( github . WithBaseURL ( \"enterprise.github.com\" )) // Create a client for github.com using a personal oauth2 token c = github . NewClient ( github . WithOAuth2 ( \"<token-here>\" ))","title":"Provider package"},{"location":"proposals/go-git-providers/#client","text":"The definition of a Client is as follows: // Client is an interface that allows talking to a Git provider type Client interface { // The Client allows accessing all known resources ResourceClient // SupportedDomain returns the supported domain // This field is set at client creation time, and can't be changed SupportedDomain () string // ProviderID returns the provider ID (e.g. \"github\", \"gitlab\") for this client // This field is set at client creation time, and can't be changed ProviderID () ProviderID // Raw returns the Go client used under the hood for accessing the Git provider Raw () interface {} } As one can see, the Client is scoped for a single backing domain. ProviderID is a typed string, and every implementation package defines their own constant, e.g. const ProviderName = gitprovider.ProviderID(\"github\") . The ResourceClient actually allows talking to resources of the API, both for single objects, and collections: // ResourceClient allows access to resource-specific clients type ResourceClient interface { // Organization gets the OrganizationClient for the specific top-level organization // ErrNotTopLevelOrganization will be returned if the organization is not top-level when using Organization ( o OrganizationRef ) OrganizationClient // Organizations returns the OrganizationsClient handling sets of organizations Organizations () OrganizationsClient // Repository gets the RepositoryClient for the specified RepositoryRef Repository ( r RepositoryRef ) RepositoryClient // Repositories returns the RepositoriesClient handling sets of organizations Repositories () RepositoriesClient } In order to reference organizations and repositories, there are the OrganizationRef and RepositoryRef interfaces: // OrganizationRef references an organization in a Git provider type OrganizationRef interface { // String returns the HTTPS URL fmt . Stringer // GetDomain returns the URL-domain for the Git provider backend, e.g. gitlab.com or version.aalto.fi GetDomain () string // GetOrganization returns the top-level organization, i.e. \"weaveworks\" or \"kubernetes-sigs\" GetOrganization () string // GetSubOrganizations returns the names of sub-organizations (or sub-groups), // e.g. [\"engineering\", \"frontend\"] would be returned for gitlab.com/weaveworks/engineering/frontend GetSubOrganizations () [] string } // RepositoryRef references a repository hosted by a Git provider type RepositoryRef interface { // RepositoryRef requires an OrganizationRef to fully-qualify a repo reference OrganizationRef // GetRepository returns the name of the repository GetRepository () string } Along with these, there is OrganizationInfo and RepositoryInfo which implement the above mentioned interfaces in a straightforward way. If you want to create an OrganizationRef or RepositoryRef , you can either use NewOrganizationInfo() or NewRepositoryInfo() , filling in all parts of the reference, or use the ParseRepositoryURL(r string) (RepositoryRef, error) or ParseOrganizationURL(o string) (OrganizationRef, error) methods. As mentioned above, only one target domain is supported by the Client . This means e.g. that if the Client is configured for GitHub, and you feed it a GitLab URL to parse, ErrDomainUnsupported will be returned. This brings us to a higher-level client abstraction, MultiClient .","title":"Client"},{"location":"proposals/go-git-providers/#multiclient","text":"In order to automatically support multiple domains and providers using the same interface, MultiClient is introduced. The user would use the MultiClient as follows: // Create a client to github.com without authentication gh := github . NewClient () // Create a client to gitlab.com, authenticating with basic auth gl := gitlab . NewClient ( gitlab . WithBasicAuth ( \"<username>\" , \"<password\" )) // Create a client to the GitLab instance at version.aalto.fi, with a given OAuth2 token aalto := gitlab . NewClient ( gitlab . WithBaseURL ( \"version.aalto.fi\" ), gitlab . WithOAuth2Token ( \"<your-token>\" )) // Create a MultiClient which supports talking to any of these backends client := gitprovider . NewMultiClient ( gh , gl , aalto ) The interface definition of MultiClient is similar to that one of Client , both embedding ResourceClient , but it also allows access to domain-specific underlying Client 's: // MultiClient allows talking to multiple Git providers at once type MultiClient interface { // The MultiClient allows accessing all known resources, automatically choosing the right underlying // Client based on the resource's domain ResourceClient // SupportedDomains returns a list of known domains SupportedDomains () [] string // ClientForDomain returns the Client used for a specific domain ClientForDomain ( domain string ) ( Client , bool ) }","title":"MultiClient"},{"location":"proposals/go-git-providers/#organizationsclient","text":"The OrganizationsClient provides access to a set of organizations, as follows: // OrganizationsClient operates on organizations the user has access to type OrganizationsClient interface { // Get a specific organization the user has access to // This might also refer to a sub-organization // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , o OrganizationRef ) ( * Organization , error ) // List all top-level organizations the specific user has access to // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context ) ([] Organization , error ) // Children returns the immediate child-organizations for the specific OrganizationRef o. // The OrganizationRef may point to any sub-organization that exists // This is not supported in GitHub // Children should return all available organizations, using multiple paginated requests if needed Children ( ctx context . Context , o OrganizationRef ) ([] Organization , error ) // Possibly add Create/Update/Delete methods later } The Organization struct is fairly straightforward for now: // Organization represents an (top-level- or sub-) organization type Organization struct { // OrganizationInfo provides the required fields // (Domain, Organization and SubOrganizations) required for being an OrganizationRef OrganizationInfo `json:\",inline\"` // InternalHolder implements the InternalGetter interface // +optional InternalHolder `json:\",inline\"` // Name is the human-friendly name of this organization, e.g. \"Weaveworks\" or \"Kubernetes SIGs\" // +required Name string `json:\"name\"` // Description returns a description for the organization // No default value at POST-time // +optional Description * string `json:\"description\"` } The OrganizationInfo struct is a straightforward struct just implementing the OrganizationRef interface with basic fields & getters. InternalHolder is implementing the InternalGetter interface as follows, and is embedded into all main structs: // InternalGetter allows access to the underlying object type InternalGetter interface { // GetInternal returns the underlying struct that's used GetInternal () interface {} } // InternalHolder can be embedded into other structs to implement the InternalGetter interface type InternalHolder struct { // Internal contains the underlying object. // +optional Internal interface {} `json:\"-\"` }","title":"OrganizationsClient"},{"location":"proposals/go-git-providers/#organizationclient","text":"OrganizationClient allows access to a specific organization's underlying resources as follows: // OrganizationClient operates on a given/specific organization type OrganizationClient interface { // Teams gives access to the TeamsClient for this specific organization Teams () OrganizationTeamsClient }","title":"OrganizationClient"},{"location":"proposals/go-git-providers/#organization-teams","text":"Teams belonging to a certain organization can at this moment be fetched on an individual basis, or listed. // OrganizationTeamsClient handles teams organization-wide type OrganizationTeamsClient interface { // Get a team within the specific organization // teamName may include slashes, to point to e.g. \"sub-teams\" i.e. subgroups in Gitlab // teamName must not be an empty string // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , teamName string ) ( * Team , error ) // List all teams (recursively, in terms of subgroups) within the specific organization // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context ) ([] Team , error ) // Possibly add Create/Update/Delete methods later } The Team struct is defined as follows: // Team is a representation for a team of users inside of an organization type Team struct { // Team embeds OrganizationInfo which makes it automatically comply with OrganizationRef OrganizationInfo `json:\",inline\"` // Team embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Name describes the name of the team. The team name may contain slashes // +required Name string `json:\"name\"` // Members points to a set of user names (logins) of the members of this team // +required Members [] string `json:\"members\"` } In GitLab, teams could be modelled as users in a sub-group. Those users can later be added as a single unit to access a given repository.","title":"Organization Teams"},{"location":"proposals/go-git-providers/#repositoriesclient","text":"RepositoriesClient provides access to a set of repositories for the user. // RepositoriesClient operates on repositories the user has access to type RepositoriesClient interface { // Get returns the repository at the given path // ErrNotFound is returned if the resource does not exist Get ( ctx context . Context , r RepositoryRef ) ( * Repository , error ) // List all repositories in the given organization // List should return all available organizations, using multiple paginated requests if needed List ( ctx context . Context , o OrganizationRef ) ([] Repository , error ) // Create creates a repository at the given organization path, with the given URL-encoded name and options // ErrAlreadyExists will be returned if the resource already exists Create ( ctx context . Context , r * Repository , opts RepositoryCreateOptions ) ( * Repository , error ) // Reconcile makes sure r is the actual state in the backing Git provider. If r doesn't exist // under the hood, it is created. If r is already the actual state, this is a no-op. If r isn't // the actual state, the resource will either be updated or deleted/recreated. Reconcile ( ctx context . Context , r * Repository ) error } RepositoryCreateOptions has options like AutoInit *bool , LicenseTemplate *string and so forth to allow an one-time initialization step. The Repository struct is defined as follows: // Repository represents a Git repository provided by a Git provider type Repository struct { // RepositoryInfo provides the required fields // (Domain, Organization, SubOrganizations and RepositoryName) // required for being an RepositoryRef RepositoryInfo `json:\",inline\"` // InternalHolder implements the InternalGetter interface // +optional InternalHolder `json:\",inline\"` // Description returns a description for the repository // No default value at POST-time // +optional Description * string `json:\"description\"` // Visibility returns the desired visibility for the repository // Default value at POST-time: RepoVisibilityPrivate // +optional Visibility * RepoVisibility } // GetCloneURL gets the clone URL for the specified transport type func ( r * Repository ) GetCloneURL ( transport TransportType ) string { return GetCloneURL ( r , transport ) } As can be seen, there is also a GetCloneURL function for the repository which allows resolving the URL from which to clone the repo, for a given transport method ( ssh and https are supported TransportType s)","title":"RepositoriesClient"},{"location":"proposals/go-git-providers/#repositoryclient","text":"RepositoryClient allows access to a given repository's underlying resources, like follows: // RepositoryClient operates on a given/specific repository type RepositoryClient interface { // TeamAccess gives access to what teams have access to this specific repository TeamAccess () RepositoryTeamAccessClient // Credentials gives access to manipulating credentials for accessing this specific repository Credentials () RepositoryCredentialsClient }","title":"RepositoryClient"},{"location":"proposals/go-git-providers/#repository-teams","text":"RepositoryTeamAccessClient allows adding & removing teams from the list of authorized persons to access a repository. // RepositoryTeamAccessClient operates on the teams list for a specific repository type RepositoryTeamAccessClient interface { // Create adds a given team to the repo's team access control list // ErrAlreadyExists will be returned if the resource already exists // The embedded RepositoryInfo of ta does not need to be populated, but if it is, // it must equal to the RepositoryRef given to the RepositoryClient. Create ( ctx context . Context , ta * TeamAccess , opts RepositoryAddTeamOptions ) error // Lists the team access control list for this repo List ( ctx context . Context ) ([] TeamAccess , error ) // Reconcile makes sure ta is the actual state in the backing Git provider. If ta doesn't exist // under the hood, it is created. If ta is already the actual state, this is a no-op. If ta isn't // the actual state, the resource will either be updated or deleted/recreated. // The embedded RepositoryInfo of ta does not need to be populated, but if it is, // it must equal to the RepositoryRef given to the RepositoryClient. Reconcile ( ctx context . Context , ta * TeamAccess ) error // Delete removes the given team from the repo's team access control list // ErrNotFound is returned if the resource does not exist Delete ( ctx context . Context , teamName string ) error } The TeamAccess struct looks as follows: // TeamAccess describes a binding between a repository and a team type TeamAccess struct { // TeamAccess embeds RepositoryInfo which makes it automatically comply with RepositoryRef // +optional RepositoryInfo `json:\",inline\"` // TeamAccess embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Name describes the name of the team. The team name may contain slashes // +required Name string `json:\"name\"` // Permission describes the permission level for which the team is allowed to operate // Default: read // Available options: See the TeamRepositoryPermission enum // +optional Permission * TeamRepositoryPermission }","title":"Repository Teams"},{"location":"proposals/go-git-providers/#repository-credentials","text":"RepositoryCredentialsClient allows adding & removing credentials (e.g. deploy keys) from accessing a specific repository. // RepositoryCredentialsClient operates on the access credential list for a specific repository type RepositoryCredentialsClient interface { // Create a credential with the given human-readable name, the given bytes and optional options // ErrAlreadyExists will be returned if the resource already exists Create ( ctx context . Context , c RepositoryCredential , opts CredentialCreateOptions ) error // Lists all credentials for the given credential type List ( ctx context . Context , t RepositoryCredentialType ) ([] RepositoryCredential , error ) // Reconcile makes sure c is the actual state in the backing Git provider. If c doesn't exist // under the hood, it is created. If c is already the actual state, this is a no-op. If c isn't // the actual state, the resource will either be updated or deleted/recreated. Reconcile ( ctx context . Context , c RepositoryCredential ) error // Deletes a credential from the repo. name corresponds to GetName() of the credential // ErrNotFound is returned if the resource does not exist Delete ( ctx context . Context , t RepositoryCredentialType , name string ) error } In order to support multiple different types of credentials, RepositoryCredential is an interface: // RepositoryCredential is a credential that allows access (either read-only or read-write) to the repo type RepositoryCredential interface { // GetType returns the type of the credential GetType () RepositoryCredentialType // GetName returns a name (or title/description) of the credential GetName () string // GetData returns the key that will be authorized to access the repo, this can e.g. be a SSH public key GetData () [] byte // IsReadOnly returns whether this credential is authorized to write to the repository or not IsReadOnly () bool } The default implementation of RepositoryCredential is DeployKey : // DeployKey represents a short-lived credential (e.g. an SSH public key) used for accessing a repository type DeployKey struct { // DeployKey embeds InternalHolder for accessing the underlying object // +optional InternalHolder `json:\",inline\"` // Title is the human-friendly interpretation of what the key is for (and does) // +required Title string `json:\"title\"` // Key specifies the public part of the deploy (e.g. SSH) key // +required Key [] byte `json:\"key\"` // ReadOnly specifies whether this DeployKey can write to the repository or not // Default value at POST-time: true // +optional ReadOnly * bool `json:\"readOnly\"` }","title":"Repository Credentials"},{"location":"roadmap/","text":"Roadmap \u00b6 In our planning discussions for the GitOps Toolkit we identified largely three areas of work: Feature parity with Flux v1 in read-only mode Feature parity with the image-update functionality in Flux v1 Feature parity with Helm Operator v1 All of the above will constitute \"Flux v2\". The road to Flux v2 \u00b6 Flux read-only feature parity \u00b6 90% This would be the first stepping stone: we want the GitOps Toolkit to be on-par with today's Flux in read-only mode and FluxCloud notifications. Goals Offer a migration guide for those that are using Flux in read-only mode to synchronize plain manifests Offer a migration guide for those that are using Flux in read-only mode to synchronize Kustomize overlays Offer a dedicated component for forwarding events to external messaging platforms Non-Goals Migrate users that are using Flux to run custom scripts with flux.yaml Automate the migration of flux.yaml kustomize users Tasks Design the events API Implement events in source and kustomize controllers Make the kustomize-controller apply/gc events on-par with Flux v1 apply events Design the notifications and events filtering API Implement a notification controller for Slack, MS Teams, Discord, Rocket Implement Prometheus metrics in source and kustomize controllers Review the git source and kustomize APIs Create a migration guide for flux.yaml kustomize users Include support for SOPS Flux image update feature parity \u00b6 0% Goals Offer components that can replace Flux v1 image update feature Non-Goals Maintain backwards compatibility with Flux v1 annotations Tasks Design the image scanning and automation API Implement an image scanning controller Design the automation component Implement the image scan/patch/push workflow Integrate the new components in the toolkit assembler Create a migration guide from Flux annotations The road to Helm Operator v2 \u00b6 Helm v3 feature parity \u00b6 100% Goals Offer a migration guide for those that are using Helm Operator with Helm v3 and charts from Helm and Git repositories Non-Goals Migrate users that are using Helm v2 Tasks Implement a Helm controller for Helm v3 covering all the current release options Discuss and design Helm releases based on source API: Providing values from sources Conditional remediation on failed Helm actions Support for Helm charts from Git Review the Helm release, chart and repository APIs Implement events in Helm controller Implement Prometheus metrics in Helm controller Implement support for values from Secret and ConfigMap resources Implement conditional remediation on (failed) Helm actions Implement support for Helm charts from Git Implement support for referring to an alternative chart values file Stabilize API Create a migration guide for Helm Operator users","title":"Roadmap"},{"location":"roadmap/#roadmap","text":"In our planning discussions for the GitOps Toolkit we identified largely three areas of work: Feature parity with Flux v1 in read-only mode Feature parity with the image-update functionality in Flux v1 Feature parity with Helm Operator v1 All of the above will constitute \"Flux v2\".","title":"Roadmap"},{"location":"roadmap/#the-road-to-flux-v2","text":"","title":"The road to Flux v2"},{"location":"roadmap/#flux-read-only-feature-parity","text":"90% This would be the first stepping stone: we want the GitOps Toolkit to be on-par with today's Flux in read-only mode and FluxCloud notifications. Goals Offer a migration guide for those that are using Flux in read-only mode to synchronize plain manifests Offer a migration guide for those that are using Flux in read-only mode to synchronize Kustomize overlays Offer a dedicated component for forwarding events to external messaging platforms Non-Goals Migrate users that are using Flux to run custom scripts with flux.yaml Automate the migration of flux.yaml kustomize users Tasks Design the events API Implement events in source and kustomize controllers Make the kustomize-controller apply/gc events on-par with Flux v1 apply events Design the notifications and events filtering API Implement a notification controller for Slack, MS Teams, Discord, Rocket Implement Prometheus metrics in source and kustomize controllers Review the git source and kustomize APIs Create a migration guide for flux.yaml kustomize users Include support for SOPS","title":"Flux read-only feature parity"},{"location":"roadmap/#flux-image-update-feature-parity","text":"0% Goals Offer components that can replace Flux v1 image update feature Non-Goals Maintain backwards compatibility with Flux v1 annotations Tasks Design the image scanning and automation API Implement an image scanning controller Design the automation component Implement the image scan/patch/push workflow Integrate the new components in the toolkit assembler Create a migration guide from Flux annotations","title":"Flux image update feature parity"},{"location":"roadmap/#the-road-to-helm-operator-v2","text":"","title":"The road to Helm Operator v2"},{"location":"roadmap/#helm-v3-feature-parity","text":"100% Goals Offer a migration guide for those that are using Helm Operator with Helm v3 and charts from Helm and Git repositories Non-Goals Migrate users that are using Helm v2 Tasks Implement a Helm controller for Helm v3 covering all the current release options Discuss and design Helm releases based on source API: Providing values from sources Conditional remediation on failed Helm actions Support for Helm charts from Git Review the Helm release, chart and repository APIs Implement events in Helm controller Implement Prometheus metrics in Helm controller Implement support for values from Secret and ConfigMap resources Implement conditional remediation on (failed) Helm actions Implement support for Helm charts from Git Implement support for referring to an alternative chart values file Stabilize API Create a migration guide for Helm Operator users","title":"Helm v3 feature parity"}]}